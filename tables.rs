//! Implementation of Unicode Standard Annex #31 for 
//! determining which `char` values are valid in programming language identifiers.
#![feature
( 
    
 )]

#![allow
( 
    bare_trait_objects,
    deprecated,
    mismatched_lifetime_syntaxes,
    non_camel_case_types,
    non_fmt_panics,
    non_snake_case,
    non_upper_case_globals,
    static_mut_refs,
    unpredictable_function_pointer_comparisons,
    unused_attributes,
    unused_imports,
    unused_macros,
    unused_variables,
 )]
/*
pub mod _
{
    pub use std::_::{ * };
}

pub mod __
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
}

pub mod error;
pub mod obj;
pub mod tup;
pub mod types;
pub mod value;
pub mod parse;

#[macro_use] extern crate bitflags;
#[macro_use] extern crate lazy_static;
*/

#[macro_use] extern crate libc;
#[macro_use] extern crate rand;
#[macro_use] extern crate regex as re;
#[macro_use] extern crate smallvec;
#[macro_use] extern crate time as temporal;
#[macro_use] extern crate unicode_normalization;
#[macro_use] extern crate unicode_width;

#[macro_use] pub mod macros
{   
    /*!
    */
    pub use std::
    {
        assert, assert_eq, assert_ne, cfg, column, compile_error, concat, dbg, debug_assert, debug_assert_eq, 
        debug_assert_ne, env, eprint, eprintln, file, format, format_args, include, include_bytes, include_str, 
        is_x86_feature_detected, line, matches, module_path, option_env, panic, print, println, stringify, 
        thread_local, todo, unimplemented, unreachable, vec, write, writeln
    };

    use ::
    {
        cell::{ Cell },
        mem::{ MaybeUninit },
        sync::{ Once, ONCE_INIT },
        *
    };
    /// Performs variable interpolation against the input and produces it as [`process::macros::TokenStream`].
    #[macro_export] macro_rules! quote
    {
        () =>
        {
            ::__private::TokenStream::new()
        };
       
        ( $tt:tt ) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt _s}
            _s
        }};
       
        
        ( # $var:ident ) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::ToTokens::to_tokens( &$var, &mut _s );
            _s
        }};
        
        ( $tt1:tt $tt2:tt ) =>
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt1 _s}
            ::quote_token!{$tt2 _s}
            _s
        }};
       
        ( $( $tt:tt )* ) => {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_each_token!{_s $( $tt )*}
            _s
        }};
    }
    /// Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.
    #[macro_export] macro_rules! quote_spanned
    {
        ( $span:expr=> ) => {{
            let _: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::__private::TokenStream::new()
        }};
       
        ( $span:expr=> $tt:tt ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::quote_token_spanned!{$tt _s _span}
            _s
        }};
       
        ( $span:expr=> # $var:ident ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::ToTokens::to_tokens( &$var, &mut _s );
            _s
        }};
        ( $span:expr=> $tt1:tt $tt2:tt ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::quote_token_spanned!{$tt1 _s _span}
            ::quote_token_spanned!{$tt2 _s _span}
            _s
        }};
       
        ( $span:expr=> $( $tt:tt )* ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::quote_each_token_spanned!{_s _span $( $tt )*}
            _s
        }};
    }
   
    #[macro_export] macro_rules! pounded_var_names
    {
        ( $call:ident! $extra:tt $( $tts:tt )* ) => {
            ::pounded_var_names_with_context!{$call! $extra
                ( @ $( $tts )* )
                ( $( $tts )* @ )
            }
        };
    }

    #[macro_export] macro_rules! pounded_var_names_with_context
    {
        ( $call:ident! $extra:tt ( $( $b1:tt )* ) ( $( $curr:tt )* ) ) => {
            $( 
                ::pounded_var_with_context!{$call! $extra $b1 $curr}
            )*
        };
    }

    #[macro_export] macro_rules! pounded_var_with_context
    {
        ( $call:ident! $extra:tt $b1:tt ( $( $inner:tt )* ) ) => {
            ::pounded_var_names!{$call! $extra $( $inner )*}
        };

        ( $call:ident! $extra:tt $b1:tt [ $( $inner:tt )* ] ) => {
            ::pounded_var_names!{$call! $extra $( $inner )*}
        };

        ( $call:ident! $extra:tt $b1:tt { $( $inner:tt )* } ) => {
            ::pounded_var_names!{$call! $extra $( $inner )*}
        };

        ( $call:ident!( $( $extra:tt )* ) # $var:ident ) => {
            ::$call!( $( $extra )* $var );
        };

        ( $call:ident! $extra:tt $b1:tt $curr:tt ) => {};
    }

    #[macro_export] macro_rules! quote_bind_into_iter 
    {
        ( $has_iter:ident $var:ident ) => {
           
            #[allow( unused_mut )]
            let ( mut $var, i ) = $var.quote_into_iter();
            let $has_iter = $has_iter | i;
        };
    }

    #[macro_export] macro_rules! quote_bind_next_or_break 
    {
        ( $var:ident ) =>
        {
            let $var = match $var.next() {
                Some( _x ) => ::__private::RepInterp( _x ),
                None => break,
            };
        };
    }
    
    #[macro_export] macro_rules! quote_each_token 
    {
        ( $tokens:ident $( $tts:tt )* ) => {
            ::quote_tokens_with_context!{$tokens
                ( @ @ @ @ @ @ $( $tts )* )
                ( @ @ @ @ @ $( $tts )* @ )
                ( @ @ @ @ $( $tts )* @ @ )
                ( @ @ @ $( ( $tts ) )* @ @ @ )
                ( @ @ $( $tts )* @ @ @ @ )
                ( @ $( $tts )* @ @ @ @ @ )
                ( $( $tts )* @ @ @ @ @ @ )
            }
        };
    }

    #[macro_export] macro_rules! quote_each_token_spanned 
    {
        ( $tokens:ident $span:ident $( $tts:tt )* ) => {
            ::quote_tokens_with_context_spanned!{$tokens $span
                ( @ @ @ @ @ @ $( $tts )* )
                ( @ @ @ @ @ $( $tts )* @ )
                ( @ @ @ @ $( $tts )* @ @ )
                ( @ @ @ $( ( $tts ) )* @ @ @ )
                ( @ @ $( $tts )* @ @ @ @ )
                ( @ $( $tts )* @ @ @ @ @ )
                ( $( $tts )* @ @ @ @ @ @ )
            }
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context
    {
        ( $tokens:ident
            ( $( $b3:tt )* ) ( $( $b2:tt )* ) ( $( $b1:tt )* )
            ( $( $curr:tt )* )
            ( $( $a1:tt )* ) ( $( $a2:tt )* ) ( $( $a3:tt )* )
        ) => {
            $( 
                ::quote_token_with_context!{$tokens $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context_spanned
    {
        ( $tokens:ident $span:ident
            ( $( $b3:tt )* ) ( $( $b2:tt )* ) ( $( $b1:tt )* )
            ( $( $curr:tt )* )
            ( $( $a1:tt )* ) ( $( $a2:tt )* ) ( $( $a3:tt )* )
        ) => {
            $( 
                ::quote_token_with_context_spanned!{$tokens $span $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_token_with_context
    {  
        ( $tokens:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) * $a3:tt ) => 
        {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            
            while true 
            {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                ::quote_each_token!{$tokens $( $inner )*}
            }
        }};
       
        ( $tokens:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) * $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt # ( $( $inner:tt )* ) ( * ) $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) $sep:tt * ) => 
        {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                if _i > 0 {
                    ::quote_token!{$sep $tokens}
                }
                _i += 1;
                ::quote_each_token!{$tokens $( $inner )*}
            }
        }};
       
        ( $tokens:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) $sep:tt * $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt # ( $( $inner:tt )* ) ( $sep:tt ) * $a2:tt $a3:tt ) => {};
       
       
        ( $tokens:ident # ( $( $inner:tt )* ) * ( * ) $a1:tt $a2:tt $a3:tt ) => {
            ::quote_token!{* $tokens}
        };
       
        ( $tokens:ident # ( $( $inner:tt )* ) $sep:tt ( * ) $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( # ) $var:ident $a2:tt $a3:tt ) => {
            ::ToTokens::to_tokens( &$var, &mut $tokens );
        };
       
        ( $tokens:ident $b3:tt $b2:tt # ( $var:ident ) $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( $curr:tt ) $a1:tt $a2:tt $a3:tt ) => {
            ::quote_token!{$curr $tokens}
        };
    }
    
    #[macro_export] macro_rules! quote_token_with_context_spanned 
    {
        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) * $a3:tt ) => {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                ::quote_each_token_spanned!{$tokens $span $( $inner )*}
            }
        }};
        ( $tokens:ident $span:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) * $a2:tt $a3:tt ) => {};
        ( $tokens:ident $span:ident $b3:tt # ( $( $inner:tt )* ) ( * ) $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) $sep:tt * ) => {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                if _i > 0 {
                    ::quote_token_spanned!{$sep $tokens $span}
                }
                _i += 1;
                ::quote_each_token_spanned!{$tokens $span $( $inner )*}
            }
        }};
        ( $tokens:ident $span:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) $sep:tt * $a3:tt ) => {};
        ( $tokens:ident $span:ident $b3:tt # ( $( $inner:tt )* ) ( $sep:tt ) * $a2:tt $a3:tt ) => {};
        ( $tokens:ident $span:ident # ( $( $inner:tt )* ) * ( * ) $a1:tt $a2:tt $a3:tt ) => {
            ::quote_token_spanned!{* $tokens $span}
        };
        ( $tokens:ident $span:ident # ( $( $inner:tt )* ) $sep:tt ( * ) $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( # ) $var:ident $a2:tt $a3:tt ) => {
            ::ToTokens::to_tokens( &$var, &mut $tokens );
        };
        ( $tokens:ident $span:ident $b3:tt $b2:tt # ( $var:ident ) $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( $curr:tt ) $a1:tt $a2:tt $a3:tt ) => {
            ::quote_token_spanned!{$curr $tokens $span}
        };
    }
    
    #[macro_export] macro_rules! quote_token
    {
        ( $ident:ident $tokens:ident ) =>
        {
            ::__private::push_ident( &mut $tokens, stringify!( $ident ) );
        };

        ( :: $tokens:ident ) =>
        {
            ::__private::push_colon2( &mut $tokens );
        };

        ( ( $( $inner:tt )* ) $tokens:ident ) =>
        {
            ::__private::push_group
            ( 
                &mut $tokens,
                ::__private::Delimiter::Parenthesis,
                ::quote!( $( $inner )* ),
             );
        };

        ( [ $( $inner:tt )* ] $tokens:ident ) =>
        {
            ::__private::push_group
            ( 
                &mut $tokens,
                ::__private::Delimiter::Bracket,
                ::quote!( $( $inner )* ),
             );
        };

        ( { $( $inner:tt )* } $tokens:ident ) =>
        {
            ::__private::push_group
            ( 
                &mut $tokens,
                ::__private::Delimiter::Brace,
                ::quote!( $( $inner )* ),
             );
        };

        ( # $tokens:ident ) =>
        {
            ::__private::push_pound( &mut $tokens );
        };

        ( , $tokens:ident ) =>
        {
            ::__private::push_comma( &mut $tokens );
        };

        ( . $tokens:ident ) =>
        {
            ::__private::push_dot( &mut $tokens );
        };

        ( ; $tokens:ident ) =>
        {
            ::__private::push_semi( &mut $tokens );
        };

        ( : $tokens:ident ) =>
        {
            ::__private::push_colon( &mut $tokens );
        };

        ( + $tokens:ident ) =>
        {
            ::__private::push_add( &mut $tokens );
        };

        ( += $tokens:ident ) =>
        {
            ::__private::push_add_eq( &mut $tokens );
        };

        ( & $tokens:ident ) =>
        {
            ::__private::push_and( &mut $tokens );
        };

        ( && $tokens:ident ) =>
        {
            ::__private::push_and_and( &mut $tokens );
        };

        ( &= $tokens:ident ) =>
        {
            ::__private::push_and_eq( &mut $tokens );
        };

        ( @ $tokens:ident ) =>
        {
            ::__private::push_at( &mut $tokens );
        };

        ( ! $tokens:ident ) =>
        {
            ::__private::push_bang( &mut $tokens );
        };

        ( ^ $tokens:ident ) =>
        {
            ::__private::push_caret( &mut $tokens );
        };

        ( ^= $tokens:ident ) =>
        {
            ::__private::push_caret_eq( &mut $tokens );
        };

        ( / $tokens:ident ) =>
        {
            ::__private::push_div( &mut $tokens );
        };

        ( /= $tokens:ident ) =>
        {
            ::__private::push_div_eq( &mut $tokens );
        };

        ( .. $tokens:ident ) =>
        {
            ::__private::push_dot2( &mut $tokens );
        };

        ( ... $tokens:ident ) =>
        {
            ::__private::push_dot3( &mut $tokens );
        };

        ( ..= $tokens:ident ) =>
        {
            ::__private::push_dot_dot_eq( &mut $tokens );
        };

        ( = $tokens:ident ) =>
        {
            ::__private::push_eq( &mut $tokens );
        };

        ( == $tokens:ident ) =>
        {
            ::__private::push_eq_eq( &mut $tokens );
        };

        ( >= $tokens:ident ) =>
        {
            ::__private::push_ge( &mut $tokens );
        };

        ( > $tokens:ident ) =>
        {
            ::__private::push_gt( &mut $tokens );
        };

        ( <= $tokens:ident ) =>
        {
            ::__private::push_le( &mut $tokens );
        };

        ( < $tokens:ident ) =>
        {
            ::__private::push_lt( &mut $tokens );
        };

        ( *= $tokens:ident ) =>
        {
            ::__private::push_mul_eq( &mut $tokens );
        };

        ( != $tokens:ident ) =>
        {
            ::__private::push_ne( &mut $tokens );
        };

        ( | $tokens:ident ) =>
        {
            ::__private::push_or( &mut $tokens );
        };

        ( |= $tokens:ident ) =>
        {
            ::__private::push_or_eq( &mut $tokens );
        };

        ( || $tokens:ident ) =>
        {
            ::__private::push_or_or( &mut $tokens );
        };

        ( ? $tokens:ident ) =>
        {
            ::__private::push_question( &mut $tokens );
        };

        ( -> $tokens:ident ) =>
        {
            ::__private::push_rarrow( &mut $tokens );
        };

        ( <- $tokens:ident ) =>
        {
            ::__private::push_larrow( &mut $tokens );
        };

        ( % $tokens:ident ) =>
        {
            ::__private::push_rem( &mut $tokens );
        };

        ( %= $tokens:ident ) =>
        {
            ::__private::push_rem_eq( &mut $tokens );
        };

        ( => $tokens:ident ) =>
        {
            ::__private::push_fat_arrow( &mut $tokens );
        };

        ( << $tokens:ident ) =>
        {
            ::__private::push_shl( &mut $tokens );
        };

        ( <<= $tokens:ident ) =>
        {
            ::__private::push_shl_eq( &mut $tokens );
        };

        ( >> $tokens:ident ) =>
        {
            ::__private::push_shr( &mut $tokens );
        };

        ( >>= $tokens:ident ) =>
        {
            ::__private::push_shr_eq( &mut $tokens );
        };

        ( * $tokens:ident ) =>
        {
            ::__private::push_star( &mut $tokens );
        };

        ( - $tokens:ident ) =>
        {
            ::__private::push_sub( &mut $tokens );
        };

        ( -= $tokens:ident ) =>
        {
            ::__private::push_sub_eq( &mut $tokens );
        };

        ( $lifetime:lifetime $tokens:ident ) =>
        {
            ::__private::push_lifetime( &mut $tokens, stringify!( $lifetime ) );
        };

        ( _ $tokens:ident ) =>
        {
            ::__private::push_underscore( &mut $tokens );
        };

        ( $other:tt $tokens:ident ) =>
        {
            ::__private::parse( &mut $tokens, stringify!( $other ) );
        };
    }

    #[macro_export] macro_rules! quote_token_spanned
    {
        ( $ident:ident $tokens:ident $span:ident ) =>
        {
            ::__private::push_ident_spanned( &mut $tokens, $span, stringify!( $ident ) );
        };

        ( :: $tokens:ident $span:ident ) =>
        {
            ::__private::push_colon2_spanned( &mut $tokens, $span );
        };

        ( ( $( $inner:tt )* ) $tokens:ident $span:ident ) =>
        {
            ::__private::push_group_spanned            
            ( 
                &mut $tokens,
                $span,
                ::__private::Delimiter::Parenthesis,
                ::quote_spanned!( $span=> $( $inner )* ),
             );
        };

        ( [ $( $inner:tt )* ] $tokens:ident $span:ident ) =>
        {
            ::__private::push_group_spanned
            ( 
                &mut $tokens,
                $span,
                ::__private::Delimiter::Bracket,
                ::quote_spanned!( $span=> $( $inner )* ),
             );
        };

        ( { $( $inner:tt )* } $tokens:ident $span:ident ) =>
        {
            ::__private::push_group_spanned
            
            ( 
                &mut $tokens,
                $span,
                ::__private::Delimiter::Brace,
                ::quote_spanned!( $span=> $( $inner )* ),
             );
        };

        ( # $tokens:ident $span:ident ) =>
        {
            ::__private::push_pound_spanned( &mut $tokens, $span );
        };

        ( , $tokens:ident $span:ident ) =>
        {
            ::__private::push_comma_spanned( &mut $tokens, $span );
        };

        ( . $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot_spanned( &mut $tokens, $span );
        };

        ( ; $tokens:ident $span:ident ) =>
        {
            ::__private::push_semi_spanned( &mut $tokens, $span );
        };

        ( : $tokens:ident $span:ident ) =>
        {
            ::__private::push_colon_spanned( &mut $tokens, $span );
        };

        ( + $tokens:ident $span:ident ) =>
        {
            ::__private::push_add_spanned( &mut $tokens, $span );
        };

        ( += $tokens:ident $span:ident ) =>
        {
            ::__private::push_add_eq_spanned( &mut $tokens, $span );
        };

        ( & $tokens:ident $span:ident ) =>
        {
            ::__private::push_and_spanned( &mut $tokens, $span );
        };

        ( && $tokens:ident $span:ident ) =>
        {
            ::__private::push_and_and_spanned( &mut $tokens, $span );
        };

        ( &= $tokens:ident $span:ident ) =>
        {
            ::__private::push_and_eq_spanned( &mut $tokens, $span );
        };

        ( @ $tokens:ident $span:ident ) =>
        {
            ::__private::push_at_spanned( &mut $tokens, $span );
        };

        ( ! $tokens:ident $span:ident ) =>
        {
            ::__private::push_bang_spanned( &mut $tokens, $span );
        };

        ( ^ $tokens:ident $span:ident ) =>
        {
            ::__private::push_caret_spanned( &mut $tokens, $span );
        };

        ( ^= $tokens:ident $span:ident ) =>
        {
            ::__private::push_caret_eq_spanned( &mut $tokens, $span );
        };

        ( / $tokens:ident $span:ident ) =>
        {
            ::__private::push_div_spanned( &mut $tokens, $span );
        };

        ( /= $tokens:ident $span:ident ) =>
        {
            ::__private::push_div_eq_spanned( &mut $tokens, $span );
        };

        ( .. $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot2_spanned( &mut $tokens, $span );
        };

        ( ... $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot3_spanned( &mut $tokens, $span );
        };

        ( ..= $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot_dot_eq_spanned( &mut $tokens, $span );
        };

        ( = $tokens:ident $span:ident ) =>
        {
            ::__private::push_eq_spanned( &mut $tokens, $span );
        };

        ( == $tokens:ident $span:ident ) =>
        {
            ::__private::push_eq_eq_spanned( &mut $tokens, $span );
        };

        ( >= $tokens:ident $span:ident ) =>
        {
            ::__private::push_ge_spanned( &mut $tokens, $span );
        };

        ( > $tokens:ident $span:ident ) =>
        {
            ::__private::push_gt_spanned( &mut $tokens, $span );
        };

        ( <= $tokens:ident $span:ident ) =>
        {
            ::__private::push_le_spanned( &mut $tokens, $span );
        };

        ( < $tokens:ident $span:ident ) =>
        {
            ::__private::push_lt_spanned( &mut $tokens, $span );
        };

        ( *= $tokens:ident $span:ident ) =>
        {
            ::__private::push_mul_eq_spanned( &mut $tokens, $span );
        };

        ( != $tokens:ident $span:ident ) =>
        {
            ::__private::push_ne_spanned( &mut $tokens, $span );
        };

        ( | $tokens:ident $span:ident ) =>
        {
            ::__private::push_or_spanned( &mut $tokens, $span );
        };

        ( |= $tokens:ident $span:ident ) =>
        {
            ::__private::push_or_eq_spanned( &mut $tokens, $span );
        };

        ( || $tokens:ident $span:ident ) =>
        {
            ::__private::push_or_or_spanned( &mut $tokens, $span );
        };

        ( ? $tokens:ident $span:ident ) =>
        {
            ::__private::push_question_spanned( &mut $tokens, $span );
        };

        ( -> $tokens:ident $span:ident ) =>
        {
            ::__private::push_rarrow_spanned( &mut $tokens, $span );
        };

        ( <- $tokens:ident $span:ident ) =>
        {
            ::__private::push_larrow_spanned( &mut $tokens, $span );
        };

        ( % $tokens:ident $span:ident ) =>
        {
            ::__private::push_rem_spanned( &mut $tokens, $span );
        };

        ( %= $tokens:ident $span:ident ) =>
        {
            ::__private::push_rem_eq_spanned( &mut $tokens, $span );
        };

        ( => $tokens:ident $span:ident ) =>
        {
            ::__private::push_fat_arrow_spanned( &mut $tokens, $span );
        };

        ( << $tokens:ident $span:ident ) =>
        {
            ::__private::push_shl_spanned( &mut $tokens, $span );
        };

        ( <<= $tokens:ident $span:ident ) =>
        {
            ::__private::push_shl_eq_spanned( &mut $tokens, $span );
        };

        ( >> $tokens:ident $span:ident ) =>
        {
            ::__private::push_shr_spanned( &mut $tokens, $span );
        };

        ( >>= $tokens:ident $span:ident ) =>
        {
            ::__private::push_shr_eq_spanned( &mut $tokens, $span );
        };

        ( * $tokens:ident $span:ident ) =>
        {
            ::__private::push_star_spanned( &mut $tokens, $span );
        };

        ( - $tokens:ident $span:ident ) =>
        {
            ::__private::push_sub_spanned( &mut $tokens, $span );
        };

        ( -= $tokens:ident $span:ident ) =>
        {
            ::__private::push_sub_eq_spanned( &mut $tokens, $span );
        };

        ( $lifetime:lifetime $tokens:ident $span:ident ) =>
        {
            ::__private::push_lifetime_spanned( &mut $tokens, $span, stringify!( $lifetime ) );
        };

        ( _ $tokens:ident $span:ident ) =>
        {
            ::__private::push_underscore_spanned( &mut $tokens, $span );
        };

        ( $other:tt $tokens:ident $span:ident ) =>
        {
            ::__private::parse_spanned( &mut $tokens, $span, stringify!( $other ) );
        };
    }

    #[macro_export] macro_rules! format_ident
    {
        ( $fmt:expr ) => {
            format_ident_impl!( [
                ::quote::__private::Option::None,
                $fmt
            ] )
        };

        ( $fmt:expr, $( $rest:tt )* ) => {
            format_ident_impl!( [
                ::quote::__private::Option::None,
                $fmt
            ] $( $rest )* )
        };
    }

    #[macro_export] macro_rules! format_ident_impl
    {
       
        ( [$span:expr, $( $fmt:tt )*] ) => {
            ::quote::__private::mk_ident( 
                &::quote::__private::format!( $( $fmt )* ),
                $span,
            )
        };

       
        ( [$old:expr, $( $fmt:tt )*] span = $span:expr ) => {
            format_ident_impl!( [$old, $( $fmt )*] span = $span, )
        };
        ( [$old:expr, $( $fmt:tt )*] span = $span:expr, $( $rest:tt )* ) => {
            format_ident_impl!( [
                ::quote::__private::Option::Some::<::quote::__private::Span>( $span ),
                $( $fmt )*
            ] $( $rest )* )
        };

       
        ( [$span:expr, $( $fmt:tt )*] $name:ident = $arg:expr ) => {
            format_ident_impl!( [$span, $( $fmt )*] $name = $arg, )
        };
        ( [$span:expr, $( $fmt:tt )*] $name:ident = $arg:expr, $( $rest:tt )* ) => {
            match ::quote::__private::IdentFragmentAdapter( &$arg ) {
                arg => format_ident_impl!( [$span.or( arg.span() ), $( $fmt )*, $name = arg] $( $rest )* ),
            }
        };

       
        ( [$span:expr, $( $fmt:tt )*] $arg:expr ) => {
            format_ident_impl!( [$span, $( $fmt )*] $arg, )
        };
        ( [$span:expr, $( $fmt:tt )*] $arg:expr, $( $rest:tt )* ) => {
            match ::quote::__private::IdentFragmentAdapter( &$arg ) {
                arg => format_ident_impl!( [$span.or( arg.span() ), $( $fmt )*, arg] $( $rest )* ),
            }
        };
    }

    #[macro_export] macro_rules! ast_struct 
    {
        ( 
            $( #[$attr:meta] )*
            $pub:ident $struct:ident $name:ident #full $body:tt
        ) =>
        {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( struct $struct );
            $( #[$attr] )* $pub $struct $name $body
        };

        ( 
            $( #[$attr:meta] )*
            $pub:ident $struct:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( struct $struct );

            $( #[$attr] )* $pub $struct $name $body
        };
    }
    
    #[macro_export] macro_rules! ast_enum
    {
        ( 
            $( #[$enum_attr:meta] )*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( enum $enum );

            $( #[$enum_attr] )* $pub $enum $name $body
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs
    {
        ( 
            $( #[$enum_attr:meta] )*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( enum $enum );

            $( #[$enum_attr] )* $pub $enum $name $body

            ast_enum_of_structs_impl!( $name $body );

                generate_to_tokens!( () tokens $name $body );
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs_impl
    {
        ( 
            $name:ident {
                $( 
                    $( #[cfg $cfg_attr:tt] )*
                    $( #[doc $( $doc_attr:tt )*] )*
                    $variant:ident $( ( $member:ident ) )*,
                )*
            }
        ) => {
            $( $( 
                ast_enum_from_struct!( $name::$variant, $member );
            )* )*
        };
    }

    #[macro_export] macro_rules! ast_enum_from_struct
    {
        ( $name:ident::Verbatim, $member:ident ) => {};

        ( $name:ident::$variant:ident, $member:ident ) =>
        {
            impl From<$member> for $name
            {
                fn from( e: $member ) -> $name {
                    $name::$variant( e )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! generate_to_tokens
    {
        ( 
            ( $( $arms:tt )* ) $tokens:ident $name:ident {
                $( #[cfg $cfg_attr:tt] )*
                $( #[doc $( $doc_attr:tt )*] )*
                $variant:ident,
                $( $next:tt )*
            }
        ) => {
            generate_to_tokens!( 
                ( $( $arms )* $( #[cfg $cfg_attr] )* $name::$variant => {} )
                $tokens $name { $( $next )* }
             );
        };

        ( 
            ( $( $arms:tt )* ) $tokens:ident $name:ident {
                $( #[cfg $cfg_attr:tt] )*
                $( #[doc $( $doc_attr:tt )*] )*
                $variant:ident( $member:ident ),
                $( $next:tt )*
            }
        ) => {
            generate_to_tokens!( 
                ( $( $arms )* $( #[cfg $cfg_attr] )* $name::$variant( _e ) => _e.to_tokens( $tokens ), )
                $tokens $name { $( $next )* }
             );
        };

        ( ( $( $arms:tt )* ) $tokens:ident $name:ident {} ) => {
            impl ::quote::ToTokens for $name {
                fn to_tokens( &self, $tokens:&mut ::process::macros::TokenStream )
                {
                    match self {
                        $( $arms )*
                    }
                }
            }
        };
    }
    
    #[macro_export] macro_rules! pub_if_not_doc
    {
        ( $( #[$m:meta] )* $pub:ident $( $item:tt )* ) => {
            check_keyword_matches!( pub $pub );

            $( #[$m] )*
            $pub $( $item )*
        };
    }

    #[macro_export] macro_rules! check_keyword_matches 
    {
        ( enum enum ) => {};
        ( pub pub ) => {};
        ( struct struct ) => {};
    }

    #[macro_export] macro_rules! return_impl_trait
    {
        ( 
            $( #[$attr:meta] )*
            $vis:vis fn $name:ident $args:tt -> $impl_trait:ty [$concrete:ty] $body:block
        ) => {
            #[cfg( not( docsrs ) )]
            $( #[$attr] )*
            $vis fn $name $args -> $concrete $body

            #[cfg( docsrs )]
            $( #[$attr] )*
            $vis fn $name $args -> $impl_trait $body
        };
    }
    /// Parse a set of parentheses and expose their content to subsequent parsers.
    #[macro_export] macro_rules! parenthesized
    {
        ( $content:ident in $cursor:expr ) => {
            match ::syntax::__private::parse_parens( &$cursor ) {
                ::syntax::__private::Ok( parens ) => {
                    $content = parens.content;
                    parens.token
                }
                ::syntax::__private::Err( error ) => {
                    return ::syntax::__private::Err( error );
                }
            }
        };
    }
    /// Parse a set of curly braces and expose their content to subsequent parsers.
    #[macro_export] macro_rules! braced
    {
        ( $content:ident in $cursor:expr ) => 
        {
            match ::syntax::__private::parse_braces( &$cursor ) {
                ::syntax::__private::Ok( braces ) => {
                    $content = braces.content;
                    braces.token
                }
                ::syntax::__private::Err( error ) => {
                    return ::syntax::__private::Err( error );
                }
            }
        };
    }
    /// Parse a set of square brackets and expose their content to subsequent parsers.
    #[macro_export] macro_rules! bracketed
    {
        ( $content:ident in $cursor:expr ) =>
        {
            match ::syntax::__private::parse_brackets( &$cursor )
            {
                ::syntax::__private::Ok( brackets ) => {
                    $content = brackets.content;
                    brackets.token
                }
                ::syntax::__private::Err( error ) => {
                    return ::syntax::__private::Err( error );
                }
            }
        };
    }

    #[macro_export] macro_rules! parse_quote
    {
        ( $( $tt:tt )* ) =>
        {
            ::syntax::__private::parse_quote( ::syntax::__private::quote::quote!( $( $tt )* ) )
        };
    }
    /// This macro is [`parse_quote!`] + [`quote_spanned!`][quote::quote_spanned].
    #[macro_export] macro_rules! parse_quote_spanned
    {
        ( $span:expr=> $( $tt:tt )* ) =>
        {
            ::syntax::__private::parse_quote( ::syntax::__private::quote::quote_spanned!( $span=> $( $tt )* ) )
        };
    }
    
    #[macro_export] macro_rules! parse_macro_input
    {
        ( $tokenstream:ident as $ty:ty ) => {
            match ::syntax::parse::<$ty>( $tokenstream ) {
                ::syntax::__private::Ok( data ) => data,
                ::syntax::__private::Err( err ) => {
                    return ::syntax::__private::TokenStream::from( err.to_compile_error() );
                }
            }
        };
        ( $tokenstream:ident with $parser:path ) => {
            match ::syntax::parse::Parser::parse( $parser, $tokenstream ) {
                ::syntax::__private::Ok( data ) => data,
                ::syntax::__private::Err( err ) => {
                    return ::syntax::__private::TokenStream::from( err.to_compile_error() );
                }
            }
        };
        ( $tokenstream:ident ) => {
            ::syntax::parse_macro_input!( $tokenstream as _ )
        };
    }

    #[macro_export] macro_rules! custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) =>
        {
            pub struct $ident {
                #[allow( dead_code )]
                pub spans: ::syntax::custom_punctuation_repr!( $( $tt )+ ),
            }
                #[allow( dead_code, non_snake_case )]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::custom_punctuation_repr!( $( $tt )+ )>>( 
                spans: __S,
            ) -> $ident {
                let _validate_len = 0 $( + ::syntax::custom_punctuation_len!( strict, $tt ) )*;
                $ident {
                    spans: ::syntax::__private::IntoSpans::into_spans( spans )
                }
            }
            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident( ::syntax::__private::Span::call_site() )
                    }
                }
                ::syntax::impl_parse_for_custom_punctuation!( $ident, $( $tt )+ );
                ::syntax::impl_to_tokens_for_custom_punctuation!( $ident, $( $tt )+ );
                ::syntax::impl_clone_for_custom_punctuation!( $ident, $( $tt )+ );
                ::syntax::impl_extra_traits_for_custom_punctuation!( $ident, $( $tt )+ );
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::CustomToken for $ident {
                fn peek( cursor: ::syntax::buffer::Cursor ) -> ::syntax::__private::bool {
                    ::syntax::__private::peek_punct( cursor, ::syntax::stringify_punct!( $( $tt )+ ) )
                }
                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!( "`", ::syntax::stringify_punct!( $( $tt )+ ), "`" )
                }
            }
            
            impl ::syntax::parse::Parse for $ident
            {
                fn parse( input: ::syntax::parse::ParseStream ) -> ::syntax::parse::Result<$ident> {
                    let spans: ::syntax::custom_punctuation_repr!( $( $tt )+ ) =
                        ::syntax::__private::parse_punct( input, ::syntax::stringify_punct!( $( $tt )+ ) )?;
                    Ok( $ident( spans ) )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens( &self, tokens:&mut ::syntax::__private::TokenStream2 ) {
                    ::syntax::__private::print_punct( ::syntax::stringify_punct!( $( $tt )+ ), &self.spans, tokens )
                }
            }
        };
    }
        
    #[macro_export] macro_rules! impl_clone_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::Copy for $ident {}
            #[allow( clippy::expl_impl_clone_on_copy )]
            impl ::syntax::__private::Clone for $ident {
                fn clone( &self ) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt( &self, f:&mut ::syntax::__private::Formatter ) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str( f, ::syntax::__private::stringify!( $ident ) )
                }
            }
            
            impl ::syntax::__private::Eq for $ident {}
            
            impl ::syntax::__private::PartialEq for $ident {
                fn eq( &self, _other:&Self ) -> ::syntax::__private::bool {
                    true
                }
            }
            
            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>( &self, _state:&mut __H ) {}
            }
        };
    }
        
    #[macro_export] macro_rules! custom_punctuation_repr
    {
        ( $( $tt:tt )+ ) => {
            [::syntax::__private::Span; 0 $( + ::syntax::custom_punctuation_len!( lenient, $tt ) )+]
        };
    }
    
    #[macro_export] macro_rules! custom_punctuation_len
    {
        ( $mode:ident, & )     => { 1 };
        ( $mode:ident, && )    => { 2 };
        ( $mode:ident, &= )    => { 2 };
        ( $mode:ident, @ )     => { 1 };
        ( $mode:ident, ^ )     => { 1 };
        ( $mode:ident, ^= )    => { 2 };
        ( $mode:ident, : )     => { 1 };
        ( $mode:ident, , )     => { 1 };
        ( $mode:ident, $ )     => { 1 };
        ( $mode:ident, . )     => { 1 };
        ( $mode:ident, .. )    => { 2 };
        ( $mode:ident, ... )   => { 3 };
        ( $mode:ident, ..= )   => { 3 };
        ( $mode:ident, = )     => { 1 };
        ( $mode:ident, == )    => { 2 };
        ( $mode:ident, => )    => { 2 };
        ( $mode:ident, >= )    => { 2 };
        ( $mode:ident, > )     => { 1 };
        ( $mode:ident, <- )    => { 2 };
        ( $mode:ident, <= )    => { 2 };
        ( $mode:ident, < )     => { 1 };
        ( $mode:ident, - )     => { 1 };
        ( $mode:ident, -= )    => { 2 };
        ( $mode:ident, != )    => { 2 };
        ( $mode:ident, ! )     => { 1 };
        ( $mode:ident, | )     => { 1 };
        ( $mode:ident, |= )    => { 2 };
        ( $mode:ident, || )    => { 2 };
        ( $mode:ident, :: )    => { 2 };
        ( $mode:ident, % )     => { 1 };
        ( $mode:ident, %= )    => { 2 };
        ( $mode:ident, + )     => { 1 };
        ( $mode:ident, += )    => { 2 };
        ( $mode:ident, # )     => { 1 };
        ( $mode:ident, ? )     => { 1 };
        ( $mode:ident, -> )    => { 2 };
        ( $mode:ident, ; )     => { 1 };
        ( $mode:ident, << )    => { 2 };
        ( $mode:ident, <<= )   => { 3 };
        ( $mode:ident, >> )    => { 2 };
        ( $mode:ident, >>= )   => { 3 };
        ( $mode:ident, / )     => { 1 };
        ( $mode:ident, /= )    => { 2 };
        ( $mode:ident, * )     => { 1 };
        ( $mode:ident, *= )    => { 2 };
        ( $mode:ident, ~ )     => { 1 };
        ( lenient, $tt:tt )    => { 0 };
        ( strict, $tt:tt )     => {{ ::syntax::custom_punctuation_unexpected!( $tt ); 0 }};
    }
    
    #[macro_export] macro_rules! custom_punctuation_unexpected
    {
        () => {};
    }
    
    #[macro_export] macro_rules! stringify_punct
    {
        ( $( $tt:tt )+ ) => {
            ::syntax::__private::concat!( $( ::syntax::__private::stringify!( $tt ) ),+ )
        };
    }

    #[macro_export] macro_rules! custom_keyword
    {
        ( $ident:ident ) => {
            #[allow( non_camel_case_types )]
            pub struct $ident {
                #[allow( dead_code )]
                pub span: ::syntax::__private::Span,
            }
                #[allow( dead_code, non_snake_case )]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::__private::Span>>( 
                span: __S,
            ) -> $ident {
                $ident {
                    span: ::syntax::__private::IntoSpans::into_spans( span ),
                }
            }
            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident {
                            span: ::syntax::__private::Span::call_site(),
                        }
                    }
                }
                ::syntax::impl_parse_for_custom_keyword!( $ident );
                ::syntax::impl_to_tokens_for_custom_keyword!( $ident );
                ::syntax::impl_clone_for_custom_keyword!( $ident );
                ::syntax::impl_extra_traits_for_custom_keyword!( $ident );
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_keyword
    {
        ( $ident:ident ) => {
           
            impl ::syntax::__private::CustomToken for $ident {
                fn peek( cursor: ::syntax::buffer::Cursor ) -> ::syntax::__private::bool {
                    if let ::syntax::__private::Some( ( ident, _rest ) ) = cursor.ident() {
                        ident == ::syntax::__private::stringify!( $ident )
                    } else {
                        false
                    }
                }
                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!( "`", ::syntax::__private::stringify!( $ident ), "`" )
                }
            }
            
            impl ::syntax::parse::Parse for $ident
            {
                fn parse( input: ::syntax::parse::ParseStream ) -> ::syntax::parse::Result<$ident> {
                    input.step( |cursor| {
                        if let ::syntax::__private::Some( ( ident, rest ) ) = cursor.ident() {
                            if ident == ::syntax::__private::stringify!( $ident ) {
                                return ::syntax::__private::Ok( ( $ident { span: ident.span() }, rest ) );
                            }
                        }
                        ::syntax::__private::Err( cursor.error( ::syntax::__private::concat!( 
                            "expected `",
                            ::syntax::__private::stringify!( $ident ),
                            "`",
                        ) ) )
                    } )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_keyword
    {
        ( $ident:ident ) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens( &self, tokens:&mut ::syntax::__private::TokenStream2 ) {
                    let ident = ::syntax::Ident::new( ::syntax::__private::stringify!( $ident ), self.span );
                    ::syntax::__private::TokenStreamExt::append( tokens, ident );
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_clone_for_custom_keyword
    {
        ( $ident:ident ) => {
            impl ::syntax::__private::Copy for $ident {}
            #[allow( clippy::expl_impl_clone_on_copy )]
            impl ::syntax::__private::Clone for $ident {
                fn clone( &self ) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_keyword 
    {
        ( $ident:ident ) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt( &self, f:&mut ::syntax::__private::Formatter ) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str( 
                        f,
                        ::syntax::__private::concat!( 
                            "Keyword [",
                            ::syntax::__private::stringify!( $ident ),
                            "]",
                        ),
                    )
                }
            }
            
            impl ::syntax::__private::Eq for $ident {}
            
            impl ::syntax::__private::PartialEq for $ident {
                fn eq( &self, _other:&Self ) -> ::syntax::__private::bool {
                    true
                }
            }
            
            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>( &self, _state:&mut __H ) {}
            }
        };
    }
    /// Forward a method to an inherent method or a base trait method.
    #[macro_export] macro_rules! forward
    {
        ( $( Self :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( self $( , $arg : $ty )* ) -> $ret {
                    Self::$method( self $( , $arg )* )
                }
            )*};
        ( $( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( self $( , $arg : $ty )* ) -> $ret {
                    <Self as $base>::$method( self $( , $arg )* )
                }
            )*};
        ( $( $base:ident :: $method:ident ( $( $arg:ident : $ty:ty ),* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( $( $arg : $ty ),* ) -> $ret {
                    <Self as $base>::$method( $( $arg ),* )
                }
            )*};
        ( $( $imp:path as $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( self $( , $arg : $ty )* ) -> $ret {
                    $imp( self $( , $arg )* )
                }
            )*};
    }

    #[macro_export] macro_rules! constant
    {
        ( $( $method:ident () -> $ret:expr ; )* )
            => {$( 
                #[inline] fn $method() -> Self {
                    $ret
                }
            )*};
    }
    
    #[macro_export] macro_rules! forward_ref_ref_binop
    {
        ( impl $imp:ident, $method:ident ) =>
        {
            impl<'a, 'b, T: Clone + Integer> $imp<&'b Ratio<T>> for &'a Ratio<T> {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&'b Ratio<T> ) -> Ratio<T> {
                    self.clone().$method( other.clone() )
                }
            }
            
            impl<'a, 'b, T: Clone + Integer> $imp<&'b T> for &'a Ratio<T> {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&'b T ) -> Ratio<T> {
                    self.clone().$method( other.clone() )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_ref_ref_binop_big
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            impl $imp<&$res> for &$res
            {
                type Output = $res;
                #[inline] fn $method( self, other:&$res ) -> $res
                {
                    $imp::$method( self.clone(), other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_ref_val_binop
    {
        ( impl $imp:ident, $method:ident ) =>
        {
            impl<'a, T> $imp<Ratio<T>> for &'a Ratio<T> where
            T: Clone + Integer
            {
                type Output = Ratio<T>;
                #[inline] fn $method( self, other: Ratio<T> ) -> Ratio<T> { self.clone().$method( other ) }
            }
            
            impl<'a, T> $imp<T> for &'a Ratio<T> where
            T: Clone + Integer,
            {
                type Output = Ratio<T>;
                #[inline] fn $method( self, other: T ) -> Ratio<T> { self.clone().$method( other ) }
            }
        };
    }

    #[macro_export] macro_rules! forward_ref_val_binop_big
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    $imp::$method( self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_ref_binop
    {
        ( impl $imp:ident, $method:ident ) => {
            impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&Ratio<T> ) -> Ratio<T> {
                    self.$method( other.clone() )
                }
            }
            
            impl<'a, T> $imp<&'a T> for Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&T ) -> Ratio<T> {
                    self.$method( other.clone() )
                }
            }
        };
    }

    
    #[macro_export] macro_rules! forward_val_ref_binop_big
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<&$res> for $res {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                   
                    $imp::$method( &self, other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_all_binop
    {
        ( impl $imp:ident, $method:ident ) =>
        {
            forward_ref_ref_binop!( impl $imp, $method );
            forward_ref_val_binop!( impl $imp, $method );
            forward_val_ref_binop!( impl $imp, $method );
        };
    }

    #[macro_export] macro_rules! cfg_32
    {
        ( $( $any:tt )+ ) => {
            #[cfg( not( target_pointer_width = "64" ) )] $( $any )+
        }
    }

    #[macro_export] macro_rules! cfg_32_or_test 
    {
        ( $( $any:tt )+ ) => {
            #[cfg( any( not( target_pointer_width = "64" ), test ) )] $( $any )+
        }
    }

    #[macro_export] macro_rules! cfg_64
    {
        ( $( $any:tt )+ ) => {
            #[cfg( target_pointer_width = "64" )] $( $any )+
        }
    }

    #[macro_export] macro_rules! cfg_digit
    {
        ( $item32:item $item64:item ) => {
            cfg_32!( $item32 );
            cfg_64!( $item64 );
        };
    }

    #[macro_export] macro_rules! cfg_digit_expr
    {
        ( $expr32:expr, $expr64:expr ) => {
            cfg_32!( $expr32 );
            cfg_64!( $expr64 );
        };
    }

    #[macro_export] macro_rules! forward_val_val_binop
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for $res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    $imp::$method( self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_val_binop_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for $res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    if self.capacity() >= other.capacity() {
                        $imp::$method( self, &other )
                    } else {
                        $imp::$method( other, &self )
                    }
                }
            }
        };
    }
    /*
     */

    #[macro_export] macro_rules! forward_ref_val_binop_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    $imp::$method( other, self )
                }
            }
        };
    }
    /*

     */

    #[macro_export] macro_rules! forward_ref_ref_binop_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<&$res> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                   
                    if self.len() >= other.len() {
                        $imp::$method( self.clone(), other )
                    } else {
                        $imp::$method( other.clone(), self )
                    }
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_assign
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for $res {
                #[inline] fn $method( &mut self, other: $res ) {
                    self.$method( &other );
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_assign_scalar
    {
        ( impl $imp:ident for $res:ty, $scalar:ty, $method:ident ) => {
            impl $imp<$res> for $scalar {
                #[inline] fn $method( &mut self, other: $res ) {
                    self.$method( &other );
                }
            }
        };
    }
    
    #[macro_export] macro_rules! forward_scalar_val_val_binop_commutative
    {
        ( impl $imp:ident < $scalar:ty > for $res:ty, $method:ident ) => {
            impl $imp<$res> for $scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( other, self )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! forward_scalar_val_val_binop_to_ref_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<$scalar> for $res {
                type Output = $res;

                #[inline] fn $method( self, other: $scalar ) -> $res {
                    $imp::$method( &self, other )
                }
            }
            
            impl $imp<$res> for $scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_ref_ref_binop_to_ref_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( self, *other )
                }
            }
            
            impl $imp<&$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                    $imp::$method( *self, other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_val_ref_binop_to_ref_val 
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for $res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( &self, *other )
                }
            }
            
            impl $imp<$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( *self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_val_ref_binop_to_val_val 
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for $res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( self, *other )
                }
            }
            
            impl $imp<$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( *self, other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_ref_val_binop_to_val_val 
    {
        ( impl $imp:ident < $scalar:ty > for $res:ty, $method:ident ) => {
            impl $imp<$scalar> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other: $scalar ) -> $res {
                    $imp::$method( self.clone(), other )
                }
            }
            
            impl $imp<&$res> for $scalar {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                    $imp::$method( self, other.clone() )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_ref_ref_binop_to_val_val 
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( self.clone(), *other )
                }
            }
            
            impl $imp<&$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                    $imp::$method( *self, other.clone() )
                }
            }
        };
    }

    #[macro_export] macro_rules! promote_scalars 
    {
        ( impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),* ) => {
            $( 
                forward_all_scalar_binop_to_val_val!( impl $imp<$scalar> for $res, $method );

                impl $imp<$scalar> for $res {
                    type Output = $res;

                    #[allow( clippy::cast_lossless )]
                    #[inline] fn $method( self, other: $scalar ) -> $res {
                        $imp::$method( self, other as $promo )
                    }
                }
                impl $imp<$res> for $scalar {
                    type Output = $res;

                    #[allow( clippy::cast_lossless )]
                    #[inline] fn $method( self, other: $res ) -> $res {
                        $imp::$method( self as $promo, other )
                    }
                }
            )*
        }
    }

    #[macro_export] macro_rules! promote_scalars_assign 
    {
        ( impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),* ) => {
            $( 
                impl $imp<$scalar> for $res {
                    #[allow( clippy::cast_lossless )]
                    #[inline] fn $method( &mut self, other: $scalar ) {
                        self.$method( other as $promo );
                    }
                }
            )*
        }
    }

    #[macro_export] macro_rules! promote_unsigned_scalars 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_scalars!( impl $imp<u32> for $res, $method, u8, u16 );
            promote_scalars!( impl $imp<::num::big::UsizePromotion> for $res, $method, usize );
        }
    }

    #[macro_export] macro_rules! promote_unsigned_scalars_assign 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_scalars_assign!( impl $imp<u32> for $res, $method, u8, u16 );
            promote_scalars_assign!( impl $imp<::num::big::UsizePromotion> for $res, $method, usize );
        }
    }

    #[macro_export] macro_rules! promote_signed_scalars 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_scalars!( impl $imp<i32> for $res, $method, i8, i16 );
            promote_scalars!( impl $imp<::num::big::IsizePromotion> for $res, $method, isize );
        }
    }

    #[macro_export] macro_rules! promote_signed_scalars_assign 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            promote_scalars_assign!( impl $imp<i32> for $res, $method, i8, i16 );
            promote_scalars_assign!( impl $imp<::num::big::IsizePromotion> for $res, $method, isize );
        }
    }

    #[macro_export] macro_rules! forward_all_binop_to_ref_ref
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            forward_val_val_binop!( impl $imp for $res, $method );
            forward_val_ref_binop_big!( impl $imp for $res, $method );
            forward_ref_val_binop_big!( impl $imp for $res, $method );
        };
    }
    
    #[macro_export] macro_rules! forward_all_binop_to_val_ref
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            forward_val_val_binop!( impl $imp for $res, $method );
            forward_ref_val_binop!( impl $imp for $res, $method );
            forward_ref_ref_binop!( impl $imp for $res, $method );
        };
    }
    
    #[macro_export] macro_rules! forward_all_binop_to_val_ref_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            forward_val_val_binop_commutative!( impl $imp for $res, $method );
            forward_ref_val_binop_commutative!( impl $imp for $res, $method );
            forward_ref_ref_binop_commutative!( impl $imp for $res, $method );
        };
    }

    #[macro_export] macro_rules! forward_all_scalar_binop_to_ref_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            forward_scalar_val_val_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_val_ref_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_ref_ref_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
        }
    }

    #[macro_export] macro_rules! forward_all_scalar_binop_to_val_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            forward_scalar_val_ref_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_ref_val_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_ref_ref_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
        }
    }

    #[macro_export] macro_rules! forward_all_scalar_binop_to_val_val_commutative
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            forward_scalar_val_val_binop_commutative!( impl $imp<$scalar> for $res, $method );
            forward_all_scalar_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
        }
    }

    #[macro_export] macro_rules! promote_all_scalars
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_unsigned_scalars!( impl $imp for $res, $method );
            promote_signed_scalars!( impl $imp for $res, $method );
        }
    }

    #[macro_export] macro_rules! promote_all_scalars_assign
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_unsigned_scalars_assign!( impl $imp for $res, $method );
            promote_signed_scalars_assign!( impl $imp for $res, $method );
        }
    }

    #[macro_export] macro_rules! impl_sum_iter_type
    {
        ( $res:ty ) => {
            impl<T> Sum<T> for $res
            where
                $res: Add<T, Output = $res>,
            {
                fn sum<I>( iter: I ) -> Self
                where
                    I: Iterator<Item = T>,
                {
                    iter.fold( Self::ZERO, <$res>::add )
                }
            }
        };
    }

    #[macro_export] macro_rules! impl_product_iter_type
    {
        ( $res:ty ) => {
            impl<T> Product<T> for $res
            where
                $res: Mul<T, Output = $res>,
            {
                fn product<I>( iter: I ) -> Self
                where
                    I: Iterator<Item = T>,
                {
                    iter.fold( One::one(), <$res>::mul )
                }
            }
        };
    }

    #[macro_export] macro_rules! map
    {
        { } => { ::collections::HashMap::new() };
        { $( $key:expr => $value:expr ),+ , } =>
        {
           
            map!{ $( $key => $value ),+ }
        };
        { $( $key:expr => $value:expr ),* } =>
        {
            {
                let mut _map = ::collections::HashMap::new();

                $( 
                    let _ = _map.insert( $key, $value );
                )*

                _map
            }
        }
    }
    /// Given an int, creates and returns a `BigInt`.
    #[macro_export] macro_rules! int 
    {
        ( $int:expr ) => {{
            use num_bigint::BigInt;

            let _b: BigInt = $int.into();
            _b
        }};
    }
    /// Given two ints, creates and returns a `BigRational`.
    #[macro_export] macro_rules! frac 
    {
        ( $int1:expr, $int2:expr ) => {{
            ::num::rational::BigRational::new( $int1.into(), $int2.into() )
        }};
    }
    /// With a list of items, converts each item to a `Value` and returns an `Arr` containing a vector of the values.
    #[macro_export] macro_rules! arr 
    {
        [] => 
        {
            $crate::arrays::Arr::from_vec( vec![] ).unwrap()
        };

        [ $( $elem:expr ),+ , ] => 
        {
           
            try_arr![ $( $elem ),+ ].unwrap()
        };

        [ $( $elem:expr ),+ ] => 
        {
            try_arr![ $( $elem ),+ ].unwrap()
        };
    }
    /// With a list of items, converts each item to a `Value` and returns an `Arr` containing a vector of the values.
    #[macro_export] macro_rules! try_arr 
    {
        [ $( $elem:expr ),+ , ] => 
        {
           
            try_arr![ $( $elem ),+ ]
        };

        [ $( $elem:expr ),+ ] => 
        {{
                $crate::arrays::Arr::from_vec( vec![ $( $elem.into() ),+ ] )
        }};
    }
    /// With a list of items, converts each item to `Value`s and returns a `Tup` containing a vector of the values.
    #[macro_export] macro_rules! tup 
    {
        ( $( $elem:expr ),* , ) => {
            tup!( $( $elem ),* )
        };
        ( $( $elem:expr ),* ) => {
            {
                $crate::tup::Tup::from_vec( vec![ $( $elem.into() ),+ ] )
            }
        };
    }
    /// With a list of field/value pairs, returns an `Obj` containing each pair.
    #[macro_export] macro_rules! obj 
    {
        {} => {
            $crate::obj::Obj::from_map_unchecked( ::std::collections::HashMap::new() )
        };
        { $( $field:expr => $inner:expr ),+ , } => {
           
            try_obj!{ $( $field => $inner ),+ }.unwrap()
        };
        { $( $field:expr => $inner:expr ),+ } => {
            try_obj!{ $( $field => $inner ),+ }.unwrap()
        };
    }
    /// With a list of field to `Value` pairs, returns an `Obj` with the fields and values.
    #[macro_export] macro_rules! try_obj
    {
        { $( $field:expr => $inner:expr ),+ , } =>
        {
           
            try_obj!{ $( $field => $inner ),* };
        };
        
        { $( $field:expr => $inner:expr ),+ } =>
        {{
            use ::objects::Obj;
            let mut _map = ::collections::HashMap::new();
            let mut _parent: Option<::values::Value> = None;

            $( 
                if $field == "^" 
                {
                    _parent = Some( $inner.into() );
                } 
                
                else 
                {
                    _map.insert( $field.into(), $inner.into() );
                }
            )*

            match _parent 
            {
                Some( parent ) => match parent.get_obj() {
                    Ok( parent ) => Obj::from_map_with_parent( _map, parent ),
                    e @ Err( _ ) => e,
                }
                None => Obj::from_map( _map ),
            }
        }};
    }
    
    #[macro_export] macro_rules! forward_screen_buffer_methods
    {
        ( |$slf:ident| $field:expr ) =>
        {
            pub fn size( &self ) -> ::system::common::terminal::Size 
            {
                let $slf = self;
                $field.size()
            }

            pub fn cursor( &self ) -> ::system::common::terminal::Cursor 
            {
                let $slf = self;
                $field.cursor()
            }

            pub fn set_cursor( &self, pos: ::system::common::terminal::Cursor ) 
            {
                let $slf = self;
                $field.set_cursor( pos );
            }

            pub fn next_line( &self, column: usize ) 
            {
                let $slf = self;
                $field.next_line( column );
            }

            pub fn clear_screen( &self ) 
            {
                let $slf = self;
                $field.clear_screen();
            }

            pub fn clear_attributes( &self ) 
            {
                let $slf = self;
                $field.clear_attributes();
            }

            pub fn add_style( &self, style: ::system::common::terminal::Style ) 
            {
                let $slf = self;
                $field.add_style( style );
            }

            pub fn remove_style( &self, style: ::system::common::terminal::Style ) 
            {
                let $slf = self;
                $field.remove_style( style );
            }

            pub fn set_style( &self, style: ::system::common::terminal::Style ) 
            {
                let $slf = self;
                $field.set_style( style );
            }

            pub fn set_fg( &self, fg: Option<::system::common::terminal::Color> ) 
            {
                let $slf = self;
                $field.set_fg( fg );
            }

            pub fn set_bg( &self, bg: Option<::system::common::terminal::Color> ) 
            {
                let $slf = self;
                $field.set_bg( bg );
            }

            pub fn set_theme( &self, theme: ::system::common::terminal::Theme ) 
            {
                let $slf = self;
                $field.set_theme( theme )
            }

            pub fn write_char( &self, ch:char ) 
            {
                let $slf = self;
                let _ = $field.write_char( ch );
            }

            pub fn write_str( &self, s:&str ) 
            {
                let $slf = self;
                let _ = $field.write_str( s  );
            }

            pub fn write_at( &self, pos: ::system::common::terminal::Cursor, text:&str ) 
            {
                let $slf = self;
                let _ = $field.write_at( pos, text );
            }

            pub fn write_styled
            ( 
                &self,
                fg: Option<::system::common::terminal::Color>,
                bg: Option<::system::common::terminal::Color>,
                style: ::system::common::terminal::Style,
                text:&str
            )
            {
                let $slf = self;
                let _ = $field.write_styled( fg, bg, style, text );
            }

            pub fn write_styled_at( &self, pos: ::system::common::terminal::Cursor,
                    fg: Option<::system::common::terminal::Color>, bg: Option<::system::common::terminal::Color>,
                    style: ::system::common::terminal::Style, text:&str ) {
                let $slf = self;
                let _ = $field.write_styled_at( pos, fg, bg, style, text );
            }
        }
    }
    
    #[macro_export] macro_rules! forward_screen_buffer_mut_methods 
    {
        ( |$slf:ident| $field:expr ) => {
            pub fn size( &self ) -> ::system::common::terminal::Size {
                let $slf = self;
                $field.size()
            }

            pub fn cursor( &self ) -> ::system::common::terminal::Cursor {
                let $slf = self;
                $field.cursor()
            }

            pub fn set_cursor( &mut self, pos: ::system::common::terminal::Cursor ) {
                let $slf = self;
                $field.set_cursor( pos );
            }

            pub fn next_line( &mut self, column: usize ) {
                let $slf = self;
                $field.next_line( column );
            }

            pub fn clear_screen( &mut self ) {
                let $slf = self;
                $field.clear_screen();
            }

            pub fn clear_attributes( &mut self ) {
                let $slf = self;
                $field.clear_attributes();
            }

            pub fn add_style( &mut self, style: ::system::common::terminal::Style ) {
                let $slf = self;
                $field.add_style( style );
            }

            pub fn remove_style( &mut self, style: ::system::common::terminal::Style ) {
                let $slf = self;
                $field.remove_style( style );
            }

            pub fn set_style( &mut self, style: ::system::common::terminal::Style ) {
                let $slf = self;
                $field.set_style( style );
            }

            pub fn set_fg( &mut self, fg: Option<::system::common::terminal::Color> ) {
                let $slf = self;
                $field.set_fg( fg );
            }

            pub fn set_bg( &mut self, bg: Option<::system::common::terminal::Color> ) {
                let $slf = self;
                $field.set_bg( bg );
            }

            pub fn set_theme( &mut self, theme: ::system::common::terminal::Theme )
            {
                let $slf = self;
                $field.set_theme( theme );
            }

            pub fn write_char( &mut self, ch:char )
            {
                let $slf = self;
                let _ = $field.write_char( ch );
            }

            pub fn write_str( &mut self, s:&str ) 
            {
                let $slf = self;
                let _ = $field.write_str( s  );
            }

            pub fn write_at( &mut self, pos: ::system::common::terminal::Cursor, text:&str )
            {
                let $slf = self;
                let _ = $field.write_at( pos, text );
            }

            pub fn write_styled
            ( 
                &mut self,
                fg: Option<::system::common::terminal::Color>, 
                bg: Option<::system::common::terminal::Color>,
                style: ::system::common::terminal::Style,
                text:&str
            ) 
            {
                let $slf = self;
                let _ = $field.write_styled( fg, bg, style, text );
            }

            pub fn write_styled_at( &mut self, pos: ::system::common::terminal::Cursor,
                    fg: Option<::system::common::terminal::Color>, 
                    bg: Option<::system::common::terminal::Color>,
                    style: ::system::common::terminal::Style, text:&str ) {
                let $slf = self;
                let _ = $field.write_styled_at( pos, fg, bg, style, text );
            }
        }
    }
    
    #[macro_export] macro_rules! libc_bitflags
    {
        ( 
            $( #[$outer:meta] )*
            pub struct $BitFlags:ident: $T:ty {
                $( 
                    $( #[$inner:ident $( $args:tt )*] )*
                    $Flag:ident $( as $cast:ty )*;
                )+
            }
        ) =>
        {
            bitflags!
            {
                #[derive( Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
                #[repr( transparent )]
                $( #[$outer] )*
                pub struct $BitFlags: $T {
                    $( 
                        $( #[$inner $( $args )*] )*
                        const $Flag = $Flag $( as $cast )*;
                    )+
                }
            }
        };
    }

    #[macro_export] macro_rules! libc_enum
    {
        ( @make_enum
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: [$( $attrs:tt )*],
                entries: [$( $entries:tt )*],
            }
        ) =>
        {
            $( $attrs )*
            #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
            $v enum $BitFlags
            {
                $( $entries )*
            }
        };
        
        ( @make_enum
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: [$( $attrs:tt )*],
                entries: [$( $entries:tt )*],
                from_type: $repr:path,
                try_froms: [$( $try_froms:tt )*]
            }
        ) =>
        {
            $( $attrs )*
            #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
            $v enum $BitFlags
            {
                $( $entries )*
            }

            impl ::convert::TryFrom<$repr> for $BitFlags
            {
                type Error = ::system::api::Error;
                fn try_from( x: $repr ) -> ::system::api::Result<Self>
                {
                    match x
                    {
                        $( $try_froms )*
                        _ => Err( ::system::api::Error::EINVAL )
                    }
                }
            }
        };

        // Done accumulating.
        ( @accumulate_entries
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: $attrs:tt,
            },
            $entries:tt,
            $try_froms:tt;
        ) => {
            libc_enum! {
                @make_enum
                name: $BitFlags,
                {
                    $v
                    attrs: $attrs,
                    entries: $entries,
                }
            }
        };

        // Done accumulating and want TryFrom
        ( @accumulate_entries
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: $attrs:tt,
                from_type: $repr:path,
            },
            $entries:tt,
            $try_froms:tt;
        ) => {
            libc_enum! {
                @make_enum
                name: $BitFlags,
                {
                    $v
                    attrs: $attrs,
                    entries: $entries,
                    from_type: $repr,
                    try_froms: $try_froms
                }
            }
        };

        // Munch an attr.
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            #[$attr:meta] $( $tail:tt )*
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    #[$attr]
                ],
                [
                    $( $try_froms )*
                ];
                $( $tail )*
            }
        };

        // Munch last ident if not followed by a comma.
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            $entry:ident
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    $entry = $entry,
                ],
                [
                    $( $try_froms )*
                    $entry => Ok( $BitFlags::$entry ),
                ];
            }
        };

        // Munch an ident; covers terminating comma case.
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            $entry:ident,
            $( $tail:tt )*
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    $entry = $entry,
                ],
                [
                    $( $try_froms )*
                    $entry => Ok( $BitFlags::$entry ),
                ];
                $( $tail )*
            }
        };

        // Munch an ident and cast it to the given type; covers terminating comma.
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            $entry:ident as $ty:ty,
            $( $tail:tt )*
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    $entry = $entry as $ty,
                ],
                [
                    $( $try_froms )*
                    $entry as $ty => Ok( $BitFlags::$entry ),
                ];
                $( $tail )*
            }
        };

        // Entry rule.
        ( 
            $( #[$attr:meta] )*
            $v:vis enum $BitFlags:ident {
                $( $vals:tt )*
            }
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                {
                    $v
                    attrs: [$( #[$attr] )*],
                },
                [],
                [];
                $( $vals )*
            }
        };

        // Entry rule including TryFrom
        ( 
            $( #[$attr:meta] )*
            $v:vis enum $BitFlags:ident {
                $( $vals:tt )*
            }
            impl TryFrom<$repr:path>
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                {
                    $v
                    attrs: [$( #[$attr] )*],
                    from_type: $repr,
                },
                [],
                [];
                $( $vals )*
            }
        };
    }
    /// A macro for defining #[cfg] if-else statements.
    #[macro_export] macro_rules! cfg_if
    {
        ( $( 
            if #[cfg( $( $meta:meta ),* )] { $( $it:item )* }
        ) else * else {
            $( $it2:item )*
        } ) =>
        {
            cfg_if!
            {
                @__items
                () ;
                $( ( ( $( $meta ),* ) ( $( $it )* ) ), )*
                ( () ( $( $it2 )* ) ),
            }
        };
        
        ( 
            if #[cfg( $( $i_met:meta ),* )] { $( $i_it:item )* }
            $( 
                else if #[cfg( $( $e_met:meta ),* )] { $( $e_it:item )* }
            )*
        ) =>
        {
            cfg_if!
            {
                @__items
                () ;
                ( ( $( $i_met ),* ) ( $( $i_it )* ) ),
                $( ( ( $( $e_met ),* ) ( $( $e_it )* ) ), )*
                ( () () ),
            }
        };
        
        ( @__items ( $( $not:meta, )* ) ; ) => {};
        ( @__items ( $( $not:meta, )* ) ; ( ( $( $m:meta ),* ) ( $( $it:item )* ) ), $( $rest:tt )* ) =>
        {
            cfg_if! { @__apply cfg( all( $( $m, )* not( any( $( $not ),* ) ) ) ), $( $it )* }            
            cfg_if! { @__items ( $( $not, )* $( $m, )* ) ; $( $rest )* }
        };
        
        ( @__apply $m:meta, $( $it:item )* ) => { $( #[$m] $it )* };
    }

    #[macro_export] macro_rules! println_stderr
    {
        ( $fmt:expr ) => 
        ( 
            use io::Write;
            match writeln!( &mut ::io::stderr(), $fmt )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed: {:?}", e )
            }
         );

        ( $fmt:expr, $( $arg:tt )* ) =>
        ( 
            match writeln!( &mut ::io::stderr(), $fmt, $( $arg )* )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed: {:?}", e )
            }
         );
    }

    #[macro_export] macro_rules! define_uuid_macro
    {
        {$(#[$doc:meta] )*} =>
        {
            #[macro_export] macro_rules! uuid
            {
                ( $uuid:expr ) => 
                {{
                    const OUTPUT: $crate::Uuid = match $crate::Uuid::try_parse( $uuid )
                    {
                        Ok(u ) => u,
                        Err(_ ) => panic!( "invalid UUID" ),
                    };

                    OUTPUT
                }};
            }
        }
    }

    define_uuid_macro!
    {
        /// Parse [`Uuid`][uuid::Uuid]s from string literals at compile time.
    }

    #[macro_export] macro_rules! unsafe_transmute_ref
    (
        ( $e:expr ) => { unsafe { ::mem::transmute::<&_, &_>( $e ) } }
    );

    #[macro_export] macro_rules! unsafe_transmute
    (
        ( $e:expr ) => { unsafe { ::mem::transmute::<_, _>( $e ) } }
    );

    #[allow(dead_code )]
    pub struct Lazy<T: Sync>( Cell<MaybeUninit<T>>, Once );

    impl<T: Sync> Lazy<T>
    {
        #[allow(deprecated )]
        pub const INIT: Self = Lazy( Cell::new(MaybeUninit::uninit() ), ONCE_INIT );

        #[inline( always )] pub fn get<F>( &'static self, f: F) -> &T where
        F:FnOnce() -> T
        {
            unsafe
            { 
                self.1.call_once(|| { self.0.set(MaybeUninit::new( f() ) ); });
                &*(*self.0.as_ptr() ).as_ptr()
            }
        }
    }

    unsafe impl<T: Sync> Sync for Lazy<T> {}

    #[macro_export] macro_rules! __lazy_static_create
    {
        ( $NAME:ident, $T:ty) => {
            static $NAME: ::macros::Lazy<$T> = ::macros::Lazy::INIT;
        };
    }

    #[macro_export( local_inner_macros )] macro_rules! __lazy_static_internal
    {
        ( $(#[$attr:meta])* ( $( $vis:tt )*) static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!(@MAKE TY, $(#[$attr])*, ( $( $vis )*), $N);
            __lazy_static_internal!(@TAIL, $N : $T = $e );
            lazy_static!( $( $t )*);
        };
        
        (@TAIL, $N:ident : $T:ty = $e:expr ) =>
        {
            impl ::ops::Deref for $N
            {
                type Target = $T;
                fn deref( &self ) -> &$T
                {
                    #[inline( always )] fn __static_ref_initialize() -> $T { $e }

                    #[inline( always )] fn __stability() -> &'static $T
                    {
                        __lazy_static_create!(LAZY, $T );
                        LAZY.get(__static_ref_initialize )
                    }
                    __stability()
                }
            }

            impl ::macros::LazyStatic for $N
            {
                fn initialize(lazy: &Self) { let _ = &**lazy; }
            }
        };
        
        (@MAKE TY, $(#[$attr:meta])*, ( $( $vis:tt )*), $N:ident ) =>
        {
            $(#[$attr])*
            $( $vis )* struct $N {__private_field: ()}
            $( $vis )* static $N: $N = $N {__private_field: ()};
        };
        () => ()
    }

    #[macro_export(local_inner_macros )]
    macro_rules! lazy_static
    {
        ( $(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!( $(#[$attr])* () static ref $N : $T = $e; $( $t )*);
        };

        ( $(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!( $(#[$attr])* ( pub) static ref $N : $T = $e; $( $t )*);
        };

        ( $(#[$attr:meta])* pub ( $( $vis:tt )+) static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!( $(#[$attr])* ( pub ( $( $vis )+ ) ) static ref $N : $T = $e; $( $t )*);
        };

        () => ()
    }
    /// Support trait for enabling a few common operations on lazy static values.
    pub trait LazyStatic
    {
        fn initialize(lazy: &Self);
    }
    /// Takes a shared reference to a lazy static and initializes it if it has not been already.
    pub fn initialize<T: LazyStatic>( lazy: &T )
    {
        LazyStatic::initialize(lazy);
    }
    
    #[macro_export] macro_rules! bitflags
    {
        (
            $(#[$outer:meta])*
            $vis:vis struct $BitFlags:ident: $T:ty
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }

            $( $t:tt )*
        ) =>
        {
            ::__declare_public_bitflags!
            {
                $(#[$outer])*
                $vis struct $BitFlags
            }
            
            ::__impl_public_bitflags_consts!
            {
                $BitFlags: $T
                {
                    $(
                        $(#[$inner $( $args )*])*
                        const $Flag = $value;
                    )*
                }
            }
            
            const _: () = 
            {
                ::__declare_internal_bitflags! { $vis struct InternalBitFlags: $T }

                ::__impl_internal_bitflags!
                {
                    InternalBitFlags: $T, $BitFlags 
                    {
                        $(
                            $(#[$inner $( $args )*])*
                            const $Flag = $value;
                        )*
                    }
                }

                ::__impl_public_bitflags_forward! { $BitFlags: $T, InternalBitFlags }

                ::__impl_public_bitflags_ops! { $BitFlags }

                ::__impl_public_bitflags_iter! { $BitFlags: $T, $BitFlags }
            };

            ::bitflags! { $( $t )* }
        };

        (
            $(#[$outer:meta])*
            impl $BitFlags:ident: $T:ty
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }

            $( $t:tt )*
        ) =>
        {
            ::__impl_public_bitflags_consts!
            {
                $BitFlags: $T
                {
                    $(
                        $(#[$inner $( $args )*])*
                        const $Flag = $value;
                    )*
                }
            }
            
            const _: () =
            {
                ::__impl_public_bitflags!
                {
                    $(#[$outer])*
                    $BitFlags: $T, $BitFlags
                    {
                        $(
                            $(#[$inner $( $args )*])*
                            const $Flag = $value;
                        )*
                    }
                }

                ::__impl_public_bitflags_ops! { $BitFlags }

                ::__impl_public_bitflags_iter! { $BitFlags: $T, $BitFlags }
            };

            ::bitflags! { $( $t )* }
        };

        () => {};
    }
    /// Implement functions on bitflags types.
    #[macro_export] macro_rules! __impl_bitflags
    {
        (
            params: $self:ident, $bits:ident, $name:ident, $other:ident, $value:ident;
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty 
            {
                fn empty() $empty_body:block
                fn all() $all_body:block
                fn bits(&self) $bits_body:block
                fn from_bits( bits ) $from_bits_body:block
                fn from_bits_truncate( bits ) $from_bits_truncate_body:block
                fn from_bits_retain( bits ) $from_bits_retain_body:block
                fn from_name(name) $from_name_body:block
                fn is_empty(&self) $is_empty_body:block
                fn is_all(&self) $is_all_body:block
                fn intersects(&self, other) $intersects_body:block
                fn contains(&self, other) $contains_body:block
                fn insert(&mut self, other) $insert_body:block
                fn remove(&mut self, other) $remove_body:block
                fn toggle(&mut self, other) $toggle_body:block
                fn set(&mut self, other, value) $set_body:block
                fn intersection(self, other) $intersection_body:block
                fn union(self, other) $union_body:block
                fn difference(self, other) $difference_body:block
                fn symmetric_difference(self, other) $symmetric_difference_body:block
                fn complement(self) $complement_body:block
            }
        ) => 
        {
            #[allow(dead_code, deprecated, unused_attributes )]
            $(#[$outer])*
            impl $PublicBitFlags 
            {
                /// Get a flags value with all bits unset.
                #[inline] pub const fn empty() -> Self
                    $empty_body

                /// Get a flags value with all known bits set.
                #[inline] pub const fn all() -> Self
                    $all_body

                /// Get the underlying bits value.
                ///
                /// The returned value is exactly the bits set in this flags value.
                #[inline] pub const fn bits(&$self) -> $T
                    $bits_body

                /// Convert from a bits value.
                ///
                /// This method will return `None` if any unknown bits are set.
                #[inline] pub const fn from_bits( $bits: $T ) -> ::option::Option<Self>
                    $from_bits_body

                /// Convert from a bits value, unsetting any unknown bits.
                #[inline] pub const fn from_bits_truncate( $bits: $T ) -> Self
                    $from_bits_truncate_body

                /// Convert from a bits value exactly.
                #[inline] pub const fn from_bits_retain( $bits: $T ) -> Self
                    $from_bits_retain_body

                /// Get a flags value with the bits of a flag with the given name set.
                ///
                /// This method will return `None` if `name` is empty or doesn't
                /// correspond to any named flag.
                #[inline] pub fn from_name( $name: &str) -> ::option::Option<Self>
                    $from_name_body

                /// Whether all bits in this flags value are unset.
                #[inline] pub const fn is_empty(&$self) -> bool
                    $is_empty_body

                /// Whether all known bits in this flags value are set.
                #[inline] pub const fn is_all(&$self) -> bool
                    $is_all_body

                /// Whether any set bits in a source flags value are also set in a target flags value.
                #[inline] pub const fn intersects(&$self, $other: Self) -> bool
                    $intersects_body

                /// Whether all set bits in a source flags value are also set in a target flags value.
                #[inline] pub const fn contains(&$self, $other: Self) -> bool
                    $contains_body

                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline] pub fn insert(&mut $self, $other: Self)
                    $insert_body

                /// The intersection of a source flags value with the complement of a target flags
                /// value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `remove` won't truncate `other`, but the `!` operator will.
                #[inline] pub fn remove(&mut $self, $other: Self)
                    $remove_body

                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline] pub fn toggle(&mut $self, $other: Self)
                    $toggle_body

                /// Call `insert` when `value` is `true` or `remove` when `value` is `false`.
                #[inline] pub fn set(&mut $self, $other: Self, $value: bool)
                    $set_body

                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn intersection( $self, $other: Self) -> Self
                    $intersection_body

                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn union( $self, $other: Self) -> Self
                    $union_body

                /// The intersection of a source flags value with the complement of a target flags
                /// value (`&!`).
                ///
                /// This method is not equivalent to `self & !other` when `other` has unknown bits set.
                /// `difference` won't truncate `other`, but the `!` operator will.
                #[inline]
                #[must_use]
                pub const fn difference( $self, $other: Self) -> Self
                    $difference_body

                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline]
                #[must_use]
                pub const fn symmetric_difference( $self, $other: Self) -> Self
                    $symmetric_difference_body

                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline]
                #[must_use]
                pub const fn complement( $self) -> Self
                    $complement_body
            }
        };
    }
    /// A macro that matches flags values, similar to Rust's `match` statement.
    #[macro_export] macro_rules! bitflags_match 
    {
        ( $operation:expr, { $( $t:tt )* }) =>
        {
            (|| { ::__bitflags_match!( $operation, { $( $t )* }) })()
        };
    }
    /// Expand the `bitflags_match` macro
    #[macro_export] macro_rules! __bitflags_match
    {
        ( $operation:expr, { $pattern:expr => { $( $body:tt )* } , $( $t:tt )+ }) =>
        { ::__bitflags_match!( $operation, { $pattern => { $( $body)* } $( $t )+ }) };
        
        ( $operation:expr, { $pattern:expr => { $( $body:tt )* } $( $t:tt )+ }) => 
        {
            {
                if $operation == $pattern
                {
                    return
                    {
                        $( $body)*
                    }; 
                }

                ::__bitflags_match!( $operation, { $( $t )+ })
            }
        };
        
        ( $operation:expr, { $pattern:expr => $body:expr , $( $t:tt )+ }) =>
        {
            {
                if $operation == $pattern { return $body; }

                ::__bitflags_match!( $operation, { $( $t )+ })
            }
        };
        
        ( $operation:expr, { _ => $default:expr $(,)? }) => { $default }
    }
    /// A macro that processed the input to `bitflags!` and shuffles attributes around based on whether or not they're "expression-safe".
    #[macro_export] macro_rules! __bitflags_expr_safe_attrs 
    {
        (
            $(#[$inner:ident $( $args:tt )*])*
            { $e:expr }
        ) => 
        {
            ::__bitflags_expr_safe_attrs! 
            {
                expr: { $e },
                attrs: 
                {
                    unprocessed: [$(#[$inner $( $args )*])*],
                    processed: [],
                },
            }
        };
        
        (
            expr:{ $e:expr },
            attrs:
            {
                unprocessed:
                [
                    #[cfg $( $args:tt )*]
                    $( $attrs_rest:tt )*
                ],
                processed: [$( $expr:tt )*],
            },
        ) =>
        {
            ::__bitflags_expr_safe_attrs!
            {
                expr: { $e },
                attrs:
                {
                    unprocessed:
                    [
                        $( $attrs_rest )*
                    ],
                    processed:
                    [
                        $( $expr)*
                        #[cfg $( $args )*]
                    ],
                },
            }
        };
        
        (
            expr: { $e:expr },
            attrs:
            {
                unprocessed:
                [
                    #[$other:ident $( $args:tt )*]
                    $( $attrs_rest:tt )*
                ],
                processed: [$( $expr:tt )*],
            },
        ) =>
        {
            ::__bitflags_expr_safe_attrs! 
            {
                expr:{ $e },
                attrs:
                {
                    unprocessed:
                    [
                        $( $attrs_rest )*
                    ],

                    processed:
                    [
                        $( $expr)*
                    ],
                },
            }
        };
        
        (
            expr:{ $e:expr },
            attrs:
            {
                unprocessed: [],
                processed: [$(#[$expr:ident $( $exprargs:tt )*])*],
            },
        ) =>
        {
            $(#[$expr $( $exprargs )*])*
            { $e }
        }
    }
    /// Implement a flag, which may be a wildcard `_`.
    #[macro_export] macro_rules! __bitflags_flag
    {
        (
            {
                name: _,
                named: { $( $named:tt )* },
                unnamed: { $( $unnamed:tt )* },
            }
        ) =>
        { $( $unnamed)* };

        (
            {
                name: $Flag:ident,
                named: { $( $named:tt )* },
                unnamed: { $( $unnamed:tt )* },
            }
        ) => { $( $named)* };
    }
    /// Declare the user-facing bitflags struct.
    #[macro_export] macro_rules! __declare_public_bitflags
    {
        (
            $(#[$outer:meta])*
            $vis:vis struct $PublicBitFlags:ident
        ) => {
            $(#[$outer])*
            $vis struct $PublicBitFlags(<$PublicBitFlags as ::bits::flags::PublicFlags>::Internal);
        };
    }
    /// Implement functions on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_forward 
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident
        ) => 
        {
            __impl_bitflags! 
            {
                params: self, bits, name, other, value;
                $(#[$outer])*
                $PublicBitFlags: $T
                {
                    fn empty() { Self( $InternalBitFlags::empty()) }
                    fn all() { Self( $InternalBitFlags::all()) }
                    fn bits(&self) { self.0.bits() }
                    fn from_bits( bits )
                    {
                        match $InternalBitFlags::from_bits( bits )
                        {
                            Some( bits ) => Some(Self( bits )),
                            None => None,
                        }
                    }
                    fn from_bits_truncate( bits ) { Self( $InternalBitFlags::from_bits_truncate( bits )) }
                    fn from_bits_retain( bits ) { Self( $InternalBitFlags::from_bits_retain( bits )) }
                    fn from_name(name)
                    {
                        match $InternalBitFlags::from_name(name)
                        {
                            Some( bits ) => Some(Self( bits )),
                            None =>None,
                        }
                    }
                    fn is_empty(&self) { self.0.is_empty() }
                    fn is_all(&self) { self.0.is_all() }
                    fn intersects(&self, other) { self.0.intersects(other.0) }
                    fn contains(&self, other) { self.0.contains(other.0) }
                    fn insert(&mut self, other) { self.0.insert(other.0) }
                    fn remove(&mut self, other) { self.0.remove(other.0) }
                    fn toggle(&mut self, other) { self.0.toggle(other.0) }
                    fn set(&mut self, other, value) { self.0.set(other.0, value) }
                    fn intersection(self, other) { Self(self.0.intersection(other.0)) }
                    fn union(self, other) { Self(self.0.union(other.0)) }
                    fn difference(self, other) { Self(self.0.difference(other.0)) }
                    fn symmetric_difference(self, other) { Self(self.0.symmetric_difference(other.0)) }
                    fn complement(self) { Self(self.0.complement()) }
                }
            }
        };
    }
    /// Implement functions on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags 
    {
        (
            $(#[$outer:meta])*
            $BitFlags:ident: $T:ty, $PublicBitFlags:ident 
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) => 
        {
            __impl_bitflags! 
            {
                params: self, bits, name, other, value;
                $(#[$outer])*
                $BitFlags: $T 
                {
                    fn empty() { Self(<$T as ::bits::flags::Bits>::EMPTY) }
                    fn all() 
                    {
                        let mut truncated = <$T as ::bits::flags::Bits>::EMPTY;
                        let mut i = 0;

                        $(
                            __bitflags_expr_safe_attrs!
                            (
                                $(#[$inner $( $args )*])*
                                {{
                                    let flag = <$PublicBitFlags as ::bits::flags::Flags>::FLAGS[i].value().bits();
                                    truncated = truncated | flag;
                                    i += 1;
                                }}
                            );
                        )*

                        let _ = i;
                        Self( truncated)
                    }
                    fn bits(&self) { self.0 }
                    fn from_bits( bits )
                    {
                        let truncated = Self::from_bits_truncate( bits ).0;
                        if truncated == bits { Some(Self( bits )) } else { None }
                    }
                    fn from_bits_truncate( bits ) { Self( bits & Self::all().0) }
                    fn from_bits_retain( bits ) { Self( bits ) }
                    fn from_name(name)
                    {
                        $(
                            __bitflags_flag!
                            ({
                                name: $Flag,
                                named: 
                                {
                                    __bitflags_expr_safe_attrs!
                                    (
                                        $(#[$inner $( $args )*])*
                                        {
                                            if name == stringify!( $Flag) 
                                            { return Some(Self( $PublicBitFlags::$Flag.bits())); }
                                        }
                                    );
                                },
                                unnamed: {},
                            });
                        )*

                        let _ = name;
                        None
                    }
                    fn is_empty(&self) { self.0 == <$T as ::bits::flags::Bits>::EMPTY }
                    fn is_all(&self) { Self::all().0 | self.0 == self.0 }
                    fn intersects(&self, other) { self.0 & other.0 != <$T as ::bits::flags::Bits>::EMPTY }
                    fn contains(&self, other) { self.0 & other.0 == other.0 }
                    fn insert(&mut self, other) { *self = Self(self.0).union( other ); }
                    fn remove(&mut self, other) { *self = Self(self.0).difference( other ); }
                    fn toggle(&mut self, other) { *self = Self(self.0).symmetric_difference( other ); }
                    fn set(&mut self, other, value)
                    {
                        if value { self.insert( other ); }
                        else { self.remove( other ); }
                    }
                    fn intersection(self, other) { Self(self.0 & other.0) }
                    fn union(self, other) { Self(self.0 | other.0) }
                    fn difference(self, other) { Self(self.0 & !other.0) }
                    fn symmetric_difference(self, other) { Self(self.0 ^ other.0) }
                    fn complement(self) { Self::from_bits_truncate(!self.0) }
                }
            }
        };
    }
    /// Implement iterators on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_iter
    {
        (
            $(#[$outer:meta])*
            $BitFlags:ident: $T:ty, $PublicBitFlags:ident
        ) =>
        {
            $(#[$outer])*
            impl $BitFlags
            {
                /// Yield a set of contained flags values.
                #[inline] pub const fn iter(&self) -> ::bits::flags::iter::Iter<$PublicBitFlags>
                {
                    ::bits::flags::iter::Iter::__private_const_new
                    (
                        <$PublicBitFlags as ::bits::flags::Flags>::FLAGS,
                        $PublicBitFlags::from_bits_retain(self.bits()),
                        $PublicBitFlags::from_bits_retain(self.bits()),
                    )
                }
                /// Yield a set of contained named flags values.
                #[inline] pub const fn iter_names(&self) -> ::bits::flags::iter::IterNames<$PublicBitFlags>
                {
                    ::bits::flags::iter::IterNames::__private_const_new
                    (
                        <$PublicBitFlags as ::bits::flags::Flags>::FLAGS,
                        $PublicBitFlags::from_bits_retain(self.bits()),
                        $PublicBitFlags::from_bits_retain(self.bits()),
                    )
                }
            }

            $(#[$outer:meta])*
            impl ::iter::IntoIterator for $BitFlags
            {
                type Item = $PublicBitFlags;
                type IntoIter = ::bits::flags::iter::Iter<$PublicBitFlags>;
                fn into_iter(self) -> Self::IntoIter { self.iter() }
            }
        };
    }
    /// Implement traits on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_ops
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident
        ) =>
        {
            $(#[$outer])*
            impl ::fmt::Binary for $PublicBitFlags
            {
                fn fmt
                (
                    &self,
                    f: &mut ::fmt::Formatter
                ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::Binary::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::Octal for $PublicBitFlags
            {
                fn fmt
                (
                    &self,
                    f: &mut ::fmt::Formatter
                ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::Octal::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::LowerHex for $PublicBitFlags
            {
                fn fmt
                (
                    &self,
                    f: &mut ::fmt::Formatter
                ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::LowerHex::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::UpperHex for $PublicBitFlags 
            {
                fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::UpperHex::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::ops::BitOr for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline] fn bitor(self, other: $PublicBitFlags ) -> Self { self.union( other ) }
            }

            $(#[$outer])*
            impl ::ops::BitOrAssign for $PublicBitFlags
            {
                /// The bitwise or (`|`) of the bits in two flags values.
                #[inline] fn bitor_assign(&mut self, other: Self) { self.insert( other ); }
            }

            $(#[$outer])*
            impl ::ops::BitXor for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline] fn bitxor(self, other: Self) -> Self { self.symmetric_difference( other ) }
            }

            $(#[$outer])*
            impl ::ops::BitXorAssign for $PublicBitFlags
            {
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[inline] fn bitxor_assign(&mut self, other: Self) { self.toggle( other ); }
            }

            $(#[$outer])*
            impl ::ops::BitAnd for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline] fn bitand(self, other: Self) -> Self { self.intersection( other ) }
            }

            $(#[$outer])*
            impl ::ops::BitAndAssign for $PublicBitFlags
            {
                /// The bitwise and (`&`) of the bits in two flags values.
                #[inline] fn bitand_assign(&mut self, other: Self)
                { *self = Self::from_bits_retain(self.bits()).intersection( other ); }
            }

            $(#[$outer])*
            impl ::ops::Sub for $PublicBitFlags
            {
                type Output = Self;
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[inline] fn sub(self, other: Self) -> Self { self.difference( other ) }
            }

            $(#[$outer])*
            impl ::ops::SubAssign for $PublicBitFlags
            {
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[inline] fn sub_assign(&mut self, other: Self) { self.remove( other ); }
            }

            $(#[$outer])*
            impl ::ops::Not for $PublicBitFlags
            {
                type Output = Self;
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[inline] fn not(self) -> Self { self.complement() }
            }

            $(#[$outer])*
            impl ::iter::Extend<$PublicBitFlags> for $PublicBitFlags 
            {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn extend<T: ::iter::IntoIterator<Item = Self>>
                (
                    &mut self,
                    iterator: T
                )
                {
                    for item in iterator
                    {
                        self.insert(item)
                    }
                }
            }

            $(#[$outer])*
            impl ::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags 
            {
                /// The bitwise or (`|`) of the bits in each flags value.
                fn from_iter<T: ::iter::IntoIterator<Item = Self>>( iterator: T ) -> Self 
                {
                    use ::iter::Extend;

                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
        };
    }
    /// Implement constants on the public (user-facing) bitflags type.
    #[macro_export] macro_rules! __impl_public_bitflags_consts 
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty 
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) => 
        {
            $(#[$outer])*
            impl $PublicBitFlags 
            {
                $(
                    __bitflags_flag!
                    ({
                        name: $Flag,
                        named: 
                        {
                            $(#[$inner $( $args )*])*
                            pub const $Flag: Self = Self::from_bits_retain( $value);
                        },
                        unnamed: {},
                    });
                )*
            }

            $(#[$outer])*
            impl ::bits::flags::Flags for $PublicBitFlags
            {
                const FLAGS: &'static [::bits::flags::Flag<$PublicBitFlags>] = 
                &[
                    $(
                        __bitflags_flag!
                        ({
                            name: $Flag,
                            named:
                            {
                                __bitflags_expr_safe_attrs!
                                (
                                    $(#[$inner $( $args )*])*
                                    {
                                        ::bits::flags::Flag::new( stringify!( $Flag), $PublicBitFlags::$Flag )
                                    }
                                )
                            },
                            unnamed:
                            {
                                ::bits::flags::__bitflags_expr_safe_attrs!
                                (
                                    $(#[$inner $( $args )*])*
                                    {
                                        ::bits::flags::Flag::new("", $PublicBitFlags::from_bits_retain( $value))
                                    }
                                )
                            },
                        }),
                    )*
                ];

                type Bits = $T;

                fn bits(&self) -> $T { $PublicBitFlags::bits(self) }
                fn from_bits_retain( bits:$T ) -> $PublicBitFlags { $PublicBitFlags::from_bits_retain( bits ) }
            }
        };
    }
    /// Declare the `bitflags`-facing bitflags struct.
    #[macro_export] macro_rules! __declare_internal_bitflags
    {
        (
            $vis:vis struct $InternalBitFlags:ident: $T:ty
        ) =>
        {
            #[repr( transparent )] #[derive( Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash )]            
            $vis struct $InternalBitFlags( $T );
        };
    }
    /// Implement functions on the private ( bitflags-facing) bitflags type.
    #[macro_export] macro_rules! __impl_internal_bitflags
    {
        (
            $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) =>
        {
            impl ::bits::flags::PublicFlags for $PublicBitFlags
            {
                type Primitive = $T;
                type Internal = $InternalBitFlags;
            }

            impl ::default::Default for $InternalBitFlags
            {
                #[inline] fn default() -> Self { $InternalBitFlags::empty() }
            }

            impl ::fmt::Debug for $InternalBitFlags
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    if self.is_empty() { write!(f, "{:#x}", <$T as ::bits::flags::Bits>::EMPTY) }
                    else { ::fmt::Display::fmt(self, f) }
                }
            }

            impl ::fmt::Display for $InternalBitFlags
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                { ::bits::flags::parser::to_writer(&$PublicBitFlags(*self), f) }
            }

            impl ::str::FromStr for $InternalBitFlags
            {
                type Err = ::bits::flags::parser::ParseError;

                fn from_str(s: &str) -> ::result::Result<Self, Self::Err>
                { ::bits::flags::parser::from_str::<$PublicBitFlags>(s ).map(|flags| flags.0) }
            }

            impl ::convert::AsRef<$T> for $InternalBitFlags
            {
                fn as_ref(&self) -> &$T { &self.0 }
            }

            impl ::convert::From<$T> for $InternalBitFlags
            {
                fn from( bits: $T ) -> Self { Self::from_bits_retain( bits ) }
            }
            
            __impl_public_bitflags!
            {
                $InternalBitFlags: $T, $PublicBitFlags
                {
                    $(
                        $(#[$inner $( $args )*])*
                        const $Flag = $value;
                    )*
                }
            }

            __impl_public_bitflags_ops! { $InternalBitFlags }

            __impl_public_bitflags_iter! { $InternalBitFlags: $T, $PublicBitFlags }

            impl $InternalBitFlags
            {
                /// Returns a mutable reference to the raw value of the flags currently stored.
                #[inline] pub fn bits_mut(&mut self) -> &mut $T { &mut self.0 }
            }
        };
    }
}

pub mod arch
{
    pub use std::arch::{ * };
}

pub mod arrays
{
    /*!
    Arr | A container which can hold an arbitrary number of elements of a single type. */
    use ::
    {
        error::{ OverError },
        fmt::{ Format },
        result::{ OverResult },
        slice::{ Iter },
        sync::{ Arc },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    */
    #[derive( Clone, Debug )]
    struct ArrInner 
    {
        vec: Vec<Value>,
        inner_t: Type,
    }
    /// `Arr` struct.
    #[derive( Clone, Debug )]
    pub struct Arr 
    {
        inner: Arc<ArrInner>,
    }

    impl Arr 
    {
        /// Returns a new `Arr` from the given vector of `Value`s.
        pub fn from_vec( vec: Vec<Value> ) -> OverResult<Arr> 
        {
            let mut tcur = Type::Any;
            let mut has_any = true;

            for value in &vec {
                let tnew = value.get_type();

                if has_any {
                    match Type::most_specific( &tcur, &tnew ) {
                        Some( ( t, any ) ) => {
                            tcur = t;
                            has_any = any;
                        }
                        None => return Err( OverError::ArrTypeMismatch( tcur, tnew ) ),
                    }
                } else if tcur != tnew {
                    return Err( OverError::ArrTypeMismatch( tcur, tnew ) );
                }
            }
            Ok( Arr {
                inner: Arc::new( ArrInner { vec, inner_t: tcur } ),
            } )
        }
        /// Returns a new `Arr` from the given vector of `Value`s without checking 
        /// whether every value in `vec` is the same type.
        pub fn from_vec_unchecked( vec: Vec<Value>, inner_t: Type ) -> Arr 
        {
            Arr {
                inner: Arc::new( ArrInner { vec, inner_t } ),
            }
        }
        /// Returns a reference to the inner vec of this `Arr`.
        pub fn vec_ref( &self ) -> &Vec<Value> 
        {
            &self.inner.vec
        }
        /// Iterates over each `Value` in `self`, applying `Fn` `f`.
        pub fn with_each<F>( &self, mut f: F ) where
            F: FnMut( &Value ),
        {
            for value in &self.inner.vec {
                f( value )
            }
        }
        /// Gets the value at `index`.
        pub fn get( &self, index: usize ) -> OverResult<Value> 
        {
            if index >= self.inner.vec.len() {
                Err( OverError::ArrOutOfBounds( index ) )
            } else {
                Ok( self.inner.vec[index].clone() )
            }
        }
        /// Returns the type of all elements in this `Arr`.
        pub fn inner_type( &self ) -> Type {
            self.inner.inner_t.clone()
        }
        /// Returns the length of this `Arr`.
        pub fn len( &self ) -> usize {
            self.inner.vec.len()
        }
        /// Returns whether this `Arr` is empty.
        pub fn is_empty( &self ) -> bool {
            self.inner.vec.is_empty()
        }
        /// Returns whether `self` and `other` point to the same data.
        pub fn ptr_eq( &self, other:&Self ) -> bool 
        {
            Arc::ptr_eq( &self.inner, &other.inner )
        }
        /// Returns an iterator over the Arr.
        pub fn iter( &self ) -> Iter<Value> 
        {
            self.vec_ref().iter()
        }
    }

    impl Default for Arr 
    {
        fn default() -> Self {
            Self::from_vec_unchecked( vec![], Type::Any )
        }
    }

    impl fmt::Display for Arr 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl PartialEq for Arr 
    {
        fn eq( &self, other:&Self ) -> bool {
           
            if self.inner.inner_t != other.inner.inner_t {
                return false;
            }
            self.inner.vec == other.inner.vec
        }
    }
}

pub mod ascii
{
    pub use std::ascii::{ * };
    
    const T: bool = true;
    const F: bool = false;

    #[repr( C, align( 8 ) )]
    pub struct Align8<T>( pub T );
    #[repr( C, align( 64 ) )]
    pub struct Align64<T>( pub T );

    pub static ASCII_START: Align64<[bool; 128]> = Align64
    ( [
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ] );

    pub static ASCII_CONTINUE: Align64<[bool; 128]> = Align64
    ( [
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
        F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, T, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ] );

    pub const CHUNK: usize = 64;

    pub static TRIE_START: Align8<[u8; 411]> = Align8
    ( [
        0x04, 0x0B, 0x0F, 0x13, 0x17, 0x1B, 0x1F, 0x23, 0x27, 0x2D, 0x31, 0x34, 0x38, 0x3C, 0x40, 0x02, 0x45, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x4D, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x51, 0x54, 0x58, 0x5C, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 
        0x64, 0x66, 0x6A, 0x6E, 0x72, 0x28, 0x76, 0x78, 0x7C, 0x80, 0x84, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0, 
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xA8, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 
        0x05, 0xB2, 0xB6, 0xBA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xD1, 0xD3, 0x00, 0x00, 0x00, 0xC9, 0xD9, 0xDD, 0xE1, 0xE5, 0xE9, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7,
    ] );

    pub static TRIE_CONTINUE: Align8<[u8; 1793]> = Align8
    ( [
        0x08, 0x0D, 0x11, 0x15, 0x19, 0x1D, 0x21, 0x25, 0x2A, 0x2F, 0x31, 0x36, 0x3A, 0x3E, 0x42, 0x02,0x47, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x4F, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x51, 0x56, 0x5A, 0x5E, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 
        0x64, 0x68,0x6C, 0x70, 0x74, 0x28, 0x76, 0x7A, 0x7E, 0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E, 0xA2,
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xAB, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xB0, 0x00, 0x00, 0x00, 
        0x05, 0xB4, 0xB8, 0xBC, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xC3, 0xC6, 0xCE, 
        0xD1, 0xD5, 0x00, 0xD7, 0x00, 0xC9,0xDB, 0xDF, 0xE3, 0xE7, 0xEB, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xCC, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xCF,
    ] );

    pub static LEAF: Align64<[u8; 7968]> = Align64
    ( [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA, 
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F, 0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 
        0xDC, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xA0, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 
        0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0xDF, 0xB8, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xB8, 0xC0, 0xD7, 0xFF, 0xFF,
        0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
        0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0x87, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFB, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xB6, 0x00, 0xFF, 0xFF, 0xFF, 0x87, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC0, 0xFE, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2F, 0x00, 0x60, 0xC0, 0x00, 0x9C,
        0x00, 0x00, 0xFD, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x02, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x07, 0x30, 0x04,
        0x00, 0x00, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0x9F, 0xFF, 0xFD, 0xFF, 0x9F,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x24,
        0xFF, 0xFF, 0x3F, 0x04, 0x10, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x01, 0xFF, 0x03, 0x00, 0xFE, 0xFF,
        0xE1, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x23, 0x00, 0x40, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x10,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFE, 0xFF,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0xF3, 0x9F, 0x79, 0x80, 0xB0, 0xCF, 0xFF, 0x03, 0x50,
        0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x1C, 0x00,
        0xE0, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x02,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x02, 0x00,
        0xE8, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEE, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0xD3, 0x87, 0x39, 0x02, 0x5E, 0xC0, 0xFF, 0x3F, 0x00,
        0xEE, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0xBF, 0x3B, 0x01, 0x00, 0xCF, 0xFF, 0x00, 0xFE,
        0xEE, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0x9F, 0x39, 0xE0, 0xB0, 0xCF, 0xFF, 0x02, 0x00,
        0xEC, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0xC3, 0xC7, 0x3D, 0x81, 0x00, 0xC0, 0xFF, 0x00, 0x00,
        0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x23, 0x00, 0x00, 0x00, 0x37, 0x03, 0x00, 0x00, 0x00,
        0xE1, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x23, 0x00, 0x00, 0x00, 0x70, 0x03, 0x00, 0x06, 0x00,
        0xF0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x27, 0x00, 0x40, 0x70, 0x80, 0x03, 0x00, 0x00, 0xFC,
        0xE0, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0xF3, 0xDF, 0x3D, 0x60, 0x37, 0xCF, 0xFF, 0x00, 0x00,
        0xEF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0xF3, 0xDF, 0x3D, 0x60, 0x70, 0xCF, 0xFF, 0x0E, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x7D, 0xF0, 0x80, 0xCF, 0xFF, 0x00, 0xFC,
        0xEE, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x84, 0x5F, 0xFF, 0xC0, 0xFF, 0x0C, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0x05, 0x20, 0x5F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x7F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0xFF, 0x3F, 0x5F, 0x7F, 0xFF, 0xF3, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x03, 0xFF, 0x03, 0xA0, 0xC2, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0xFE, 0xFF,
        0xDF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x80, 0x00, 0x00, 0x3F, 0x3C, 0x62, 0xC0, 0xE1, 0xFF,
        0x03, 0x40, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0xFE, 0x03, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x03, 0x80, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xDF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF, 0x1F, 0x00, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xDF, 0x0D, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0x30, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xB8, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x0F, 0xFF, 0x0F, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x01, 0xC0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x9F,
        0xFF, 0x03, 0xFF, 0x03, 0x80, 0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x0F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03, 0x00, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x6F, 0x04,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x27, 0x00, 0xF0, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x1F, 0xE2, 0xFF, 0x01, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x78, 0x0C, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x80,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE6, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0x00, 0x0C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xBF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xBB, 0xF7, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x68,
        0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x80, 0x00, 0x00, 0xDF, 0xFF, 0x00, 0x7C,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xE8,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x80, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0xF7, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0xC4,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x62, 0x3E, 0x05, 0x00, 0x00, 0x38, 0xFF, 0x07, 0x1C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0x7F, 0xFC,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x38, 0xFF, 0xFF, 0x7C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x37, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xA0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xE0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0xFF, 0xFF, 0x07, 0xC0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0xFF, 0x03, 0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07, 0xE0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0x3F, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x91, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x37, 0x00,
        0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x6F, 0xF0, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x87, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xBE, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1B, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x90, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x47, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x3F, 0x80,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x4F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xDE, 0xFF, 0x17, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0xE0, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x03,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xFB, 0x9F, 0x39, 0x81, 0xE0, 0xCF, 0x1F, 0x1F, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xA5, 0xF7, 0x0F, 0x00, 0x06, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x80, 0x07, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xC3, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x01, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x0F, 0xFF, 0x03, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0xBF, 0xF9, 0x0F, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1B, 0x00, 0x00, 0x00,
        0x01, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0x00, 0x01, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0x03,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x01, 0x00, 0xFF, 0x03, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xB4, 0xFF, 0x00, 0xFF, 0x03, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x7F, 0xFB, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xF4, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x07, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x0F, 0x00, 0xFF, 0x03, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x7C, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x6F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE3, 0x07, 0xF8,
        0xE7, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xE0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xDF, 0x64, 0xDE, 0xFF, 0xEB, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xBF, 0xE7, 0xDF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7B, 0x5F, 0xFC, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x20, 0x00,
        0x10, 0x00, 0x00, 0xF8, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x3F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFF, 0xFF, 0xF9, 0xDB, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x3F, 0xFF, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xB7, 0x3F, 0x1F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x3F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEF, 0xFF, 0xFF, 0xFF, 0x96, 0xFE, 0xF7, 0x0A, 0x84, 0xEA, 0x96, 0xAA, 0x96, 0xF7, 0xF7, 0x5E,
        0xFF, 0xFB, 0xFF, 0x0F, 0xEE, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ] );
}

pub mod backtrace
{
    pub use std::backtrace::{ * };
}

pub mod bits
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    pub mod flags
    {
        /*!
        Generate types for C-style flags with ergonomic APIs.*/
        use ::
        {
            *,
        };
        /*
        */
        pub mod iter
        {           
            /*!
            Yield the bits of a source flags value in a set of contained flags values. */
            use ::
            {
                *,
            };
            /*
            */
            use super::{ Flag, Flags };
            /**
            An iterator over flags values. */
            pub struct Iter<B: 'static> 
            {
                inner: IterNames<B>,
                done: bool,
            }

            impl<B: Flags> Iter<B> 
            {
                pub fn new(flags: &B) -> Self {
                    Iter {
                        inner: IterNames::new(flags ),
                        done: false,
                    }
                }
            }

            impl<B: 'static> Iter<B> 
            {
                // Used by the `bitflags` macro
                #[doc(hidden)]
                pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self {
                    Iter {
                        inner: IterNames::__private_const_new(flags, source, remaining),
                        done: false,
                    }
                }
            }

            impl<B: Flags> Iterator for Iter<B> 
            {
                type Item = B;

                fn next(&mut self) -> Option<Self::Item> {
                    match self.inner.next() {
                        Some((_, flag)) => Some(flag),
                        None if !self.done => {
                            self.done = true;

                            // After iterating through valid names, if there are any bits left over
                            // then return one final value that includes them. This makes `into_iter`
                            // and `from_iter` roundtrip
                            if !self.inner.remaining().is_empty() {
                                Some( b::from_bits_retain(self.inner.remaining.bits()))
                            } else {
                                None
                            }
                        }
                        None => None,
                    }
                }
            }
            /**
            An iterator over flags values.*/
            pub struct IterNames<B: 'static> {
                flags: &'static [Flag<B>],
                idx: usize,
                source: B,
                remaining: B,
            }

            impl<B: Flags> IterNames<B> {
                pub fn new(flags: &B) -> Self {
                    IterNames {
                        flags: B::FLAGS,
                        idx: 0,
                        remaining: B::from_bits_retain(flags.bits()),
                        source: B::from_bits_retain(flags.bits()),
                    }
                }
            }

            impl<B: 'static> IterNames<B> {
                // Used by the bitflags macro
                #[doc(hidden)]
                pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, remaining: B) -> Self {
                    IterNames {
                        flags,
                        idx: 0,
                        remaining,
                        source,
                    }
                }
                /// Get a flags value of any remaining bits that haven't been yielded yet.
                ///
                /// Once the iterator has finished, this method can be used to
                /// check whether or not there are any bits that didn't correspond
                /// to a contained, defined, named flag remaining.
                pub fn remaining(&self) -> &B {
                    &self.remaining
                }
            }

            impl<B: Flags> Iterator for IterNames<B> {
                type Item = (&'static str, B);

                fn next(&mut self) -> Option<Self::Item> {
                    while let Some(flag) = self.flags.get(self.idx) {
                        // Short-circuit if our state is empty
                        if self.remaining.is_empty() {
                            return None;
                        }

                        self.idx += 1;

                        // Skip unnamed flags
                        if flag.name().is_empty() {
                            continue;
                        }

                        let bits = flag.value().bits();

                        // If the flag is set in the original source _and_ it has bits that haven't
                        // been covered by a previous flag yet then yield it. These conditions cover
                        // two cases for multi-bit flags:
                        //
                        // 1. When flags partially overlap, such as `0b00000001` and `0b00000101`, we'll
                        // yield both flags.
                        // 2. When flags fully overlap, such as in convenience flags that are a shorthand for others,
                        // we won't yield both flags.
                        if self.source.contains( b::from_bits_retain( bits ))
                            && self.remaining.intersects( b::from_bits_retain( bits ))
                        {
                            self.remaining.remove( b::from_bits_retain( bits ));

                            return Some((flag.name(), B::from_bits_retain( bits )));
                        }
                    }

                    None
                }
            }

            /**
            An iterator over all defined named flags.

            This iterator will yield flags values for all defined named flags, regardless of
            whether they are contained in a particular flags value.
            */
            pub struct IterDefinedNames<B: 'static> {
                flags: &'static [Flag<B>],
                idx: usize,
            }

            impl<B: Flags> IterDefinedNames<B> {
                pub fn new() -> Self {
                    IterDefinedNames {
                        flags: B::FLAGS,
                        idx: 0,
                    }
                }
            }

            impl<B: Flags> Iterator for IterDefinedNames<B>
            {
                type Item = (&'static str, B);

                fn next(&mut self) -> Option<Self::Item>
                {
                    while let Some(flag) = self.flags.get(self.idx)
                    {
                        self.idx += 1;
                        if flag.is_named() { return Some((flag.name(), B::from_bits_retain(flag.value().bits()))); }
                    }

                    None
                }
            }
        } pub use self::iter::{ * };

        pub mod parser
        {
            /*!
            Parsing flags from text.*/
            use ::
            {
                fmt::{ self, Write },
                *,
            };

            use super::{ * };
            /*
            */
            /**
            Write a flags value as text.*/
            pub fn to_writer<B:Flags>( b:&B, mut w:impl Write ) -> Result<(), fmt::Error> where
            B::Bits: WriteHex
            {
                let mut first = true;
                let mut iter = b.iter_names();

                for (name, _) in &mut iter
                {
                    if !first { w.write_str(" | ")?; }

                    first = false;
                    w.write_str(name)?;
                }
                
                let remaining = iter.remaining().bits();
                
                if remaining != B::Bits::EMPTY
                {
                    if !first { w.write_str(" | ")?; }

                    w.write_str("0x")?;
                    remaining.write_hex( w )?;
                }

                fmt::Result::Ok(())
            }
            /**
            Parse a flags value from text. */
            pub fn from_str<B: Flags>( t:&str ) -> Result<B, ParseError> where
            B::Bits: ParseHex
            {
                let mut parsed_flags = B::empty();
                
                if t.trim().is_empty() { return Ok(parsed_flags ); }

                for flag in t.split('|')
                {
                    let flag = flag.trim();
                    
                    if flag.is_empty() { return Err(ParseError::empty_flag()); }
                    
                    let parsed_flag = if let Some(flag) = flag.strip_prefix("0x")
                    {
                        let bits = <B::Bits>::parse_hex(flag).map_err( | _ | ParseError::invalid_hex_flag( flag ) )?;
                        B::from_bits_retain( bits )
                    }
                    
                    else { B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))? };

                    parsed_flags.insert(parsed_flag);
                }

                Ok(parsed_flags )
            }
            /**
            Write a flags value as text, ignoring any unknown bits. */
            pub fn to_writer_truncate<B: Flags>( f: &B, w:impl Write ) -> Result<(), fmt::Error> where
            B::Bits: WriteHex
            {
                to_writer( &B::from_bits_truncate( f.bits() ), w )
            }
            /**
            Parse a flags value from text. */
            pub fn from_str_truncate<B: Flags>( t:&str ) -> Result<B, ParseError> where
            B::Bits: ParseHex
            { Ok( B::from_bits_truncate( from_str::<B>( t )?.bits() ) ) }
            /**
            Write only the contained, defined, named flags in a flags value as text. */
            pub fn to_writer_strict<B: Flags>( f: &B, mut w: impl Write) -> Result<(), fmt::Error>
            {
                let mut first = true;
                let mut iter = f.iter_names();

                for (name, _) in &mut iter
                {
                    if !first { w.write_str(" | ")?; }

                    first = false;
                    w.write_str(name)?;
                }

                fmt::Result::Ok(())
            }
            /**
            Parse a flags value from text.*/
            pub fn from_str_strict<B: Flags>( t:&str ) -> Result<B, ParseError>
            {
                let mut parsed_flags = B::empty();
                if t.trim().is_empty() { return Ok(parsed_flags ); }

                for flag in t.split('|')
                {
                    let flag = flag.trim();
                    if flag.is_empty() { return Err(ParseError::empty_flag()); }
                    
                    if flag.starts_with("0x") { return Err(ParseError::invalid_hex_flag("unsupported hex flag")); }

                    let parsed_flag = B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))?;

                    parsed_flags.insert(parsed_flag);
                }

                Ok( parsed_flags )
            }
            /// An error encountered while parsing flags from text.
            #[derive(Debug)]
            pub struct ParseError( ParseErrorKind );

            #[derive(Debug)]
            enum ParseErrorKind
            {
                EmptyFlag,
                InvalidNamedFlag
                {
                    got: String,
                },
                InvalidHexFlag
                {
                    got: String,
                },
            }

            impl ParseError
            {
                /// An invalid hex flag was encountered.
                pub fn invalid_hex_flag(flag: impl fmt::Display) -> Self
                {
                    let _flag = flag;
                    let got = _flag.to_string();
                    ParseError(ParseErrorKind::InvalidHexFlag { got })
                }
                /// A named flag that doesn't correspond to any on the flags type was encountered.
                pub fn invalid_named_flag(flag: impl fmt::Display) -> Self 
                {
                    let _flag = flag;
                    let got = _flag.to_string();
                    ParseError(ParseErrorKind::InvalidNamedFlag { got })
                }
                /// A hex or named flag wasn't found between separators.
                pub const fn empty_flag() -> Self { ParseError(ParseErrorKind::EmptyFlag) }
            }

            impl fmt::Display for ParseError 
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    match &self.0 
                    {
                        ParseErrorKind::InvalidNamedFlag { got } => 
                        {
                            let _got = got;
                            write!(f, "unrecognized named flag")?;
                            write!(f, " `{}`", _got )?;
                        }

                        ParseErrorKind::InvalidHexFlag { got } => 
                        {
                            let _got = got;
                            write!(f, "invalid hex flag")?;
                            write!(f, " `{}`", _got )?;
                        }

                        ParseErrorKind::EmptyFlag => { write!(f, "encountered empty flag")?; }
                    }

                    Ok(())
                }
            }
            
            impl std::error::Error for ParseError {}
        } pub use self::parser::{ * };
        
        pub mod traits
        {
            /*!
            */
            use ::
            {
                ops::{BitAnd, BitOr, BitXor, Not},
                *,
            };
            /**
            A defined flags value that may be named or unnamed.
            */
            #[derive( Debug )]
            pub struct Flag<B> 
            {
                name: &'static str,
                value: B,
            }

            impl<B> Flag<B> 
            {
                /**
                Define a flag. */
                pub const fn new(name: &'static str, value: B) -> Self { Flag { name, value } }
                /**
                Get the name of this flag. */
                pub const fn name(&self) -> &'static str { self.name }
                /**
                Get the flags value of this flag.
                */
                pub const fn value(&self) -> &B { &self.value }
                /**
                Whether the flag is named. */
                pub const fn is_named(&self) -> bool { !self.name.is_empty() }
                /**
                Whether the flag is unnamed. */
                pub const fn is_unnamed(&self) -> bool { self.name.is_empty() }
            }
            /**
            A set of defined flags using a bits type as storage.*/
            pub trait Flags: Sized + 'static 
            {
                /// The set of defined flags.
                const FLAGS: &'static [Flag<Self>];
                /// The underlying bits type.
                type Bits: Bits;
                /// Get a flags value with all bits unset.
                fn empty() -> Self { Self::from_bits_retain(Self::Bits::EMPTY) }
                /// Get a flags value with all known bits set.
                fn all() -> Self
                {
                    let mut truncated = Self::Bits::EMPTY;

                    for flag in Self::FLAGS.iter()
                    {
                        truncated = truncated | flag.value().bits();
                    }
                    
                    Self::from_bits_retain( truncated)
                }
                /// This method will return `true` if any unknown bits are set.
                fn contains_unknown_bits(&self) -> bool { Self::all().bits() & self.bits() != self.bits() }
                /// Get the underlying bits value.
                fn bits(&self) -> Self::Bits;
                /// Convert from a bits value.
                fn from_bits( bits: Self::Bits ) -> Option<Self> 
                {
                    let truncated = Self::from_bits_truncate( bits );

                    if truncated.bits() == bits { Some( truncated ) }
                    else { None }
                }
                /// Convert from a bits value, unsetting any unknown bits.
                fn from_bits_truncate( bits: Self::Bits ) -> Self { Self::from_bits_retain( bits & Self::all().bits()) }
                /// Convert from a bits value exactly.
                fn from_bits_retain( bits: Self::Bits ) -> Self;
                /// Get a flags value with the bits of a flag with the given name set.
                fn from_name(name: &str) -> Option<Self>
                {
                    if name.is_empty() { return None; }

                    for flag in Self::FLAGS 
                    {
                        if flag.name() == name { return Some(Self::from_bits_retain(flag.value().bits())); }
                    }

                    None
                }
                /// Yield a set of contained flags values.
                fn iter(&self) -> super::iter::Iter<Self>
                {
                    super::iter::Iter::new(self)
                }
                /// Yield a set of contained named flags values.
                fn iter_names(&self) -> super::iter::IterNames<Self> { super::iter::IterNames::new(self) }
                /// Yield a set of all named flags defined by [`Self::FLAGS`].
                fn iter_defined_names() -> super::iter::IterDefinedNames<Self> { super::iter::IterDefinedNames::new() }
                /// Whether all bits in this flags value are unset.
                fn is_empty(&self) -> bool { self.bits() == Self::Bits::EMPTY }
                /// Whether all known bits in this flags value are set.
                fn is_all(&self) -> bool  { Self::all().bits() | self.bits() == self.bits() }
                /// Whether any set bits in a source flags value are also set in a target flags value.
                fn intersects(&self, other: Self) -> bool where
                Self: Sized
                { self.bits() & other.bits() != Self::Bits::EMPTY }
                /// Whether all set bits in a source flags value are also set in a target flags value.
                fn contains(&self, other: Self) -> bool where
                Self: Sized
                { self.bits() & other.bits() == other.bits() }
                /// Remove any unknown bits from the flags.
                fn truncate(&mut self) where
                Self: Sized
                { *self = Self::from_bits_truncate(self.bits()); }
                /// The bitwise or (`|`) of the bits in two flags values.
                fn insert(&mut self, other: Self) where
                Self: Sized
                { *self = Self::from_bits_retain(self.bits()).union( other ); }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                fn remove(&mut self, other: Self) where
                Self: Sized
                { *self = Self::from_bits_retain(self.bits()).difference( other ); }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                fn toggle(&mut self, other: Self) where
                Self: Sized
                { *self = Self::from_bits_retain(self.bits()).symmetric_difference( other ); }
                /// Call [`Flags::insert`] when `value` is `true` or [`Flags::remove`] when `value` is `false`.
                fn set(&mut self, other: Self, value: bool) where
                Self: Sized
                {
                    if value { self.insert( other ); }
                    else { self.remove( other ); }
                }
                /// Unsets all bits in the flags.
                fn clear(&mut self) where
                Self: Sized
                { *self = Self::empty(); }
                /// The bitwise and (`&`) of the bits in two flags values.
                #[must_use]
                fn intersection(self, other: Self) -> Self { Self::from_bits_retain(self.bits() & other.bits()) }
                /// The bitwise or (`|`) of the bits in two flags values.
                #[must_use]
                fn union(self, other: Self) -> Self { Self::from_bits_retain(self.bits() | other.bits()) }
                /// The intersection of a source flags value with the complement of a target flags value (`&!`).
                #[must_use]
                fn difference(self, other: Self) -> Self { Self::from_bits_retain(self.bits() & !other.bits()) }
                /// The bitwise exclusive-or (`^`) of the bits in two flags values.
                #[must_use]
                fn symmetric_difference(self, other: Self) -> Self { Self::from_bits_retain(self.bits() ^ other.bits()) }
                /// The bitwise negation (`!`) of the bits in a flags value, truncating the result.
                #[must_use]
                fn complement(self) -> Self { Self::from_bits_truncate(!self.bits()) }
            }
            /**
            A bits type that can be used as storage for a flags type. */
            pub trait Bits:
            Clone
            + Copy
            + PartialEq
            + BitAnd<Output = Self>
            + BitOr<Output = Self>
            + BitXor<Output = Self>
            + Not<Output = Self>
            + Sized
            + 'static
            {
                /// A value with all bits unset.
                const EMPTY: Self;
                /// A value with all bits set.
                const ALL: Self;
            }
            
            pub trait Primitive {}

            macro_rules! impl_bits 
            {
                ( $( $u:ty, $i:ty,)*) => 
                {
                    $(
                        impl Bits for $u 
                        {
                            const EMPTY: $u = 0;
                            const ALL: $u = <$u>::MAX;
                        }

                        impl Bits for $i 
                        {
                            const EMPTY: $i = 0;
                            const ALL: $i = <$u>::MAX as $i;
                        }

                        impl ParseHex for $u 
                        {
                            fn parse_hex(input: &str) -> Result<Self, ::bits::flags::ParseError> 
                            { <$u>::from_str_radix(input, 16).map_err(|_| ::bits::flags::ParseError::invalid_hex_flag(input )) }
                        }

                        impl ParseHex for $i
                        {
                            fn parse_hex(input: &str) -> Result<Self, ::bits::flags::ParseError> 
                            { <$i>::from_str_radix(input, 16).map_err(|_| ::bits::flags::ParseError::invalid_hex_flag(input )) }
                        }

                        impl WriteHex for $u
                        {
                            fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result { write!(writer, "{:x}", self) }
                        }

                        impl WriteHex for $i
                        {
                            fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result { write!(writer, "{:x}", self) }
                        }

                        impl Primitive for $i {}
                        impl Primitive for $u {}
                    )*
                }
            }

            impl_bits! 
            { 
                u8, u16, u32, u64, u128, usize,
                i8, i16, i32, i64, i128, isize,
            }
            /// A trait for referencing the `bitflags`-owned internal type without exposing it publicly.
            pub trait PublicFlags 
            {
                /// The type of the underlying storage.
                type Primitive: Primitive;
                /// The type of the internal field on the generated flags type.
                type Internal;
            }
            /**
            Encode a value as a hex string. */
            pub trait WriteHex
            {
                /// Write the value as hex.
                fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result;
            }
            /**
            Parse a value from a hex string. */
            pub trait ParseHex
            {
                /// Parse the value from hex.
                fn parse_hex(input: &str) -> Result<Self, super::parser::ParseError> where Self: Sized;
            }

            #[doc(hidden)]
            #[deprecated(note = "use the `Flags` trait instead")]
            pub trait BitFlags: ImplementedByBitFlagsMacro + Flags 
            {
                /// An iterator over enabled flags in an instance of the type.
                type Iter: Iterator<Item = Self>;
                /// An iterator over the raw names and bits for enabled flags in an instance of the type.
                type IterNames: Iterator<Item = (&'static str, Self)>;
            }

            #[allow(deprecated)]
            impl<B: Flags> BitFlags for B 
            {
                type Iter = ::bits::flags::iter::Iter<Self>;
                type IterNames = ::bits::flags::iter::IterNames<Self>;
            }

            impl<B: Flags> ImplementedByBitFlagsMacro for B {}
            /// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.
            #[doc(hidden)]
            pub trait ImplementedByBitFlagsMacro {}

            pub mod __private 
            {
                pub use super::{ImplementedByBitFlagsMacro, PublicFlags};
            }
        } pub use self::traits::{ * };
    }
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod char
{
    /*!
    Character stream used for parsing. */
    pub use std::char::{ * };
    use ::
    {
        cell::{ RefCell },
        fs::{ File },
        io::{ self, Read },
        iter::{ Peekable },
        rc::{ Rc },
        str::{ Chars },
        *,
    };
    /*
    */
    #[allow( dead_code )]
    #[derive( Clone, Debug )]
    struct Inner 
    {
        file: Option<String>,
        contents: String,
        stream: Peekable<Chars<'static>>,
        line: usize,
        col: usize,
    }

    #[derive( Clone, Debug )]
    pub struct CharStream 
    {
        inner: Rc<RefCell<Inner>>,
    }

    impl CharStream 
    {
        pub fn from_file( path:&str ) -> io::Result<CharStream> 
        {
            let mut file = File::open( path )?;

            let len = file.metadata()?.len();
            let mut contents = String::with_capacity( len as usize );

            file.read_to_string( &mut contents )?;

            Self::from_string_impl( Some( String::from( path ) ), contents )
        }

        fn from_string_impl( file: Option<String>, contents: String ) -> io::Result<CharStream> 
        {
            let chars: Chars = unsafe { mem::transmute( contents.chars() ) };
            let stream = chars.peekable();
            Ok( CharStream 
            {
                inner: Rc::new( RefCell::new( Inner 
                {
                    file,
                    contents,
                    stream,
                    line: 1,
                    col: 1,
                } ) ),
            } )
        }

        pub fn from_string( contents: String ) -> io::Result<CharStream> 
        {
            Self::from_string_impl( None, contents )
        }

        pub fn peek( &self ) -> Option<char> 
        {
            let mut inner = self.inner.borrow_mut();
            let opt = inner.stream.peek();

            match opt {
                Some( ch ) => Some( *ch ),
                None => None,
            }
        }

        pub fn file( &self ) -> Option<String> 
        {
            let inner = self.inner.borrow();
            inner.file.clone()
        }

        pub fn line( &self ) -> usize 
        {
            let inner = self.inner.borrow();
            inner.line
        }

        pub fn col( &self ) -> usize 
        {
            let inner = self.inner.borrow();
            inner.col
        }

        fn set_line( &mut self, value: usize ) 
        {
            let mut inner = self.inner.borrow_mut();
            inner.line = value;
        }

        fn set_col( &mut self, value: usize ) 
        {
            let mut inner = self.inner.borrow_mut();
            inner.col = value;
        }
    }

    impl Iterator for CharStream 
    {
        type Item = char;

        fn next( &mut self ) -> Option<Self::Item>
        {
            let opt = {
                let mut inner = self.inner.borrow_mut();
                inner.stream.next()
            };

            match opt {
                Some( ch ) => {
                    if ch == '\n' {
                        let line = self.line();
                        self.set_line( line + 1 );
                        self.set_col( 1 );
                    } else {
                        let col = self.col();
                        self.set_col( col + 1 );
                    }
                    Some( ch )
                }
                None => None,
            }
        }
    }

    pub fn format( ch:char ) -> String 
    {
        match ch {
            '\n' => String::from( "\\n" ),
            ch => format!( "{}", ch ),
        }
    }
    /// Returns the width of a character in the terminal.
    // #[inline] pub fn char_width( ch:char ) -> Option<usize>
    #[inline] pub fn width( ch:char ) -> Option<usize>
    {
        use unicode_width::UnicodeWidthChar;
        ch.width()
    }
    /// Returns the control character corresponding to the given character.
    #[inline] pub fn control( ch:char ) -> char { ( ( ch as u8 ) & 0x1f ) as char }
    /// Returns the ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_upper( ch:char ) -> char { ( ( ch as u8 ) | 0x40 ) as char }
    /// Returns the lowercase ASCII character corresponding to the given control character.
    #[inline] pub fn unctrl_lower( ch:char ) -> char { unctrl_upper( ch ).to_ascii_lowercase() }
    /// Character value indicating end-of-file
    pub const EOF:char = '\x04';
    /// Character value generated by the Escape key
    pub const ESCAPE:char = '\x1b';
    /// Character value generated by the Backspace key
    ///
    /// On Unix systems, this is equivalent to `RUBOUT`
    #[cfg( unix )]
    pub const DELETE:char = RUBOUT;
    /// Character value generated by the Backspace key.
    #[cfg( windows )]
    pub const DELETE:char = '\x08';
    /// Character value generated by the Backspace key on some systems
    pub const RUBOUT:char = '\x7f';
    /// Returns a character name as a key sequence, e.g. `Control-x` or `Meta-x`.
    pub fn parse_char_name( name:&str ) -> Option<String>
    {
        let name_lc = name.to_lowercase();

        let is_ctrl = contains_any( &name_lc, &["c-", "ctrl-", "control-"] );
        let is_meta = contains_any( &name_lc, &["m-", "meta-"] );

        let name = match name_lc.rfind( '-' ) {
            Some( pos ) => &name_lc[pos + 1..],
            None => &name_lc[..]
        };

        let ch = match name {
            "del" | "rubout"  => DELETE,
            "esc" | "escape"  => ESCAPE,
            "lfd" | "newline" => '\n',
            "ret" | "return"  => '\r',
            "spc" | "space"   => ' ',
            "tab"             => '\t',
            s if !s.is_empty() => s.chars().next().unwrap(),
            _ => return None
        };

        let ch = match ( is_ctrl, is_meta ) {
            ( true,  true )  => meta( ctrl( ch ) ),
            ( true,  false ) => ctrl( ch ).to_string(),
            ( false, true )  => meta( ch ),
            ( false, false ) => ch.to_string(),
        };

        Some( ch )
    }
    /// Returns a character sequence escaped for user-facing display.
    pub fn escape_sequence( s:&str ) -> String
    {
        let mut res = String::with_capacity( s.len() );

        for ch in s.chars()
        {
            match ch
            {
                ESCAPE => res.push_str( r"\e" ),
                RUBOUT => res.push_str( r"\C-?" ),
                '\\' => res.push_str( r"\\" ),
                '\'' => res.push_str( r"\'" ),
                '"' => res.push_str( r#"\""# ),
                ch if is_ctrl( ch ) => {
                    res.push_str( r"\C-" );
                    res.push( unctrl_lower( ch ) );
                }
                ch => res.push( ch )
            }
        }

        res
    }
    /// Returns a meta sequence for the given character.
    pub fn meta( ch:char ) -> String
    {
        let mut s = String::with_capacity( ch.len_utf8() + 1 );
        s.push( ESCAPE );
        s.push( ch );
        s
    }

    fn contains_any( s:&str, strs:&[&str] ) -> bool { strs.iter().any( |a| s.contains( a ) ) }
    /// Returns whether the character is printable.
    pub fn is_printable( c:char ) -> bool { c == '\t' || c == '\n' || !( c == '\0' || is::control( c ) ) }

    const CTRL_BIT: u8 = 0x40;
    const CTRL_MASK: u8 = 0x1f;
    /// Returns whether the given character is a control character.
    pub fn is_ctrl( c:char ) -> bool
    {
        const CTRL_MAX: u32 = 0x1f;
        c != '\0' && c as u32 <= CTRL_MAX
    }
    /// Returns a control character for the given character.
    pub fn ctrl( c:char ) -> char { ( ( c as u8 ) & CTRL_MASK ) as char }
    /// Returns the printable character corresponding to the given control character.
    pub fn unctrl( c:char ) -> char { ( ( c as u8 ) | CTRL_BIT ) as char }
    /// Returns a string consisting of a `char`, repeated `n` times.
    // pub fn repeat_char( ch:char, n: usize ) -> String
    pub fn repeat( ch:char, n: usize ) -> String
    {
        let mut buf = [0; 4];
        let s = ch.encode_utf8( &mut buf );
        s.repeat( n )
    }
    // pub fn backward_char( n: usize, s:&str, cur: usize ) -> usize
    pub fn backward( n: usize, s:&str, cur: usize ) -> usize
    {
        let mut chars = s[..cur].char_indices()
            .filter( |&( _, ch )| !is::combining_mark( ch ) );
        let mut res = cur;

        for _ in 0..n {
            match chars.next_back() {
                Some( ( idx, _ ) ) => res = idx,
                None => return 0
            }
        }

        res
    }
    // pub fn backward_search_char( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    pub fn backward_search( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n {
            match buf[..cur].rfind( ch ) {
                Some( p ) => {
                    cur = p;
                    pos = Some( cur );
                }
                None => break
            }
        }

        pos
    }
    // pub fn forward_char( n: usize, s:&str, cur: usize ) -> usize
    pub fn forward( n: usize, s:&str, cur: usize ) -> usize
    {
        let mut chars = s[cur..].char_indices()
            .filter( |&( _, ch )| !is::combining_mark( ch ) );

        for _ in 0..n {
            match chars.next() {
                Some( _ ) => (),
                None => return s.len()
            }
        }

        match chars.next() {
            Some( ( idx, _ ) ) => cur + idx,
            None => s.len()
        }
    }
    // pub fn forward_search_char( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    pub fn forward_search( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n {
            let off = match buf[cur..].chars().next() {
                Some( ch ) => ch.len_utf8(),
                None => break
            };

            match buf[cur + off..].find( ch ) {
                Some( p ) => {
                    cur += off + p;
                    pos = Some( cur );
                }
                None => break
            }
        }

        pos
    }
    /// Returns the first character in the buffer, if it contains any valid characters.
    // pub fn first_char( buf:&[u8] ) -> io::Result<Option<char>>
    pub fn first( buf:&[u8] ) -> io::Result<Option<char>>
    {
        match str::from_utf8( buf ) 
        {
            Ok( s ) => Ok( s.chars().next() ),
            Err( e ) => 
            {
                if e.error_len().is_some()
                {
                    return Err
                    ( 
                        io::Error::new( io::ErrorKind::InvalidData, "invalid utf-8 input received" )
                     );
                }

                let valid = e.valid_up_to();

                let s = unsafe { str::from_utf8_unchecked( &buf[..valid] ) };
                Ok( s.chars().next() )
            }
        }
    }
}

pub mod clone
{
    pub use std::clone::{ * };
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod env
{
    /*!
    */
    pub use std::env::{ * };
    use ::
    {
        path::{ Path },
        *,
    };
    /*
    */
    //pub fn init_path_env()
    pub fn initialize_paths()
    {
        let mut paths:Vec<String> = vec![];
        for x in
        [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ]
        {
            if Path::new( x ).exists() { paths.push( x.to_string() ); }
        }

        if let Ok( env_path ) = var( "PATH" )
        {
            for x in env_path.split( ":" )
            {
                if !paths.contains( &x.to_string() ) { paths.push( x.to_string() ); }
            }
        }
        
        let paths = paths.join( ":" );
        set_var( "PATH", paths );
    }
}

pub mod error
{
    /*!
    Error Handling */
    pub use std::error::{ * };

    use ::
    {
        types::{ Type },
        *,
    };
    /*
    */
    /// The fabulous OVER error type.
    #[derive( Debug, PartialEq, Eq )]
    pub enum OverError
    {
        ArrOutOfBounds( usize ),
        ArrTypeMismatch( Type, Type ),
        FieldNotFound( String ),
        InvalidFieldName( String ),
        NoParentFound,
        ParseError( String ),
        TupOutOfBounds( usize ),
        TupTypeMismatch( Type, Type, usize ),
        TypeMismatch( Type, Type ),
        IoError( String ),
    }

    impl fmt::Display for OverError 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            use self::OverError::*;

            match *self {
                ArrOutOfBounds( ref index ) => write!( f, "Arr index {} out of bounds", index ),
                ArrTypeMismatch( ref expected, ref found ) => write!( 
                    f,
                    "Arr inner types do not match: expected {}, found {}",
                    expected, found
                ),
                FieldNotFound( ref field ) => write!( f, "Field not found: \"{}\"", field ),
                InvalidFieldName( ref field ) => write!( f, "Invalid field name: \"{}\"", field ),
                NoParentFound => write!( f, "No parent found for this obj" ),
                TupOutOfBounds( ref index ) => write!( f, "Tup index {} out of bounds", index ),
                TupTypeMismatch( ref expected, ref found, ref index ) => write!( 
                    f,
                    "Tup inner types do not match at index {}: expected {}, found {}",
                    index, expected, found
                ),
                TypeMismatch( ref expected, ref found ) => {
                    write!( f, "Type mismatch: expected {}, found {}", expected, found )
                }
                ParseError( ref error ) | IoError( ref error ) => write!( f, "{}", error ),
            }
        }
    }

    impl Error for OverError
    {
        fn description( &self ) -> &str
        {
            use self::OverError::*;

            match *self 
            {
                ArrOutOfBounds( _ ) => "Arr index out of bounds",
                ArrTypeMismatch( _, _ ) => "Arr inner types do not match",
                FieldNotFound( _ ) => "Field not found",
                InvalidFieldName( _ ) => "Invalid field name",
                NoParentFound => "No parent found for this obj",
                TupOutOfBounds( _ ) => "Tup index out of bounds",
                TupTypeMismatch( _, _, _ ) => "Tup inner types do not match",
                TypeMismatch( _, _ ) => "Type mismatch",

                ParseError( ref error ) | IoError( ref error ) => error,
            }
        }
    }

    impl From<io::Error> for OverError
    {
        fn from( e: io::Error ) -> Self { OverError::IoError( format!( "{}", e ) ) }
    }

    impl From<ParseError> for OverError
    {
        fn from( e: ParseError ) -> Self
        {
            OverError::ParseError( format!( "{}", e ) )
        }
    }

    pub mod parse
    {
        /*!
        */
        use ::
        {
            char::{ format },
            error::{ Error, OverError },
            num::
            {
                big::{ BigInt, ParseBigIntError },
                ParseIntError
            },
            objects::{ Obj },
            parses::{ MAX_DEPTH, object_file, object_from_str },
            result::{ ParseResult },
            types::{ Type },
            *,
        };

        pub fn parse_err<T>( file: Option<String>, kind: ParseErrorKind ) -> ParseResult<T>
        {
            Err( ParseError { file, kind } )
        }
        /// Error kind.
        #[derive( Debug )]
        pub enum ParseErrorKind
        {
            BinaryOperatorError( Type, Type, char, usize, usize ),
            CyclicInclude( String, usize, usize ),
            DuplicateField( String, usize, usize ),
            DuplicateGlobal( String, usize, usize ),
            ExpectedType( Type, Type, usize, usize ),
            GlobalNotFound( String, usize, usize ),
            InvalidIndex( BigInt, usize, usize ),
            InvalidClosingBracket( Option<char>, char, usize, usize ),
            InvalidDot( Type, usize, usize ),
            InvalidEscapeChar( char, usize, usize ),
            InvalidFieldChar( char, usize, usize ),
            InvalidFieldName( String, usize, usize ),
            InvalidIncludeChar( char, usize, usize ),
            InvalidIncludePath( String, usize, usize ),
            InvalidIncludeToken( Type, usize, usize ),
            InvalidNumeric( usize, usize ),
            InvalidValue( String, usize, usize ),
            InvalidValueChar( char, usize, usize ),
            MaxDepth( usize, usize ),
            UnaryOperatorError( Type, char, usize, usize ),
            UnexpectedEnd( usize ),
            VariableNotFound( String, usize, usize ),

            IoError( String ),
            OverError( String ),
            ParseIntError( String ),
        }
        /// Parse error.
        #[derive( Debug )]
        pub struct ParseError 
        {
            /// The file this error occurred in.
            pub file: Option<String>,
            /// Error kind.
            pub kind: ParseErrorKind,
        }

        impl fmt::Display for ParseError 
        {
            fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
            {
                use self::ParseErrorKind::*;

                if let Some( ref file ) = ( *self ).file
                {
                    write!( f, "{}: ", file )?;
                }
                match ( *self ).kind
                {
                    BinaryOperatorError( ref expected, ref found, ref op, ref line, ref col ) => write!( 
                        f,
                        "Could not apply operator {} on types {} and {} at line {}, column {}",
                        op, expected, found, line, col,
                    ),
                    CyclicInclude( ref file, ref line, ref col ) => write!( 
                        f,
                        "Tried to cyclically include file \"{}\" at line {}, column {}",
                        file, line, col
                    ),
                    DuplicateField( ref field, ref line, ref col ) => write!( 
                        f,
                        "Duplicate field \"{}\" at line {}, column {}",
                        field, line, col
                    ),
                    DuplicateGlobal( ref field, ref line, ref col ) => write!( 
                        f,
                        "Duplicate global \"{}\" at line {}, column {}",
                        field, line, col
                    ),
                    ExpectedType( ref expected, ref found, ref line, ref col ) => write!( 
                        f,
                        "Expected {} at line {}, column {}; found {}",
                        expected, line, col, found
                    ),
                    GlobalNotFound( ref var, ref line, ref col ) => write!( 
                        f,
                        "Global \"{}\" at line {}, column {} could not be found",
                        var, line, col
                    ),
                    InvalidClosingBracket( ref expected, ref found, ref line, ref col ) => write!( 
                        f,
                        "Invalid closing bracket '{}' at line {}, column {}; expected {}",
                        found,
                        line,
                        col,
                        match *expected {
                            Some( ch ) => format!( "'{}'", ch ),
                            None => String::from( "none" ),
                        }
                    ),
                    InvalidDot( ref t, ref line, ref col ) => write!( 
                        f,
                        "Invalid use of dot notation on value of type {} at line {}, column {}; \
                        value must be an Obj, Arr, or Tup.",
                        t, line, col
                    ),
                    InvalidEscapeChar( ref ch, ref line, ref col ) => write!( 
                        f,
                        "Invalid escape character '\\{}' at line {}, column {}. \
                        If you meant to write a backslash, use '\\\\'",
                        format( *ch ),
                        line,
                        col
                    ),
                    InvalidFieldChar( ref ch, ref line, ref col ) => write!( 
                        f,
                        "Invalid character '{}' for field at line {}, column {}",
                        format( *ch ),
                        line,
                        col
                    ),
                    InvalidFieldName( ref field, ref line, ref col ) => write!( 
                        f,
                        "Invalid field name \"{}\" at line {}, column {}",
                        field, line, col
                    ),
                    InvalidIncludeChar( ref found, ref line, ref col ) => write!( 
                        f,
                        "Invalid include token character \'{}\' at line {}, column {}",
                        found, line, col
                    ),
                    InvalidIncludePath( ref path, ref line, ref col ) => write!( 
                        f,
                        "Invalid include path \"{}\" at line {}, column {}",
                        path, line, col
                    ),
                    InvalidIncludeToken( ref t, ref line, ref col ) => write!( 
                        f,
                        "Invalid value of type \"{}\" at line {}, column {}; \
                        must be either a Str value or one of the tokens \
                        \"Obj\", \"Arr\", \"Tup\", or \"Str\"",
                        t, line, col
                    ),
                    InvalidIndex( ref index, ref line, ref col ) => write!( 
                        f,
                        "Invalid index {} at line {}, column {}",
                        index, line, col
                    ),
                    InvalidNumeric( ref line, ref col ) => {
                        write!( f, "Invalid numeric value at line {}, column {}", line, col )
                    }
                    InvalidValue( ref value, ref line, ref col ) => write!( 
                        f,
                        "Invalid value \"{}\" at line {}, column {}",
                        value, line, col
                    ),
                    InvalidValueChar( ref ch, ref line, ref col ) => write!( 
                        f,
                        "Invalid character '{}' for value at line {}, column {}",
                        format( *ch ),
                        line,
                        col
                    ),
                    MaxDepth( ref line, ref col ) => write!( 
                        f,
                        "Exceeded maximum recursion depth ( {} ) at line {}, column {}",
                        MAX_DEPTH, line, col
                    ),
                    UnaryOperatorError( ref found, ref op, ref line, ref col ) => write!( 
                        f,
                        "Could not apply operator {} on type {} at line {}, column {}",
                        op, found, line, col,
                    ),
                    UnexpectedEnd( ref line ) => write!( f, "Unexpected end at line {}", line, ),
                    VariableNotFound( ref var, ref line, ref col ) => write!( 
                        f,
                        "Variable \"{}\" at line {}, column {} could not be found",
                        var, line, col
                    ),

                    IoError( ref error ) | OverError( ref error ) | ParseIntError( ref error ) => {
                        write!( f, "{}", error )
                    }
                }
            }
        }

        impl Error for ParseError 
        {
            fn description( &self ) -> &str {
                use self::ParseErrorKind::*;

                match ( *self ).kind {
                    BinaryOperatorError( _, _, _, _, _ ) | UnaryOperatorError( _, _, _, _ ) => {
                        "Could not apply operator"
                    }
                    CyclicInclude( _, _, _ ) => "Tried to cyclically include file",
                    DuplicateField( _, _, _ ) => "Duplicate field",
                    DuplicateGlobal( _, _, _ ) => "Duplicate global",
                    ExpectedType( _, _, _, _ ) => "Expected different type",
                    GlobalNotFound( _, _, _ ) => "Global could not be found",
                    InvalidClosingBracket( _, _, _, _ ) => "Invalid closing bracket",
                    InvalidDot( _, _, _ ) => "Invalid use of dot notation",
                    InvalidEscapeChar( _, _, _ ) => "Invalid escape character",
                    InvalidFieldChar( _, _, _ ) => "Invalid character for field",
                    InvalidFieldName( _, _, _ ) => "Invalid field name",
                    InvalidIncludeChar( _, _, _ ) => "Invalid include character",
                    InvalidIncludePath( _, _, _ ) => "Invalid include path",
                    InvalidIncludeToken( _, _, _ ) => "Invalid include token",
                    InvalidIndex( _, _, _ ) => "Invalid index",
                    InvalidNumeric( _, _ ) => "Invalid numeric value",
                    InvalidValue( _, _, _ ) => "Invalid value",
                    InvalidValueChar( _, _, _ ) => "Invalid character for value",
                    MaxDepth( _, _ ) => "Exceeded maximum depth for a container",
                    UnexpectedEnd( _ ) => "Unexpected end when reading value",
                    VariableNotFound( _, _, _ ) => "Variable could not be found",

                    IoError( ref error ) | OverError( ref error ) | ParseIntError( ref error ) => error,
                }
            }
        }

        impl ParseError 
        {
            /// Convert an `OverError` to a `ParseError` given line and column numbers.
            pub fn from_over( e:&OverError, file: Option<String>, line: usize, col: usize ) -> Self {
                ParseError {
                    file,
                    kind: ParseErrorKind::OverError( format!( "{} at line {}, col {}", e, line, col ) ),
                }
            }
        }

        impl From<()> for ParseError 
        {
            fn from( e:() ) -> Self {
                ParseError {
                    file: None,
                    kind: ParseErrorKind::IoError( format!( "()" ) ),
                }
            }
        }


        impl From<io::Error> for ParseError 
        {
            fn from( e: io::Error ) -> Self {
                ParseError {
                    file: None,
                    kind: ParseErrorKind::IoError( format!( "{}", e ) ),
                }
            }
        }

        impl From<ParseIntError> for ParseError 
        {
            fn from( e: ParseIntError ) -> Self {
                ParseError {
                    file: None,
                    kind: ParseErrorKind::ParseIntError( format!( "{}", e ) ),
                }
            }
        }

        impl From<ParseBigIntError> for ParseError 
        {
            fn from( e: ParseBigIntError ) -> Self 
            {
                ParseError
                {
                    file: None,
                    kind: ParseErrorKind::ParseIntError( format!( "{}", e ) ),
                }
            }
        }
    } pub use self::parse::{ ParseError };

    pub mod no
    {
        /*!
        Cross-platform interface to the `errno` variable. */
        use ::
        {
            error::{ Error },
            *,
        };
        /*
        */
        pub mod sys
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod unix
            {
                /*!
                Implementation of `errno` functionality for Unix systems. */
                use ::
                {
                    error::no::{ Errno },
                    system::api::{ Result as Res, * },
                    *,
                };
                /*
                */
                fn from_utf8_lossy(input:&[u8] ) -> &str
                {
                    match str::from_utf8(input )
                    {
                        Ok(valid ) => valid,
                        Err(error ) => unsafe { str::from_utf8_unchecked( &input[..error.valid_up_to()]) },
                    }
                }

                pub fn with_description<F, T>(err: Errno, callback: F) -> T where
                F:FnOnce( ::result::Result<&str, Errno> ) -> T,
                {
                    let mut buf = [0u8; 1024];
                    let c_str = unsafe {
                        let rc = strerror_r(err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t );
                        if rc != 0
                        {
                            let fm_err = match rc < 0 {
                                true => errno(),
                                false => Errno( rc ),
                            };
                            if fm_err != Errno( ERANGE) {
                                return callback(Err( fm_err  ) );
                            }
                        }
                        let c_str_len = strlen( buf.as_ptr() as *const _ );
                        &buf[..c_str_len]
                    };
                    callback( Ok( from_utf8_lossy( c_str ) ) )
                }

                pub const STRERROR_NAME: &str = "strerror_r";

                pub fn errno() -> Errno {
                    unsafe { Errno(*errno_location() ) }
                }

                pub fn set_errno(Errno(errno): Errno) {
                    unsafe {
                        *errno_location() = errno;
                    }
                }

                extern "C" {
                    #[cfg_attr(
                        any(
                            target_os = "macos",
                            target_os = "ios",
                            target_os = "tvos",
                            target_os = "watchos",
                            target_os = "visionos",
                            target_os = "freebsd"
                        ),
                        link_name = "__error"
                    )]
                    #[cfg_attr(
                        any(
                            target_os = "openbsd",
                            target_os = "netbsd",
                            target_os = "android",
                            target_os = "espidf",
                            target_os = "vxworks",
                            target_os = "cygwin",
                            target_env = "newlib"
                        ),
                        link_name = "__errno"
                    )]
                    #[cfg_attr(
                        any( target_os = "solaris", target_os = "illumos" ),
                        link_name = "___errno"
                    )]
                    #[cfg_attr( target_os = "haiku", link_name = "_errnop" )]
                    #[cfg_attr(
                        any(
                            target_os = "linux",
                            target_os = "hurd",
                            target_os = "redox",
                            target_os = "dragonfly",
                            target_os = "emscripten",
                        ),
                        link_name = "__errno_location"
                    )]
                    #[cfg_attr( target_os = "aix", link_name = "_Errno" )]
                    #[cfg_attr( target_os = "nto", link_name = "__get_errno_ptr" )]
                    fn errno_location() -> *mut c_int;
                }
            }
            /*
            */
            pub mod windows
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
            }
            #[cfg( unix )] pub use self::unix::{ * };
            #[cfg( windows )] pub use self::windows::{ * };
        }
        /// Wraps a platform-specific error code.
        #[derive( Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash )]
        pub struct Errno( pub i32);

        impl fmt::Debug for Errno
        {
            fn fmt( &self, fmt: &mut fmt::Formatter ) -> fmt::Result
            {
                sys::with_description(*self, |desc|
                {
                    fmt.debug_struct( "Errno" )
                    .field( "code", &self.0)
                    .field( "description", &desc.ok() )
                    .finish()
                })
            }
        }

        impl fmt::Display for Errno
        {
            fn fmt( &self, fmt: &mut fmt::Formatter ) -> fmt::Result
            {
                sys::with_description(*self, |desc| match desc {
                    Ok(desc ) => fmt.write_str(desc ),
                    Err( fm_err ) => write!
                    (
                        fmt,
                        "OS error {} ({} returned error {})",
                        self.0,
                        sys::STRERROR_NAME,
                        fm_err.0
                    ),
                })
            }
        }

        impl From<Errno> for i32 {
            fn from(e: Errno) -> Self {
                e.0
            }
        }
        
        impl Error for Errno {
            // TODO: Remove when MSRV >= 1.27
            #[allow(deprecated )]
            fn description( &self ) -> &str {
                "system error"
            }
        }
        
        impl From<Errno> for io::Error {
            fn from(errno: Errno) -> Self {
                io::Error::from_raw_os_error(errno.0)
            }
        }
        /// Returns the platform-specific value of `errno`.
        pub fn errno() -> Errno {
            sys::errno()
        }
        /// Sets the platform-specific value of `errno`.
        pub fn set_errno(err: Errno) {
            sys::set_errno(err )
        }

    }

}

pub mod expand
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    
    // pub fn expand_home( text:&str ) -> String
    pub fn home( text:&str ) -> String
    {
        let mut s: String = text.to_string();
        let v = vec!
        [
            r"(?P<head> +)~(?P<tail> +)",
            r"(?P<head> +)~(?P<tail>/)",
            r"^(?P<head> *)~(?P<tail>/)",
            r"(?P<head> +)~(?P<tail> *$)",
        ];
        
        for item in &v
        {
            let re;

            if let Ok( x ) = Regex::new(item) { re = x; }
            else { return String::new(); }

            let home = get::user_home();
            let ss = s.clone();
            let to = format!( "$head{}$tail", home );
            let result = re.replace_all( ss.as_str(), to.as_str() );
            s = result.to_string();
        }

        s
    }
    // pub fn expand_glob( tokens: &mut types::Tokens )
    pub fn glob( tokens: &mut types::Tokens )
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !needs_globbing( text )
            {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let item = text.as_str();

            if !item.contains('*') || item.trim().starts_with('\'') || item.trim().starts_with('"')
            { result.push(item.to_string() ); }

            else
            {
                let _basename = path::basename(item);
                let show_hidden = _basename.starts_with( ".*" );

                match ::path::glob( item )
                {
                    Ok( paths ) =>
                    {
                        let mut is_empty = true;
                        
                        for entry in paths
                        {
                            match entry
                            {
                                Ok( path ) =>
                                {
                                    let file_path = path.to_string_lossy();
                                    let _basename = path::basename( &file_path );

                                    if _basename == ".." || _basename == "." { continue; }

                                    if _basename.starts_with('.') && !show_hidden { continue; }

                                    result.push( file_path.to_string() );
                                    is_empty = false;
                                }

                                Err( e ) => { /*log!( "glob error: {:?}", e );*/ }
                            }
                        }

                        if is_empty { result.push(item.to_string() ); }
                    }

                    Err( e ) =>
                    {
                        println!( "glob error: {:?}", e );
                        result.push(item.to_string() );
                        return;
                    }
                }
            }

            buff.push((idx, result ) );
            idx += 1;
        }

        for (i, result ) in buff.iter().rev()
        {
            tokens.remove(*i);
            
            for (j, token ) in result.iter().enumerate()
            {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }
}

pub mod get
{
    /*!
    use ::io::Write;
    Getter Setter Functionality */
    use ::
    {
        fs::{ File },
        path::{ Path, PathBuf },
        system::
        {
            api::{ c_char, size_t },
        },
        *,
    };
    /*
    */
    /// If `ch` preceded by a backslash together form an escape character, then return this char.
    pub fn escaped_character( ch:char ) -> Option<char>
    {
        match ch
        {
            '\\' => Some( '\\' ),
            '"' => Some( '"' ),
            '\'' => Some( '\'' ),
            '$' => Some( '$' ),
            'n' => Some( '\n' ),
            'r' => Some( '\r' ),
            't' => Some( '\t' ),
            _ => None,
        }
    }
    // pub fn get_open_paren( ch:char ) -> Option<char>
    pub fn open_parenthesis( ch:char ) -> Option<char>
    {
        match ch
        {
            ')' => Some( '(' ),
            ']' => Some( '[' ),
            '}' => Some( '{' ),
            _ => None
        }
    }
    // pub fn get_current_dir() -> String
    pub fn current_directory() -> String
    {
        let mut current_dir = PathBuf::new();

        match env::current_dir() 
        {
            Ok( x ) => current_dir = x,
            Err( e ) =>
            {
                use ::io::Write;
                println_stderr!( "env current_dir() failed: {}", e );
            }
        }

        let mut str_current_dir = "";

        match current_dir.to_str() 
        {
            Some( x ) => str_current_dir = x,
            None =>
            {
                println_stderr!( "current_dir to str failed." );
            }
        }

        str_current_dir.to_string()
    }
    // pub fn get_user_name() -> String
    pub fn user_name() -> String
    {
        match env::var( "USER" )
        {
            Ok( x ) => { return x; }
            Err( e ) => { /* log!( ":: env USER error: {}", e ); */ }
        }

        let cmd_result = now::run( "whoami" );
        cmd_result.stdout.trim().to_string()
    }
    // pub fn get_user_home() -> String
    pub fn user_home() -> String
    {
        match env::var( "HOME" )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                use ::io::Write;
                println_stderr!( ":: env HOME error: {}", e );
                String::new()
            }
        }
    }
    // pub fn get_config_dir() -> String
    pub fn config_dir() -> String
    {
        if let Ok( x ) = env::var( "XDG_CONFIG_HOME" ) {
            format!( "{}/cicada", x)
        } else {
            let home = user_home();
            format!( "{}/.config/cicada", home )
        }
    }
    // pub fn get_user_completer_dir() -> String
    pub fn user_completer_dir() -> String
    {
        let dir_config = config_dir();
        format!( "{}/completers", dir_config)
    }
    // pub fn get_hostname() -> String
    pub fn hostname() -> String
    {
        let len = 255;
        let mut buf = Vec::<u8>::with_capacity(len );

        let ptr = buf.as_mut_slice().as_mut_ptr();

        let err = unsafe { hostname( ptr as *mut c_char, len as size_t ) } as i32;

        match err
        {
            0 =>
            {
                let real_len;
                let mut i = 0;
                
                loop
                {
                    let byte = unsafe { *((( ptr as u64) + (i as u64 ) ) as *const u8) };
                    if byte == 0 {
                        real_len = i;
                        break;
                    }

                    i += 1;
                }
                
                unsafe { buf.set_len( real_len ) }
                String::from_utf8_lossy( buf.as_slice() ).into_owned()
            }
            _ => String::from( "unknown" ),
        }
    }
    // pub fn get_fd_from_file( file_name:&str ) -> i32
    pub fn fd_from_file( file_name:&str ) -> i32
    {
        let path = Path::new( file_name );
        let display = path.display();
        let file = match File::open( path ) {
            Err(why) => 
            {
                use ::io::Write;
                println_stderr!( ":: {}: {}", display, why);
                return -1;
            }
            Ok( file ) => file,
        };
        file.into_raw_fd()
    }
    // pub fn get_prompt_len( prompt:&str ) -> i32
    pub fn prompt_len( prompt:&str ) -> i32
    {
        let mut count = 0;
        let mut met_x01 = false;
        for c in prompt.chars() {
            if c == '\x01' {
                met_x01 = true;
                continue;
            } else if c == '\x02' {
                met_x01 = false;
                continue;
            }
            if !met_x01 {
                count += 1;
            }
        }
        count
    }
}

pub mod f32
{
    pub use std::f32::{ * };
}

pub mod f64
{
    pub use std::f64::{ * };
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    /*!
    Module containing functions for formatting output of objects. */
    pub use std::fmt::{ * };    
    use ::
    {
        arrays::{ Arr },
        num::
        {
            big::{ BigInt },
            rational::{ BigRational },
            traits::{ One },
        },
        objects::{ Obj },
        tuples::{ Tup },
        values::{ Value },
        *,
    };
    /*
    use crate::INDENT_STEP;
    */
   
    fn indent( amount: usize ) -> String 
    {
        " ".repeat( amount )
    }

    fn get_char_map( ch:char ) -> Option<&'static str> 
    {
        match ch
        {
            '\\' => Some( "\\\\" ),
            '\"' => Some( "\\\"" ),
            '\'' => Some( "\\\'" ),
            '$' => Some( "\\$" ),
            '\n' => Some( "\\n" ),
            '\r' => Some( "\\r" ),
            '\t' => Some( "\\t" ),
            _ => None,
        }
    }

    fn replace_all( s:&str ) -> String 
    {
        let mut string = String::with_capacity( s.len() );

        for ch in s.chars() 
        {
            if let Some( s ) = get_char_map( ch  ) { string.push_str( s  ); }            
            else { string.push( ch  ); }
        }

        string
    }
    /// Trait for formatting a .over representation of an object.
    pub trait Format 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String;
    }

    impl Format for BigRational 
    {
        fn format( &self, _full: bool, _indent_amt: usize ) -> String {
            let frac_fmt = format!( "{}", *self );

            if *self.denom() == BigInt::one() {
                format!( "{}.0", frac_fmt )
            } else {
                frac_fmt
            }
        }
    }

    impl Format for char 
    {
        fn format( &self, _full: bool, _indent_amt: usize ) -> String {
            if let Some( s ) = get_char_map( *self ) {
                format!( "\'{}\'", s )
            } else {
                format!( "\'{}\'", *self )
            }
        }
    }

    impl Format for String 
    {
        fn format( &self, _full: bool, _indent_amt: usize ) -> String {
            format!( "\"{}\"", replace_all( self ) )
        }
    }

    impl Format for Value 
    {
        fn format( &self, _full: bool, indent_amt: usize ) -> String
        {
            match *self
            {
                Value::Null => String::from( "null" ),

                Value::Bool( ref inner ) =>
                {
                    if *inner {
                        String::from( "true" )
                    } else {
                        String::from( "false" )
                    }
                }

                Value::Int( ref inner ) => format!( "{}", inner ),
                Value::Integer( ref inner ) => format!( "{}", inner ),
                Value::Frac( ref inner ) => inner.format( true, indent_amt ),
                Value::Char( ref inner ) => inner.format( true, indent_amt ),
                Value::Str( ref inner ) => inner.format( true, indent_amt ),
                Value::Strand( ref inner ) => inner.format( true, indent_amt ),
                Value::Arr( ref inner ) => inner.format( true, indent_amt ),
                Value::Tup( ref inner ) => inner.format( true, indent_amt ),
                Value::Obj( ref inner ) => inner.format( true, indent_amt ),
            }
        }
    }

    impl Format for Arr 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String {
            match self.len() {
                0 => {
                    if full {
                        String::from( "[]" )
                    } else {
                        String::new()
                    }
                }
                1 => {
                    let f = self.get( 0 ).unwrap().format( true, indent_amt );
                    if full {
                        format!( "[{}]", f )
                    } else {
                        f
                    }
                }
                _ => {
                    let mut s = if full {
                        String::from( "[\n" )
                    } else {
                        String::new()
                    };

                    self.with_each( |value| {
                        s.push_str( &format!( 
                            "{}{}\n",
                            indent( indent_amt ),
                            value.format( true, indent_amt + INDENT_STEP )
                        ) )
                    } );

                    if full {
                        let actual_indent_amt = if indent_amt == 0 {
                            0
                        } else {
                            indent_amt - INDENT_STEP
                        };
                        s.push_str( &format!( "{}]", indent( actual_indent_amt ) ) );
                    }
                    s
                }
            }
        }
    }

    impl Format for Tup 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String {
            match self.len() {
                0 => {
                    if full {
                        String::from( "()" )
                    } else {
                        String::new()
                    }
                }
                1 => {
                    let f = self.get( 0 ).unwrap().format( true, indent_amt );
                    if full {
                        format!( "( {} )", f )
                    } else {
                        f
                    }
                }
                _ => {
                    let mut s = if full {
                        String::from( "( \n" )
                    } else {
                        String::new()
                    };

                    self.with_each( |value| {
                        s.push_str( &format!( 
                            "{}{}\n",
                            indent( indent_amt ),
                            value.format( true, indent_amt + INDENT_STEP )
                        ) )
                    } );

                    if full {
                        s.push_str( &format!( "{} )", indent( indent_amt - INDENT_STEP ) ) );
                    }
                    s
                }
            }
        }
    }

    impl Format for Obj 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String {
            if self.is_empty() && !self.has_parent() {
                if full {
                    String::from( "{}" )
                } else {
                    String::new()
                }
            } else {
                let mut s = if full {
                    String::from( "{\n" )
                } else {
                    String::new()
                };

                if let Some( parent ) = self.get_parent() {
                    s.push_str( &format!( 
                        "{}^: {}\n",
                        indent( indent_amt ),
                        parent.format( true, indent_amt + INDENT_STEP )
                    ) );
                }
                self.with_each( |field, value| {
                    s.push_str( &format!( 
                        "{}{}: {}\n",
                        indent( indent_amt ),
                        field,
                        value.format( true, indent_amt + INDENT_STEP )
                    ) );
                } );

                if full {
                    s.push_str( &format!( "{}}}", indent( indent_amt - INDENT_STEP ) ) );
                }
                s
            }
        }
    }
}

pub mod fs
{
    pub use std::fs::{ * };
}

pub mod has
{
    /*!
    */
    use ::
    {
        system::api::
        {
            tcgetpgrp, getpgid
        },
        *,
    };
    /*
    */
    // fn proc_has_terminal() -> bool
    pub fn terminal() -> bool
    {
        unsafe
        {
            let tgid = tcgetpgrp( 0 );
            let pgid = getpgid( 0 );
            tgid == pgid
        }
    }
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod highlights
{
    /*!
    */
    use ::
    {
        collections::{ HashSet },
        ops::{ Range },
        os::{ unix::fs::PermissionsExt },
        sync::{ Arc, Mutex },
        *,
    };
    /*
    use crate::parsers::parser_line;
    */
    /// Style reset sequence
    pub const RESET_STYLE: &str = "\x1b[0m";
    pub const GREEN: &str = "\x1b[0;32m";

    lazy_static!
    {
        pub static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new() );
        pub static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new() );
    }
    /// Provides style information for a line of text.
    #[derive( Clone )]
    pub struct CicadaHighlighter;
    /// Represents a style to be applied to a text range.
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum Style 
    {
        /// A style using raw ANSI color codes
        AnsiColor(String),
        /// The default terminal style
        Default,
    }
    /// A trait for providing style information for a line of text.
    pub trait Highlighter
    {
        /// Takes the current line buffer and returns a list of styled ranges.
        fn highlight( &self, line:&str ) -> Vec<(Range<usize>, Style )>;
    }
    /// Initialize the available commands cache by scanning PATH directories
    pub fn initialize()
    {
        let commands = scan_available_commands();
        if let Ok( mut cache ) = AVAILABLE_COMMANDS.lock() { *cache = commands; }
    }
    /// Update aliases in the highlighter's cache
    pub fn update( sh: &shell::Shell) 
    {
        if let Ok( mut aliases ) = ALIASES.lock()
        {
            aliases.clear();

            for alias_name in sh.aliases.keys()
            {
                aliases.insert( alias_name.clone() );
            }
        }
    }

    pub fn scan() -> HashSet<String> 
    {
        let mut commands = HashSet::new();

        if let Ok( path_var ) = env::var( "PATH" )
        {
            for dir_path in env::split_paths( &path_var )
            {
                if !dir_path.is_dir() { continue; }

                if let Ok(entries ) = fs::read_dir(dir_path ) 
                {
                    for entry in entries.filter_map(Result::ok) 
                    {
                        if let Ok( file_type ) = entry.file_type() 
                        {
                            if file_type.is_file() || file_type.is_symlink() 
                            {
                                if let Ok(metadata ) = entry.metadata() 
                                {
                                    if metadata.permissions().mode() & 0o111 != 0 
                                    {
                                        if let Some( name ) = entry.file_name().to_str()
                                        { commands.insert( name.to_string() ); }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        commands
    }

    fn find( line: &str, start_byte: usize, token: &(String, String) ) -> Option<Range<usize>> 
    {
        let ( sep, word ) = token;
        let mut search_area = &line[start_byte..];

        let token_start_byte = if let Some( non_ws_offset ) = search_area.find(|c:char| !c.is_whitespace() )
        {
            start_byte + search_area
            .char_indices()
            .nth( non_ws_offset )
            .map_or(0, |(idx, _ )| idx)
        }
        else { return None; };

        search_area = &line[token_start_byte..];
        let mut estimated_len = 0;
        let mut current_search_offset = 0;
        
        if !sep.is_empty() && search_area.starts_with( sep)
        {
            estimated_len += sep.len();
            current_search_offset += sep.len();
        }
        
        if search_area[current_search_offset..].starts_with(word )
        {
            estimated_len += word.len();
            current_search_offset += word.len();
            
            if !sep.is_empty() && search_area[current_search_offset..].starts_with( sep) { estimated_len += sep.len(); }

            Some( token_start_byte..( token_start_byte + estimated_len ) )
        }
        
        else if word.is_empty()
        && !sep.is_empty()
        && search_area.starts_with( sep)
        && search_area[sep.len()..].starts_with( sep)
        {
            estimated_len += sep.len() * 2;
            Some( token_start_byte..( token_start_byte + estimated_len ) )
        }

        else
        {
            if search_area.starts_with(word ) { Some( token_start_byte..( token_start_byte + word.len() ) ) }
            else { None }
        }
    }

    impl Highlighter for CicadaHighlighter 
    {
        fn highlight( &self, line:&str ) -> Vec<(Range<usize>, Style )> 
        {
            let mut styles = Vec::new();
            if line.is_empty() { return styles; }

            let line_info = parser_line::parse_line(line );
            
            if line_info.tokens.is_empty()
            {
                styles.push((0..line.len(), Style::Default ) );
                return styles;
            }

            let mut current_byte_idx = 0;
            let mut is_start_of_segment = true;

            for token in &line_info.tokens
            {
                match find_token_range_heuristic(line, current_byte_idx, token )
                {
                    Some( token_range ) =>
                    {
                        if token_range.start > current_byte_idx {
                            styles.push(( current_byte_idx..token_range.start, Style::Default ) );
                        }

                        let (_sep, word ) = token;
                        let mut current_token_style = Style::Default;

                        if is_start_of_segment && !word.is_empty() {
                            if is_command(word ) {
                                current_token_style = Style::AnsiColor(GREEN.to_string() );
                            }
                            is_start_of_segment = false;
                        }

                        styles.push(( token_range.clone(), current_token_style  ) );
                        
                        if ["|", "&&", "||", ";"].contains( &word.as_str() ) {
                            is_start_of_segment = true;
                        }

                        current_byte_idx = token_range.end;
                    }

                    None => 
                    {
                        if current_byte_idx < line.len() 
                        { styles.push(( current_byte_idx..line.len(), Style::Default ) ); }

                        current_byte_idx = line.len();
                        break;
                    }
                }
            }
            
            if current_byte_idx < line.len() { styles.push(( current_byte_idx..line.len(), Style::Default ) ); }

            styles
        }
    }

    pub fn create() -> Arc<CicadaHighlighter> { Arc::new( CicadaHighlighter ) }
}

pub mod i8
{
    pub use std::i8::{ * };
}

pub mod i16
{
    pub use std::i16::{ * };
}

pub mod i32
{
    pub use std::i32::{ * };
}

pub mod i64
{
    pub use std::i64::{ * };
}

pub mod is
{
    /*!
    Identity Signature*/
    use ::
    {
        *,
    };
    /*
    */
    /// Returns true if this character signifies the legal end of a value.
    pub fn value_end_char( ch:char ) -> bool 
    {
        whitespace( ch ) || end_delimiter( ch ) || operator( ch )
    }
    /// Returns true if the character is either whitespace or '#' ( start of a comment ).   
    pub fn whitespace( ch:char ) -> bool 
    {
        ch.is_whitespace() || ch == '#'
    }
   
    pub fn end_delimiter( ch:char ) -> bool 
    {
        match ch {
            ')' | ']' | '}' | '>' => true,
            _ => false,
        }
    }
   
    pub fn numeric_char( ch:char ) -> bool 
    {
        match ch {
            _ch if digit( _ch ) => true,
            '.' | ',' => true,
            _ => false,
        }
    }
   
    pub fn priority_operator( ch:char ) -> bool 
    {
        match ch {
            '*' | '/' | '%' => true,
            _ => false,
        }
    }
   
    pub fn operator( ch:char ) -> bool 
    {
        match ch {
            '+' | '-' | '*' | '/' | '%' => true,
            _ => false,
        }
    }
    /// Returns true if `ch` is an ASCII decimal digit.
    //pub fn is_digit( ch:char ) -> bool {
    pub fn digit( ch:char ) -> bool 
    {
        match ch {
            '0'..='9' => true,
            _ => false,
        }
    }
   
    pub fn reserved( field:&str ) -> bool 
    {
        match field {
            "@" | "null" | "true" | "false" | "Obj" | "Str" | "Arr" | "Tup" => true,
            _ => false,
        }
    }
    /// Whether the character has the Unicode property XID\_Start.
    /*
    pub fn is_xid_start( ... ) -> bool*/
    pub fn xid_start( ch:char ) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_START.0[ch as usize]; }
        let chunk = * ::ascii::TRIE_START.0.get( ch as usize / 8 / ::ascii::CHUNK ).unwrap_or( &0 );
        let offset = chunk as usize *  ::ascii::CHUNK / 2 + ch as usize / 8 %  ::ascii::CHUNK;
        unsafe {  ::ascii::LEAF.0.get_unchecked( offset ) }.wrapping_shr( ch as u32 % 8 ) & 1 != 0
    }
    /// Whether the character has the Unicode property XID\_Continue.
    /*
    pub fn is_xid_continue( ch:char ) -> bool */
    pub fn xid_continue( ch:char ) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_CONTINUE.0[ch as usize]; }
        let chunk = *::ascii::TRIE_CONTINUE.0.get( ch as usize / 8 / ::ascii::CHUNK ).unwrap_or( &0 );
        let offset = chunk as usize * ::ascii::CHUNK / 2 + ch as usize / 8 % ::ascii::CHUNK;
        unsafe { ::ascii::LEAF.0.get_unchecked( offset ) }.wrapping_shr( ch as u32 % 8 ) & 1 != 0
    }
    /*
    pub fn is_ident_start( c:char ) -> bool*/
    pub fn ident_start( c:char ) -> bool
    {
        c == '_' || xid_start( c )
    }
    /*
    pub fn is_ident_continue( c:char ) -> bool */
    pub fn ident_continue( c:char ) -> bool
    {
        xid_continue( c )
    }
    /// Returns whether the given character is a combining mark.
    // #[inline] pub fn is_combining_mark( ch:char ) -> bool
    #[inline] pub fn combining_mark( ch:char ) -> bool
    {
        use unicode_normalization::char::is_combining_mark;
        is_combining_mark( ch )
    }
    /// Returns whether the given character is a control character.
    // #[inline] pub fn is_ctrl( ch:char ) -> bool
    #[inline] pub fn control( ch:char ) -> bool
    {
        let ch = ch as u32;
        ch & ( 0x1f as u32 ) == ch
    }
    // pub fn is_visible( ch:char ) -> bool
    pub fn visible( ch:char ) -> bool
    {
        match ch
        {
            '\t' | '\r' | '\n' => true,
            _ => char::width( ch ).unwrap_or( 0 ) != 0
        }
    }    
    // fn is_xterm( name:&str ) -> bool
    pub fn xterm( name:&str ) -> bool
    {
        // Includes such terminal names as "xterm-256color"
        name == "xterm" || name.starts_with( "xterm-" )
    }
    // pub fn is_wide( ch:char ) -> bool
    pub fn wide( ch:char ) -> bool
    {
        char::width( ch ) == Some( 2 )
    }    
    // pub fn is_env(line:&str ) -> bool
    pub fn env(line:&str ) -> bool
    {
        regex::contains(line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$" )
    }
    // pub fn is_signal_handler_enabled() -> bool
    pub fn signal_handler_enabled() -> bool
    {
        env::var( "CICADA_ENABLE_SIG_HANDLER" ).is_ok_and(|x| x == "1" )
    }
    // pub fn is_arithmetic(line:&str ) -> bool
    pub fn arithmetic(line:&str ) -> bool
    {
        if !regex::contains(line, r"[0-9]+" ) { return false; }
        if !regex::contains(line, r"\+|\-|\*|/|\^" ) { return false; }
        regex::contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$" )
    }
    // pub fn is_builtin( s:&str ) -> bool
    pub fn builtin( s:&str ) -> bool
    {
        let builtins = 
        [
            "alias", "bg", "cd", "cinfo", "exec", "exit", "export", "fg", "history", "jobs", "read", "source", 
            "ulimit", "unalias", "vox", "minfd", "set", "unset", "unpath",
        ];

        builtins.contains( &s )
    }
    // pub fn is_shell_altering_command(line:&str ) -> bool
    pub fn shell_altering_command(line:&str ) -> bool
    {
        let line = line.trim();
        if regex::contains( line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$" ) { return true; }

        line.starts_with( "alias " )
        || line.starts_with( "export " )
        || line.starts_with( "unalias " )
        || line.starts_with( "unset " )
        || line.starts_with( "source " )
    }
    // pub fn is_login( args:&[String] ) -> bool
    pub fn login( args:&[String] ) -> bool
    {
        if !args.is_empty() && args[0].starts_with( "-" ) { return true; }

        if args.len() > 1 && ( args[1] == "--login" || args[1] == "-l" ) { return true; }

        if let Ok( term_program) = ::env::var( "TERM_PROGRAM" )
        {
            if term_program == "vscode" { return true; }
        }

        false
    }
    // pub fn is_script( args:&[String] ) -> bool 
    pub fn script( args:&[String] ) -> bool { args.len() > 1 && !args[1].starts_with( "-" ) }
    // pub fn is_command_string( args:&[String] ) -> bool
    pub fn command_string( args:&[String] ) -> bool { args.len() > 1 && args[1] == "-c" }
    // pub fn is_non_tty() -> bool 
    pub fn non_tty() -> bool { unsafe { ::system::api::isatty( 0 ) == 0 } }

    // pub fn is_command(word:&str ) -> bool
    pub fn command(word:&str ) -> bool
    {
        if builtin(word ) { return true; }

        if let Ok( aliases ) = ::highlights::ALIASES.lock()
        {
            if aliases.contains(word ) { return true; }
        }

        if let Ok( commands ) = ::highlights::AVAILABLE_COMMANDS.lock()
        {
            if commands.contains(word ) { return true; }
        }

        false
    }
    // pub fn is_prefix_char( c:char ) -> bool
    pub fn prefix_char( c:char ) -> bool { c == '[' || c == '{' }
    //pub fn is_suffix_char( c:char ) -> bool
    pub fn suffix_char( c:char ) -> bool { c == ']' || c == '}' }
    // pub fn is_prompt_item_char( c:char, token:&str ) -> bool
    pub fn prompt_item_char( c:char, token:&str ) -> bool
    {
        let s = c.to_string();
        if token.is_empty() { regex::contains( &s, r#"^[a-zA-Z_]$"#) }
        else { regex::contains( &s, r#"^[a-zA-Z0-9_]$"#) }
    }

    pub fn tty( fd:system::api::c_int ) -> bool
    {
        system::api::isatty( fd )
    }
    // pub fn is_meta_character(c: char) -> bool
    /// Returns true if the given character has significance in a regex.
    pub fn meta_character(c: char) -> bool
    {
        match c
        {
            '\\'|'.'|'+'|'*'|'?'|'('|')'|'|'|'['|']'|'{'|'}'|'^'|'$'|'#'|'&'|'-'|'~' => true,
            _ => false,
        }
    }
    // pub fn is_escapeable_character(c: char) -> bool
    /// Returns true if the given character can be escaped in a regex.
    pub fn escapeable_character(c: char) -> bool
    {
        if meta_character(c) { return true; }
        
        if !c.is_ascii() { return false; }

        match c
        {
            '0'..='9' | 'A'..='Z' | 'a'..='z' => false,
            '<' | '>' => false,
            _ => true,
        }
    }
    // pub fn is_word_character(c: char) -> bool
    /// Returns true if and only if the given character is a Unicode word character.
    pub fn word_character(c: char) -> bool
    {
        try_word_character(c).expect("unicode-perl feature must be enabled")
    }
    /// Returns true if and only if the given character is a Unicode word character.
    pub fn try_word_character( c: char ) -> Result<bool, UnicodeWordError> { unicode::is_word_character(c) }
    // pub fn is_word_byte(c: u8) -> bool
    /// Returns true if and only if the given character is an ASCII word character.
    pub fn word_byte(c: u8) -> bool
    {
        match c
        {
            b'_' | b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' => true,
            _ => false,
        }
    }
}

pub mod isize
{
    pub use std::isize::{ * };
}

pub mod i128
{
    pub use std::i128::{ * };
}

pub mod io
{
    pub use std::io::{ * };
}

pub mod iter
{
    pub use std::iter::{ * };
    
    pub fn drop_while<I, T, F>( iter:&mut I, mut f: F ) where
    I: Iterator<Item=T> + Clone, F: FnMut( T ) -> bool
    {
        loop {
            let mut clone = iter.clone();

            match clone.next() {
                None => break,
                Some( t ) => {
                    if f( t ) {
                        *iter = clone;
                    } else {
                        break;
                    }
                }
            }
        }
    }
}

pub mod marker
{
    pub use std::marker::{ * };
    use ::
    {
        rc::{ Rc },
        panic::{ RefUnwindSafe, UnwindSafe },
        *,
    };
    /*
    */
    pub const MARKER: ProcMacroAutoTraits = ProcMacroAutoTraits( PhantomData );
    /// Zero sized marker with the correct set of autotrait impls we want all proc macro types to have.
    #[derive( Copy, Clone, PartialEq, Eq )]
    pub struct ProcMacroAutoTraits( pub PhantomData<Rc<()>>  );
    impl UnwindSafe for ProcMacroAutoTraits {}
    impl RefUnwindSafe for ProcMacroAutoTraits {}
}

pub mod num
{
    pub use std::num::{ * };
    use ::
    {
        *,
    };
    /*
    */
    pub mod traits
    {
        //! Numeric traits for generic mathematics
        use ::
        {
            num::{ Wrapping },
            ops::{ Add, Div, Mul, Rem, Sub, AddAssign, DivAssign, MulAssign, RemAssign, SubAssign },
            *,
        };
        /*
        */
        pub mod bounds
        {
            use ::
            {
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Wrapping,
                },
                *,
            };
            /*
            */
            /// Numbers which have upper and lower bounds
            pub trait Bounded
            {
               
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
            /// Numbers which have lower bounds
            pub trait LowerBounded
            {
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
            }
           
            impl<T: Bounded> LowerBounded for T
            {
                fn min_value() -> T {
                    Bounded::min_value()
                }
            }
            /// Numbers which have upper bounds
            pub trait UpperBounded
            {
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
           
            impl<T: Bounded> UpperBounded for T
            {
                fn max_value() -> T {
                    Bounded::max_value()
                }
            }
            macro_rules! bounded_impl
            {
                ( $t:ty, $min:expr, $max:expr ) =>
                {
                    impl Bounded for $t {
                        #[inline]
                        fn min_value() -> $t {
                            $min
                        }
                        #[inline]
                        fn max_value() -> $t {
                            $max
                        }
                    }
                };
            }
            bounded_impl!( usize, usize::MIN, usize::MAX );
            bounded_impl!( u8, u8::MIN, u8::MAX );
            bounded_impl!( u16, u16::MIN, u16::MAX );
            bounded_impl!( u32, u32::MIN, u32::MAX );
            bounded_impl!( u64, u64::MIN, u64::MAX );
            bounded_impl!( u128, u128::MIN, u128::MAX );

            bounded_impl!( isize, isize::MIN, isize::MAX );
            bounded_impl!( i8, i8::MIN, i8::MAX );
            bounded_impl!( i16, i16::MIN, i16::MAX );
            bounded_impl!( i32, i32::MIN, i32::MAX );
            bounded_impl!( i64, i64::MIN, i64::MAX );
            bounded_impl!( i128, i128::MIN, i128::MAX );

            macro_rules! bounded_impl_nonzero_const 
            {
                ( $t:ty, $v:expr, $i:ident ) => {
                    const $i: $t = match <$t>::new( $v ) {
                        Some( nz ) => nz,
                        None => panic!( "bad nonzero bound!" ),
                    };
                };
            }
            macro_rules! bounded_impl_nonzero 
            {
                ( $t:ty, $min:expr, $max:expr ) => {
                    impl Bounded for $t {
                        #[inline]
                        fn min_value() -> $t {
                           
                            bounded_impl_nonzero_const!( $t, $min, MIN );
                            MIN
                        }
                        #[inline]
                        fn max_value() -> $t {
                           
                            bounded_impl_nonzero_const!( $t, $max, MAX );
                            MAX
                        }
                    }
                };
            }
            bounded_impl_nonzero!( NonZeroUsize, 1, usize::MAX );
            bounded_impl_nonzero!( NonZeroU8, 1, u8::MAX );
            bounded_impl_nonzero!( NonZeroU16, 1, u16::MAX );
            bounded_impl_nonzero!( NonZeroU32, 1, u32::MAX );
            bounded_impl_nonzero!( NonZeroU64, 1, u64::MAX );
            bounded_impl_nonzero!( NonZeroU128, 1, u128::MAX );

            bounded_impl_nonzero!( NonZeroIsize, isize::MIN, isize::MAX );
            bounded_impl_nonzero!( NonZeroI8, i8::MIN, i8::MAX );
            bounded_impl_nonzero!( NonZeroI16, i16::MIN, i16::MAX );
            bounded_impl_nonzero!( NonZeroI32, i32::MIN, i32::MAX );
            bounded_impl_nonzero!( NonZeroI64, i64::MIN, i64::MAX );
            bounded_impl_nonzero!( NonZeroI128, i128::MIN, i128::MAX );

            impl<T: Bounded> Bounded for Wrapping<T> 
            {
                fn min_value() -> Self {
                    Wrapping( T::min_value() )
                }
                fn max_value() -> Self {
                    Wrapping( T::max_value() )
                }
            }
            bounded_impl!( f32, f32::MIN, f32::MAX );

            macro_rules! for_each_tuple_ 
            {
                ( $m:ident !! ) => ( 
                    $m! { }
                 );
                ( $m:ident !! $h:ident, $( $t:ident, )* ) => ( 
                    $m! { $h $( $t )* }
                    for_each_tuple_! { $m !! $( $t, )* }
                 );
            }
            macro_rules! for_each_tuple 
            {
                ( $m:ident ) => {
                    for_each_tuple_! { $m !! A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, }
                };
            }
            macro_rules! bounded_tuple 
            {
                ( $( $name:ident )* ) => ( 
                    impl<$( $name: Bounded, )*> Bounded for ( $( $name, )* ) {
                        #[inline]
                        fn min_value() -> Self {
                            ( $( $name::min_value(), )* )
                        }
                        #[inline]
                        fn max_value() -> Self {
                            ( $( $name::max_value(), )* )
                        }
                    }
                 );
            }
            for_each_tuple!( bounded_tuple );
            bounded_impl!( f64, f64::MIN, f64::MAX );
        } pub use self::bounds::Bounded;

        pub mod cast
        {
            use ::
            {
                mem::{ size_of },
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Wrapping,
                },
                *,
            };
            /*
            */
            /// A generic trait for converting a value to a number.
            pub trait ToPrimitive
            {
                /// Converts the value of `self` to an `isize`.
                #[inline] fn to_isize( &self ) -> Option<isize> { self.to_i64().as_ref().and_then( ToPrimitive::to_isize ) }
                /// Converts the value of `self` to an `i8`.
                #[inline] fn to_i8( &self ) -> Option<i8> { self.to_i64().as_ref().and_then( ToPrimitive::to_i8 ) }
                /// Converts the value of `self` to an `i16`.
                #[inline] fn to_i16( &self ) -> Option<i16> { self.to_i64().as_ref().and_then( ToPrimitive::to_i16 ) }
                /// Converts the value of `self` to an `i32`.
                #[inline] fn to_i32( &self ) -> Option<i32> { self.to_i64().as_ref().and_then( ToPrimitive::to_i32 ) }
                /// Converts the value of `self` to an `i64`.
                fn to_i64( &self ) -> Option<i64>;
                /// Converts the value of `self` to an `i128`.
                #[inline] fn to_i128( &self ) -> Option<i128> { self.to_i64().map( From::from ) }
                /// Converts the value of `self` to a `usize`.
                #[inline] fn to_usize( &self ) -> Option<usize> { self.to_u64().as_ref().and_then( ToPrimitive::to_usize ) }
                /// Converts the value of `self` to a `u8`.
                #[inline] fn to_u8( &self ) -> Option<u8> { self.to_u64().as_ref().and_then( ToPrimitive::to_u8 ) }
                /// Converts the value of `self` to a `u16`.
                #[inline] fn to_u16( &self ) -> Option<u16> { self.to_u64().as_ref().and_then( ToPrimitive::to_u16 ) }
                /// Converts the value of `self` to a `u32`.
                #[inline] fn to_u32( &self ) -> Option<u32> { self.to_u64().as_ref().and_then( ToPrimitive::to_u32 ) }
                /// Converts the value of `self` to a `u64`.
                fn to_u64( &self ) -> Option<u64>;
                /// Converts the value of `self` to a `u128`.
                #[inline] fn to_u128( &self ) -> Option<u128> { self.to_u64().map( From::from ) }
                /// Converts the value of `self` to an `f32`.
                #[inline] fn to_f32( &self ) -> Option<f32> { self.to_f64().as_ref().and_then( ToPrimitive::to_f32 ) }
                /// Converts the value of `self` to an `f64`. Overflows may map to positive
                /// or negative inifinity, otherwise `None` is returned if the value cannot
                /// be represented by an `f64`.
                /// override this method if they can represent a greater range.
                #[inline] fn to_f64( &self ) -> Option<f64> {
                    match self.to_i64() {
                        Some( i ) => i.to_f64(),
                        None => self.to_u64().as_ref().and_then( ToPrimitive::to_f64 ),
                    }
                }
            }
            macro_rules! impl_to_primitive_int_to_int 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> {
                        let min = $DstT::MIN as $SrcT;
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || ( min <= *self && *self <= max ) {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_int_to_uint 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if 0 <= *self && ( size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max ) {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_int 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_int_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }
                        impl_to_primitive_int_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }
                        #[inline]
                        fn to_f32( &self ) -> Option<f32> {
                            Some( *self as f32 )
                        }
                        #[inline]
                        fn to_f64( &self ) -> Option<f64> {
                            Some( *self as f64 )
                        }
                    }
                };
            }
            impl_to_primitive_int!( isize );
            impl_to_primitive_int!( i8 );
            impl_to_primitive_int!( i16 );
            impl_to_primitive_int!( i32 );
            impl_to_primitive_int!( i64 );
            impl_to_primitive_int!( i128 );

            macro_rules! impl_to_primitive_uint_to_int 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_uint_to_uint 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_uint 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_uint_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }
                        impl_to_primitive_uint_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }
                        #[inline]
                        fn to_f32( &self ) -> Option<f32> {
                            Some( *self as f32 )
                        }
                        #[inline]
                        fn to_f64( &self ) -> Option<f64> {
                            Some( *self as f64 )
                        }
                    }
                };
            }
            impl_to_primitive_uint!( usize );
            impl_to_primitive_uint!( u8 );
            impl_to_primitive_uint!( u16 );
            impl_to_primitive_uint!( u32 );
            impl_to_primitive_uint!( u64 );
            impl_to_primitive_uint!( u128 );

            macro_rules! impl_to_primitive_nonzero_to_method 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> {
                        self.get().$method()
                    }
                )*}
            }
            macro_rules! impl_to_primitive_nonzero 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_nonzero_to_method! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;

                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;

                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }
            impl_to_primitive_nonzero!( NonZeroUsize );
            impl_to_primitive_nonzero!( NonZeroU8 );
            impl_to_primitive_nonzero!( NonZeroU16 );
            impl_to_primitive_nonzero!( NonZeroU32 );
            impl_to_primitive_nonzero!( NonZeroU64 );
            impl_to_primitive_nonzero!( NonZeroU128 );

            impl_to_primitive_nonzero!( NonZeroIsize );
            impl_to_primitive_nonzero!( NonZeroI8 );
            impl_to_primitive_nonzero!( NonZeroI16 );
            impl_to_primitive_nonzero!( NonZeroI32 );
            impl_to_primitive_nonzero!( NonZeroI64 );
            impl_to_primitive_nonzero!( NonZeroI128 );

            macro_rules! impl_to_primitive_float_to_float 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> {
                       
                       
                        Some( *self as $DstT )
                    }
                )*}
            }
            macro_rules! float_to_int_unchecked 
            {
               
               
                ( $float:expr => $int:ty ) => {
                    unsafe { $float.to_int_unchecked::<$int>() }
                };
            }
            macro_rules! impl_to_primitive_float_to_signed_int 
            {
                ( $f:ident : $( fn $method:ident -> $i:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$i> {
                       
                       
                        if size_of::<$f>() > size_of::<$i>() {
                           
                            const MIN_M1: $f = $i::MIN as $f - 1.0;
                            const MAX_P1: $f = $i::MAX as $f + 1.0;
                            if *self > MIN_M1 && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $i ) );
                            }
                        } else {
                           
                           
                            const MIN: $f = $i::MIN as $f;
                           
                           
                            const MAX_P1: $f = $i::MAX as $f;
                            if *self >= MIN && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $i ) );
                            }
                        }
                        None
                    }
                )*}
            }
            macro_rules! impl_to_primitive_float_to_unsigned_int 
            {
                ( $f:ident : $( fn $method:ident -> $u:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$u> {
                       
                       
                        if size_of::<$f>() > size_of::<$u>() {
                           
                            const MAX_P1: $f = $u::MAX as $f + 1.0;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $u ) );
                            }
                        } else {
                           
                           
                           
                            const MAX_P1: $f = $u::MAX as $f;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $u ) );
                            }
                        }
                        None
                    }
                )*}
            }
            macro_rules! impl_to_primitive_float 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_float_to_signed_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }
                        impl_to_primitive_float_to_unsigned_int! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }
                        impl_to_primitive_float_to_float! { $T:
                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }
            impl_to_primitive_float!( f32 );
            impl_to_primitive_float!( f64 );
            /// A generic trait for converting a number to a value.
            pub trait FromPrimitive: Sized
            {
                /// Converts an `isize` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_isize( n: isize ) -> Option<Self> {
                    n.to_i64().and_then( FromPrimitive::from_i64 )
                }
                /// Converts an `i8` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_i8( n: i8 ) -> Option<Self> {
                    FromPrimitive::from_i64( From::from( n ) )
                }
                /// Converts an `i16` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_i16( n: i16 ) -> Option<Self> {
                    FromPrimitive::from_i64( From::from( n ) )
                }
                /// Converts an `i32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_i32( n: i32 ) -> Option<Self> {
                    FromPrimitive::from_i64( From::from( n ) )
                }
                /// Converts an `i64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                fn from_i64( n: i64 ) -> Option<Self>;
                /// Converts an `i128` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_i128( n: i128 ) -> Option<Self> {
                    n.to_i64().and_then( FromPrimitive::from_i64 )
                }
                /// Converts a `usize` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_usize( n: usize ) -> Option<Self> {
                    n.to_u64().and_then( FromPrimitive::from_u64 )
                }
                /// Converts an `u8` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_u8( n: u8 ) -> Option<Self> {
                    FromPrimitive::from_u64( From::from( n ) )
                }
                /// Converts an `u16` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_u16( n: u16 ) -> Option<Self> {
                    FromPrimitive::from_u64( From::from( n ) )
                }
                /// Converts an `u32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_u32( n: u32 ) -> Option<Self> {
                    FromPrimitive::from_u64( From::from( n ) )
                }
                /// Converts an `u64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                fn from_u64( n: u64 ) -> Option<Self>;
                /// Converts an `u128` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_u128( n: u128 ) -> Option<Self> {
                    n.to_u64().and_then( FromPrimitive::from_u64 )
                }
                /// Converts a `f32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline] fn from_f32( n: f32 ) -> Option<Self> {
                    FromPrimitive::from_f64( From::from( n ) )
                }
                /// Converts a `f64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                /// override this method if they can represent a greater range.
                #[inline] fn from_f64( n: f64 ) -> Option<Self> {
                    match n.to_i64() {
                        Some( i ) => FromPrimitive::from_i64( i ),
                        None => n.to_u64().and_then( FromPrimitive::from_u64 ),
                    }
                }
            }
            macro_rules! impl_from_primitive
            {
                ( $T:ty, $to_ty:ident ) => {
                    impl FromPrimitive for $T {
                        #[inline]
                        fn from_isize( n: isize ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i8( n: i8 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i16( n: i16 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i32( n: i32 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i64( n: i64 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i128( n: i128 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_usize( n: usize ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u8( n: u8 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u16( n: u16 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u32( n: u32 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u64( n: u64 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u128( n: u128 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_f32( n: f32 ) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_f64( n: f64 ) -> Option<$T> {
                            n.$to_ty()
                        }
                    }
                };
            }
            impl_from_primitive!( isize, to_isize );
            impl_from_primitive!( i8, to_i8 );
            impl_from_primitive!( i16, to_i16 );
            impl_from_primitive!( i32, to_i32 );
            impl_from_primitive!( i64, to_i64 );
            impl_from_primitive!( i128, to_i128 );
            impl_from_primitive!( usize, to_usize );
            impl_from_primitive!( u8, to_u8 );
            impl_from_primitive!( u16, to_u16 );
            impl_from_primitive!( u32, to_u32 );
            impl_from_primitive!( u64, to_u64 );
            impl_from_primitive!( u128, to_u128 );
            impl_from_primitive!( f32, to_f32 );
            impl_from_primitive!( f64, to_f64 );

            macro_rules! impl_from_primitive_nonzero
            {
                ( $T:ty, $to_ty:ident ) => {
                    impl FromPrimitive for $T {
                        #[inline]
                        fn from_isize( n: isize ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_i8( n: i8 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_i16( n: i16 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_i32( n: i32 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_i64( n: i64 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_i128( n: i128 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_usize( n: usize ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_u8( n: u8 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_u16( n: u16 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_u32( n: u32 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_u64( n: u64 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_u128( n: u128 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_f32( n: f32 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                        #[inline]
                        fn from_f64( n: f64 ) -> Option<$T> {
                            n.$to_ty().and_then( Self::new )
                        }
                    }
                };
            }
            impl_from_primitive_nonzero!( NonZeroIsize, to_isize );
            impl_from_primitive_nonzero!( NonZeroI8, to_i8 );
            impl_from_primitive_nonzero!( NonZeroI16, to_i16 );
            impl_from_primitive_nonzero!( NonZeroI32, to_i32 );
            impl_from_primitive_nonzero!( NonZeroI64, to_i64 );
            impl_from_primitive_nonzero!( NonZeroI128, to_i128 );
            impl_from_primitive_nonzero!( NonZeroUsize, to_usize );
            impl_from_primitive_nonzero!( NonZeroU8, to_u8 );
            impl_from_primitive_nonzero!( NonZeroU16, to_u16 );
            impl_from_primitive_nonzero!( NonZeroU32, to_u32 );
            impl_from_primitive_nonzero!( NonZeroU64, to_u64 );
            impl_from_primitive_nonzero!( NonZeroU128, to_u128 );

            macro_rules! impl_to_primitive_wrapping 
            {
                ( $( fn $method:ident -> $i:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$i> {
                        ( self.0 ).$method()
                    }
                )*}
            }
            
            impl<T: ToPrimitive> ToPrimitive for Wrapping<T> 
            {
                impl_to_primitive_wrapping! {
                    fn to_isize -> isize;
                    fn to_i8 -> i8;
                    fn to_i16 -> i16;
                    fn to_i32 -> i32;
                    fn to_i64 -> i64;
                    fn to_i128 -> i128;

                    fn to_usize -> usize;
                    fn to_u8 -> u8;
                    fn to_u16 -> u16;
                    fn to_u32 -> u32;
                    fn to_u64 -> u64;
                    fn to_u128 -> u128;

                    fn to_f32 -> f32;
                    fn to_f64 -> f64;
                }
            }
            macro_rules! impl_from_primitive_wrapping 
            {
                ( $( fn $method:ident ( $i:ident  ); )* ) => {$( 
                    #[inline] fn $method( n: $i ) -> Option<Self> {
                        T::$method( n ).map( Wrapping )
                    }
                )*}
            }
            
            impl<T: FromPrimitive> FromPrimitive for Wrapping<T> 
            {
                impl_from_primitive_wrapping! {
                    fn from_isize( isize );
                    fn from_i8( i8 );
                    fn from_i16( i16 );
                    fn from_i32( i32 );
                    fn from_i64( i64 );
                    fn from_i128( i128 );

                    fn from_usize( usize );
                    fn from_u8( u8 );
                    fn from_u16( u16 );
                    fn from_u32( u32 );
                    fn from_u64( u64 );
                    fn from_u128( u128 );

                    fn from_f32( f32 );
                    fn from_f64( f64 );
                }
            }
            /// Cast from one machine scalar to another.
            #[inline] pub fn cast<T: NumCast, U: NumCast>( n: T ) -> Option<U>
            {
                NumCast::from( n )
            }
            /// An interface for casting between machine scalars.
            pub trait NumCast: Sized + ToPrimitive
            {
                /// Creates a number from another value that can be converted into
                /// a primitive via the `ToPrimitive` trait. If the source value cannot be
                /// represented by the target type, then `None` is returned.
                fn from<T: ToPrimitive>( n: T ) -> Option<Self>;
            }
            macro_rules! impl_num_cast
            {
                ( $T:ty, $conv:ident ) => {
                    impl NumCast for $T {
                        #[inline]
                        fn from<N: ToPrimitive>( n: N ) -> Option<$T> {
                            n.$conv()
                        }
                    }
                };
            }
            impl_num_cast!( u8, to_u8 );
            impl_num_cast!( u16, to_u16 );
            impl_num_cast!( u32, to_u32 );
            impl_num_cast!( u64, to_u64 );
            impl_num_cast!( u128, to_u128 );
            impl_num_cast!( usize, to_usize );
            impl_num_cast!( i8, to_i8 );
            impl_num_cast!( i16, to_i16 );
            impl_num_cast!( i32, to_i32 );
            impl_num_cast!( i64, to_i64 );
            impl_num_cast!( i128, to_i128 );
            impl_num_cast!( isize, to_isize );
            impl_num_cast!( f32, to_f32 );
            impl_num_cast!( f64, to_f64 );

            macro_rules! impl_num_cast_nonzero {
                ( $T:ty, $conv:ident ) => {
                    impl NumCast for $T {
                        #[inline]
                        fn from<N: ToPrimitive>( n: N ) -> Option<$T> {
                            n.$conv().and_then( Self::new )
                        }
                    }
                };
            }
            impl_num_cast_nonzero!( NonZeroUsize, to_usize );
            impl_num_cast_nonzero!( NonZeroU8, to_u8 );
            impl_num_cast_nonzero!( NonZeroU16, to_u16 );
            impl_num_cast_nonzero!( NonZeroU32, to_u32 );
            impl_num_cast_nonzero!( NonZeroU64, to_u64 );
            impl_num_cast_nonzero!( NonZeroU128, to_u128 );

            impl_num_cast_nonzero!( NonZeroIsize, to_isize );
            impl_num_cast_nonzero!( NonZeroI8, to_i8 );
            impl_num_cast_nonzero!( NonZeroI16, to_i16 );
            impl_num_cast_nonzero!( NonZeroI32, to_i32 );
            impl_num_cast_nonzero!( NonZeroI64, to_i64 );
            impl_num_cast_nonzero!( NonZeroI128, to_i128 );

            impl<T: NumCast> NumCast for Wrapping<T>
            {
                fn from<U: ToPrimitive>( n: U ) -> Option<Self> {
                    T::from( n ).map( Wrapping )
                }
            }
            /// Generic interface for casting between machine scalars with the `as` operator, 
            /// which admits narrowing and precision loss.
            pub trait AsPrimitive<T>: 'static + Copy where
            T: 'static + Copy,
            {
                /// Convert a value to another, using the `as` operator.
                fn as_( self ) -> T;
            }
            macro_rules! impl_as_primitive
            {
                ( @ $T: ty =>  impl $U: ty ) => {
                    impl AsPrimitive<$U> for $T {
                        #[inline] fn as_( self ) -> $U { self as $U }
                    }
                };
                ( @ $T: ty => { $( $U: ty ),* } ) => {$( 
                    impl_as_primitive!( @ $T => impl $U );
                )*};
                ( $T: ty => { $( $U: ty ),* } ) => {
                    impl_as_primitive!( @ $T => { $( $U ),* } );
                    impl_as_primitive!( @ $T => { u8, u16, u32, u64, u128, usize } );
                    impl_as_primitive!( @ $T => { i8, i16, i32, i64, i128, isize } );
                };
            }
            impl_as_primitive!( u8 => { char, f32, f64 } );
            impl_as_primitive!( i8 => { f32, f64 } );
            impl_as_primitive!( u16 => { f32, f64 } );
            impl_as_primitive!( i16 => { f32, f64 } );
            impl_as_primitive!( u32 => { f32, f64 } );
            impl_as_primitive!( i32 => { f32, f64 } );
            impl_as_primitive!( u64 => { f32, f64 } );
            impl_as_primitive!( i64 => { f32, f64 } );
            impl_as_primitive!( u128 => { f32, f64 } );
            impl_as_primitive!( i128 => { f32, f64 } );
            impl_as_primitive!( usize => { f32, f64 } );
            impl_as_primitive!( isize => { f32, f64 } );
            impl_as_primitive!( f32 => { f32, f64 } );
            impl_as_primitive!( f64 => { f32, f64 } );
            impl_as_primitive!( char => { char } );
            impl_as_primitive!( bool => {} );

        } pub use self::cast::{cast, AsPrimitive, FromPrimitive, NumCast, ToPrimitive};

        pub mod float
        {
            use ::
            {
                cmp::{ Ordering },
                num::
                {
                    traits::{ Num, NumCast, ToPrimitive },
                    FpCategory
                },
                ops::{ Add, Div, Neg },
                *,
            };
            /*
            */
            /// Generic trait for floating point numbers that works with `no_std`.
            pub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy
            {
                /// Returns positive infinity.
                fn infinity() -> Self;
                /// Returns negative infinity.
                fn neg_infinity() -> Self;
                /// Returns NaN.
                fn nan() -> Self;
                /// Returns `-0.0`.
                fn neg_zero() -> Self;
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self;
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns `true` if the number is NaN.
                #[inline] fn is_nan( self ) -> bool {
                    self != self
                }
                /// Returns `true` if the number is infinite.
                #[inline] fn is_infinite( self ) -> bool {
                    self == Self::infinity() || self == Self::neg_infinity()
                }
                /// Returns `true` if the number is neither infinite or NaN.
                #[inline] fn is_finite( self ) -> bool {
                    !( self.is_nan() || self.is_infinite() )
                }
                /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.
                #[inline] fn is_normal( self ) -> bool {
                    self.classify() == FpCategory::Normal
                }
                /// Returns `true` if the number is [subnormal].
                #[inline] fn is_subnormal( self ) -> bool {
                    self.classify() == FpCategory::Subnormal
                }
                /// Returns the floating point category of the number.
                fn classify( self ) -> FpCategory;
                /// Returns the largest integer less than or equal to a number.
                #[inline] fn floor( self ) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self < Self::zero() {
                        self - f - Self::one()
                    } else {
                        self - f
                    }
                }
                /// Returns the smallest integer greater than or equal to a number.
                #[inline] fn ceil( self ) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        self - f + Self::one()
                    } else {
                        self - f
                    }
                }
                /// Returns the nearest integer to a number. Round half-way cases away from `0.0`.
                #[inline] fn round( self ) -> Self {
                    let one = Self::one();
                    let h = Self::from( 0.5 ).expect( "Unable to cast from 0.5" );
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        if f < h {
                            self - f
                        } else {
                            self - f + one
                        }
                    } else if -f < h {
                        self - f
                    } else {
                        self - f - one
                    }
                }
                /// Return the integer part of a number.
                #[inline] fn trunc( self ) -> Self {
                    let f = self.fract();
                    if f.is_nan() {
                        self
                    } else {
                        self - f
                    }
                }
                /// Returns the fractional part of a number.
                #[inline] fn fract( self ) -> Self {
                    if self.is_zero() {
                        Self::zero()
                    } else {
                        self % Self::one()
                    }
                }
                /// Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.
                #[inline] fn abs( self ) -> Self {
                    if self.is_sign_positive() {
                        return self;
                    }
                    if self.is_sign_negative() {
                        return -self;
                    }
                    Self::nan()
                }
                /// Returns a number that represents the sign of `self`.
                #[inline] fn signum( self ) -> Self {
                    if self.is_nan() {
                        Self::nan()
                    } else if self.is_sign_negative() {
                        -Self::one()
                    } else {
                        Self::one()
                    }
                }
                /// Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and `Float::nan()`.
                #[inline] fn is_sign_positive( self ) -> bool {
                    !self.is_sign_negative()
                }
                /// Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and `-Float::nan()`.
                #[inline] fn is_sign_negative( self ) -> bool {
                    let ( _, _, sign ) = self.integer_decode();
                    sign < 0
                }
                /// Returns the minimum of the two numbers.
                #[inline] fn min( self, other: Self ) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self < other {
                        self
                    } else {
                        other
                    }
                }
                /// Returns the maximum of the two numbers.
                #[inline] fn max( self, other: Self ) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self > other {
                        self
                    } else {
                        other
                    }
                }
                /// A value bounded by a minimum and a maximum.
                fn clamp( self, min: Self, max: Self ) -> Self {
                    ::num::traits::clamp( self, min, max )
                }
                /// Returns the reciprocal ( multiplicative inverse ) of the number.
                #[inline] fn recip( self ) -> Self {
                    Self::one() / self
                }
                /// Raise a number to an integer power.
                #[inline] fn powi( mut self, mut exp: i32 ) -> Self {
                    if exp < 0 {
                        exp = exp.wrapping_neg();
                        self = self.recip();
                    }
                   
                   
                   
                    super::pow( self, ( exp as u32 ).to_usize().unwrap() )
                }
                /// Converts to degrees, assuming the number is in radians.
                fn to_degrees( self ) -> Self;
                /// Converts to radians, assuming the number is in degrees.
                fn to_radians( self ) -> Self;
                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                fn integer_decode( self ) -> ( u64, i16, i8 );
            }
            
            impl FloatCore for f32
            {
                constant!
                {
                    infinity() -> f32::INFINITY;
                    neg_infinity() -> f32::NEG_INFINITY;
                    nan() -> f32::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f32::MIN;
                    min_positive_value() -> f32::MIN_POSITIVE;
                    epsilon() -> f32::EPSILON;
                    max_value() -> f32::MAX;
                }
                #[inline] fn integer_decode( self ) -> ( u64, i16, i8 )
                {
                    integer_decode_f32( self )
                }
                forward!
                {
                    Self::is_nan( self ) -> bool;
                    Self::is_infinite( self ) -> bool;
                    Self::is_finite( self ) -> bool;
                    Self::is_normal( self ) -> bool;
                    Self::is_subnormal( self ) -> bool;
                    Self::clamp( self, min: Self, max: Self ) -> Self;
                    Self::classify( self ) -> FpCategory;
                    Self::is_sign_positive( self ) -> bool;
                    Self::is_sign_negative( self ) -> bool;
                    Self::min( self, other: Self ) -> Self;
                    Self::max( self, other: Self ) -> Self;
                    Self::recip( self ) -> Self;
                    Self::to_degrees( self ) -> Self;
                    Self::to_radians( self ) -> Self;
                }
                
                forward!
                {
                    Self::floor( self ) -> Self;
                    Self::ceil( self ) -> Self;
                    Self::round( self ) -> Self;
                    Self::trunc( self ) -> Self;
                    Self::fract( self ) -> Self;
                    Self::abs( self ) -> Self;
                    Self::signum( self ) -> Self;
                    Self::powi( self, n: i32 ) -> Self;
                }
            }
            
            impl FloatCore for f64
            {
                constant!
                {
                    infinity() -> f64::INFINITY;
                    neg_infinity() -> f64::NEG_INFINITY;
                    nan() -> f64::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f64::MIN;
                    min_positive_value() -> f64::MIN_POSITIVE;
                    epsilon() -> f64::EPSILON;
                    max_value() -> f64::MAX;
                }
                #[inline] fn integer_decode( self ) -> ( u64, i16, i8 )
                {
                    integer_decode_f64( self )
                }
                forward!
                {
                    Self::is_nan( self ) -> bool;
                    Self::is_infinite( self ) -> bool;
                    Self::is_finite( self ) -> bool;
                    Self::is_normal( self ) -> bool;
                    Self::is_subnormal( self ) -> bool;
                    Self::clamp( self, min: Self, max: Self ) -> Self;
                    Self::classify( self ) -> FpCategory;
                    Self::is_sign_positive( self ) -> bool;
                    Self::is_sign_negative( self ) -> bool;
                    Self::min( self, other: Self ) -> Self;
                    Self::max( self, other: Self ) -> Self;
                    Self::recip( self ) -> Self;
                    Self::to_degrees( self ) -> Self;
                    Self::to_radians( self ) -> Self;
                }
                
                forward!
                {
                    Self::floor( self ) -> Self;
                    Self::ceil( self ) -> Self;
                    Self::round( self ) -> Self;
                    Self::trunc( self ) -> Self;
                    Self::fract( self ) -> Self;
                    Self::abs( self ) -> Self;
                    Self::signum( self ) -> Self;
                    Self::powi( self, n: i32 ) -> Self;
                }
            }
            /// Generic trait for floating point numbers
            pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self>
            {
                /// Returns the `NaN` value.
                fn nan() -> Self;
                /// Returns the infinite value.
                fn infinity() -> Self;
                /// Returns the negative infinite value.
                fn neg_infinity() -> Self;
                /// Returns `-0.0`.
                fn neg_zero() -> Self;
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self {
                    Self::from( f32::EPSILON ).expect( "Unable to cast from f32::EPSILON" )
                }
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns `true` if this value is `NaN` and false otherwise.
                fn is_nan( self ) -> bool;
                /// Returns `true` if this value is positive infinity or negative infinity and false otherwise.
                fn is_infinite( self ) -> bool;
                /// Returns `true` if this number is neither infinite nor `NaN`.
                fn is_finite( self ) -> bool;
                /// Returns `true` if the number is neither zero, infinite, subnormal, or `NaN`.
                fn is_normal( self ) -> bool;
                /// Returns `true` if the number is [subnormal].
                #[inline] fn is_subnormal( self ) -> bool {
                    self.classify() == FpCategory::Subnormal
                }
                /// Returns the floating point category of the number.
                fn classify( self ) -> FpCategory;
                /// Returns the largest integer less than or equal to a number.
                fn floor( self ) -> Self;
                /// Returns the smallest integer greater than or equal to a number.
                fn ceil( self ) -> Self;
                /// Returns the nearest integer to a number. Round half-way cases away from `0.0`.
                fn round( self ) -> Self;
                /// Return the integer part of a number.
                fn trunc( self ) -> Self;
                /// Returns the fractional part of a number.
                fn fract( self ) -> Self;
                /// Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.
                fn abs( self ) -> Self;
                /// Returns a number that represents the sign of `self`.
                fn signum( self ) -> Self;
                /// Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, `Float::nan()`.
                fn is_sign_positive( self ) -> bool;
                /// Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, `-Float::nan()`.
                fn is_sign_negative( self ) -> bool;
                /// Fused multiply-add.
                fn mul_add( self, a: Self, b: Self ) -> Self;
                /// Take the reciprocal ( inverse ) of a number, `1/x`.
                fn recip( self ) -> Self;
                /// Raise a number to an integer power.
                fn powi( self, n: i32 ) -> Self;
                /// Raise a number to a floating point power.
                fn powf( self, n: Self ) -> Self;
                /// Take the square root of a number.
                fn sqrt( self ) -> Self;
                /// Returns `e^( self )`, ( the exponential function ).
                fn exp( self ) -> Self;
                /// Returns `2^( self )`.
                fn exp2( self ) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln( self ) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log( self, base: Self ) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2( self ) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10( self ) -> Self;
                /// Converts radians to degrees.
                #[inline] fn to_degrees( self ) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from( 90u8 ).unwrap();
                    self * ninety / halfpi
                }
                /// Converts degrees to radians.
                #[inline] fn to_radians( self ) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from( 90u8 ).unwrap();
                    self * halfpi / ninety
                }
                /// Returns the maximum of the two numbers.
                fn max( self, other: Self ) -> Self;
                /// Returns the minimum of the two numbers.
                fn min( self, other: Self ) -> Self;
                /// Clamps a value between a min and max.
                fn clamp( self, min: Self, max: Self ) -> Self {
                    num::traits::clamp( self, min, max )
                }
                /// The positive difference of two numbers.
                fn abs_sub( self, other: Self ) -> Self;
                /// Take the cubic root of a number.
                fn cbrt( self ) -> Self;
                /// Calculate the length of the hypotenuse of a right-angle triangle, legs of length `x` and `y`.
                fn hypot( self, other: Self ) -> Self;
                /// Computes the sine of a number ( in radians ).
                fn sin( self ) -> Self;
                /// Computes the cosine of a number ( in radians ).
                fn cos( self ) -> Self;
                /// Computes the tangent of a number ( in radians ).
                fn tan( self ) -> Self;
                /// Computes the arcsine of a number.
                fn asin( self ) -> Self;
                /// Computes the arccosine of a number.
                fn acos( self ) -> Self;
                /// Computes the arctangent of a number.
                fn atan( self ) -> Self;
                /// Computes the four quadrant arctangent of `self` ( `y` ) and `other` ( `x` ).
                fn atan2( self, other: Self ) -> Self;
                /// Simultaneously computes the sine and cosine of the number, `x`.
                fn sin_cos( self ) -> ( Self, Self );
                /// Returns `e^( self ) - 1` in a way that is accurate even if the number is close to zero.
                fn exp_m1( self ) -> Self;
                /// Returns `ln( 1+n )` more accurately than if the operations were performed separately.
                fn ln_1p( self ) -> Self;
                /// Hyperbolic sine function.
                fn sinh( self ) -> Self;
                /// Hyperbolic cosine function.
                fn cosh( self ) -> Self;
                /// Hyperbolic tangent function.
                fn tanh( self ) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh( self ) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh( self ) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh( self ) -> Self;
                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                fn integer_decode( self ) -> ( u64, i16, i8 );
                /// Returns a number composed of the magnitude of `self` and the sign of `sign`.
                fn copysign( self, sign: Self ) -> Self {
                    if self.is_sign_negative() == sign.is_sign_negative() {
                        self
                    } else {
                        self.neg()
                    }
                }
            }
            macro_rules! float_impl_std
            {
                ( $T:ident $decode:ident ) => {
                    impl Float for $T {
                        constant! {
                            nan() -> $T::NAN;
                            infinity() -> $T::INFINITY;
                            neg_infinity() -> $T::NEG_INFINITY;
                            neg_zero() -> -0.0;
                            min_value() -> $T::MIN;
                            min_positive_value() -> $T::MIN_POSITIVE;
                            epsilon() -> $T::EPSILON;
                            max_value() -> $T::MAX;
                        }
                        #[inline]
                        #[allow( deprecated )]
                        fn abs_sub( self, other: Self ) -> Self {
                            <$T>::abs_sub( self, other )
                        }
                        #[inline]
                        fn integer_decode( self ) -> ( u64, i16, i8 ) {
                            $decode( self )
                        }
                        forward! {
                            Self::is_nan( self ) -> bool;
                            Self::is_infinite( self ) -> bool;
                            Self::is_finite( self ) -> bool;
                            Self::is_normal( self ) -> bool;
                            Self::is_subnormal( self ) -> bool;
                            Self::classify( self ) -> FpCategory;
                            Self::clamp( self, min: Self, max: Self ) -> Self;
                            Self::floor( self ) -> Self;
                            Self::ceil( self ) -> Self;
                            Self::round( self ) -> Self;
                            Self::trunc( self ) -> Self;
                            Self::fract( self ) -> Self;
                            Self::abs( self ) -> Self;
                            Self::signum( self ) -> Self;
                            Self::is_sign_positive( self ) -> bool;
                            Self::is_sign_negative( self ) -> bool;
                            Self::mul_add( self, a: Self, b: Self ) -> Self;
                            Self::recip( self ) -> Self;
                            Self::powi( self, n: i32 ) -> Self;
                            Self::powf( self, n: Self ) -> Self;
                            Self::sqrt( self ) -> Self;
                            Self::exp( self ) -> Self;
                            Self::exp2( self ) -> Self;
                            Self::ln( self ) -> Self;
                            Self::log( self, base: Self ) -> Self;
                            Self::log2( self ) -> Self;
                            Self::log10( self ) -> Self;
                            Self::to_degrees( self ) -> Self;
                            Self::to_radians( self ) -> Self;
                            Self::max( self, other: Self ) -> Self;
                            Self::min( self, other: Self ) -> Self;
                            Self::cbrt( self ) -> Self;
                            Self::hypot( self, other: Self ) -> Self;
                            Self::sin( self ) -> Self;
                            Self::cos( self ) -> Self;
                            Self::tan( self ) -> Self;
                            Self::asin( self ) -> Self;
                            Self::acos( self ) -> Self;
                            Self::atan( self ) -> Self;
                            Self::atan2( self, other: Self ) -> Self;
                            Self::sin_cos( self ) -> ( Self, Self );
                            Self::exp_m1( self ) -> Self;
                            Self::ln_1p( self ) -> Self;
                            Self::sinh( self ) -> Self;
                            Self::cosh( self ) -> Self;
                            Self::tanh( self ) -> Self;
                            Self::asinh( self ) -> Self;
                            Self::acosh( self ) -> Self;
                            Self::atanh( self ) -> Self;
                            Self::copysign( self, sign: Self ) -> Self;
                        }
                    }
                };
            }
            
            fn integer_decode_f32( f: f32 ) -> ( u64, i16, i8 )
            {
                let bits: u32 = f.to_bits();
                let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };
                let mut exponent: i16 = (( bits >> 23 ) & 0xff ) as i16;
                let mantissa = if exponent == 0 {
                    ( bits & 0x7fffff ) << 1
                } else {
                    ( bits & 0x7fffff ) | 0x800000
                };
               
                exponent -= 127 + 23;
                ( mantissa as u64, exponent, sign )
            }
            fn integer_decode_f64( f: f64 ) -> ( u64, i16, i8 )
            {
                let bits: u64 = f.to_bits();
                let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
                let mut exponent: i16 = (( bits >> 52 ) & 0x7ff ) as i16;
                let mantissa = if exponent == 0 {
                    ( bits & 0xfffffffffffff ) << 1
                } else {
                    ( bits & 0xfffffffffffff ) | 0x10000000000000
                };
               
                exponent -= 1023 + 52;
                ( mantissa, exponent, sign )
            }
            float_impl_std!( f32 integer_decode_f32 );
            float_impl_std!( f64 integer_decode_f64 );
            
            macro_rules! float_const_impl
            {
                ( $( #[$doc:meta] $constant:ident, )+ ) => ( 
                    #[allow( non_snake_case )]
                    pub trait FloatConst {
                        $( #[$doc] fn $constant() -> Self; )+
                        #[doc = "Return the full circle constant ``."]
                        #[inline]
                        fn TAU() -> Self where Self: Sized + Add<Self, Output = Self> {
                            Self::PI() + Self::PI()
                        }
                        #[doc = "Return `log10( 2.0 )`."]
                        #[inline]
                        fn LOG10_2() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_2() / Self::LN_10()
                        }
                        #[doc = "Return `log2( 10.0 )`."]
                        #[inline]
                        fn LOG2_10() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_10() / Self::LN_2()
                        }
                    }
                    float_const_impl! { @float f32, $( $constant, )+ }
                    float_const_impl! { @float f64, $( $constant, )+ }
                 );
                ( @float $T:ident, $( $constant:ident, )+ ) => ( 
                    impl FloatConst for $T {
                        constant! {
                            $( $constant() -> $T::consts::$constant; )+
                            TAU() -> 6.28318530717958647692528676655900577;
                            LOG10_2() -> 0.301029995663981195213738894724493027;
                            LOG2_10() -> 3.32192809488736234787031942948939018;
                        }
                    }
                 );
            }
            float_const_impl!
            {
                #[doc = "Return Eulers number."]
                E,
                #[doc = "Return `1.0 / `."]
                FRAC_1_PI,
                #[doc = "Return `1.0 / sqrt( 2.0 )`."]
                FRAC_1_SQRT_2,
                #[doc = "Return `2.0 / `."]
                FRAC_2_PI,
                #[doc = "Return `2.0 / sqrt(  )`."]
                FRAC_2_SQRT_PI,
                #[doc = "Return ` / 2.0`."]
                FRAC_PI_2,
                #[doc = "Return ` / 3.0`."]
                FRAC_PI_3,
                #[doc = "Return ` / 4.0`."]
                FRAC_PI_4,
                #[doc = "Return ` / 6.0`."]
                FRAC_PI_6,
                #[doc = "Return ` / 8.0`."]
                FRAC_PI_8,
                #[doc = "Return `ln( 10.0 )`."]
                LN_10,
                #[doc = "Return `ln( 2.0 )`."]
                LN_2,
                #[doc = "Return `log10( e )`."]
                LOG10_E,
                #[doc = "Return `log2( e )`."]
                LOG2_E,
                #[doc = "Return Archimedes constant ``."]
                PI,
                #[doc = "Return `sqrt( 2.0 )`."]
                SQRT_2,
            }
            /// Trait for floating point numbers that provide an implementation of the `totalOrder` predicate.
            pub trait TotalOrder
            {
                /// Return the ordering between `self` and `other`.
                fn total_cmp( &self, other:&Self ) -> Ordering;
            }
            macro_rules! totalorder_impl
            {
                ( $T:ident, $I:ident, $U:ident, $bits:expr ) => {
                    impl TotalOrder for $T {
                        #[inline]
                        #[cfg( has_total_cmp )]
                        fn total_cmp( &self, other:&Self ) -> Ordering {
                           
                            Self::total_cmp( &self, other )
                        }
                        #[inline]
                        #[cfg( not( has_total_cmp ) )]
                        fn total_cmp( &self, other:&Self ) -> Ordering {
                           
                            let mut left = self.to_bits() as $I;
                            let mut right = other.to_bits() as $I;

                            left ^= (( ( left >> ( $bits - 1 ) ) as $U ) >> 1 ) as $I;
                            right ^= (( ( right >> ( $bits - 1 ) ) as $U ) >> 1 ) as $I;

                            left.cmp( &right )
                        }
                    }
                };
            }
            totalorder_impl!( f64, i64, u64, 64 );
            totalorder_impl!( f32, i32, u32, 32 );
        } pub use self::float::{ Float, FloatConst };

        pub mod identities
        {
            use ::
            {
                num::{ Saturating, Wrapping },
                ops::{ Add, Mul },
                *,
            };
            /*
            */
            /// Defines an additive identity element for `Self`.
            pub trait Zero: Sized + Add<Self, Output = Self>
            {
                /// Returns the additive identity element of `Self`, `0`.
               
                fn zero() -> Self;
                /// Sets `self` to the additive identity element of `Self`, `0`.
                fn set_zero( &mut self ) {
                    *self = Zero::zero();
                }
                /// Returns `true` if `self` is equal to the additive identity.
                fn is_zero( &self ) -> bool;
            }
            /// Defines an associated constant representing the additive identity element for `Self`.
            pub trait ConstZero: Zero
            {
                /// The additive identity element of `Self`, `0`.
                const ZERO: Self;
            }
            macro_rules! zero_impl
            {
                ( $t:ty, $v:expr ) => {
                    impl Zero for $t {
                        #[inline]
                        fn zero() -> $t {
                            $v
                        }
                        #[inline]
                        fn is_zero( &self ) -> bool {
                            *self == $v
                        }
                    }
                    impl ConstZero for $t {
                        const ZERO: Self = $v;
                    }
                };
            }
            zero_impl!( usize, 0 );
            zero_impl!( u8, 0 );
            zero_impl!( u16, 0 );
            zero_impl!( u32, 0 );
            zero_impl!( u64, 0 );
            zero_impl!( u128, 0 );

            zero_impl!( isize, 0 );
            zero_impl!( i8, 0 );
            zero_impl!( i16, 0 );
            zero_impl!( i32, 0 );
            zero_impl!( i64, 0 );
            zero_impl!( i128, 0 );

            zero_impl!( f32, 0.0 );
            zero_impl!( f64, 0.0 );

            impl<T: Zero> Zero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                fn is_zero( &self ) -> bool {
                    self.0.is_zero()
                }
                fn set_zero( &mut self ) {
                    self.0.set_zero();
                }
                fn zero() -> Self {
                    Wrapping( T::zero() )
                }
            }
            
            impl<T: ConstZero> ConstZero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                const ZERO: Self = Wrapping( T::ZERO );
            }
            #[cfg( has_num_saturating )]
            impl<T: Zero> Zero for Saturating<T> where
                Saturating<T>: Add<Output = Saturating<T>>,
            {
                fn is_zero( &self ) -> bool {
                    self.0.is_zero()
                }
                fn set_zero( &mut self ) {
                    self.0.set_zero();
                }
                fn zero() -> Self {
                    Saturating( T::zero() )
                }
            }
            #[cfg( has_num_saturating )]
            impl<T: ConstZero> ConstZero for Saturating<T> where
                Saturating<T>: Add<Output = Saturating<T>>,
            {
                const ZERO: Self = Saturating( T::ZERO );
            }
            /// Defines a multiplicative identity element for `Self`.
            pub trait One: Sized + Mul<Self, Output = Self> {
                /// Returns the multiplicative identity element of `Self`, `1`.
               
                fn one() -> Self;
                /// Sets `self` to the multiplicative identity element of `Self`, `1`.
                fn set_one( &mut self ) {
                    *self = One::one();
                }
                /// Returns `true` if `self` is equal to the multiplicative identity.
                #[inline] fn is_one( &self ) -> bool
                where
                    Self: PartialEq,
                {
                    *self == Self::one()
                }
            }
            /// Defines an associated constant representing the multiplicative identity element for `Self`.
            pub trait ConstOne: One {
                /// The multiplicative identity element of `Self`, `1`.
                const ONE: Self;
            }

            macro_rules! one_impl {
                ( $t:ty, $v:expr ) => {
                    impl One for $t {
                        #[inline]
                        fn one() -> $t {
                            $v
                        }
                        #[inline]
                        fn is_one( &self ) -> bool {
                            *self == $v
                        }
                    }
                    impl ConstOne for $t {
                        const ONE: Self = $v;
                    }
                };
            }

            one_impl!( usize, 1 );
            one_impl!( u8, 1 );
            one_impl!( u16, 1 );
            one_impl!( u32, 1 );
            one_impl!( u64, 1 );
            one_impl!( u128, 1 );

            one_impl!( isize, 1 );
            one_impl!( i8, 1 );
            one_impl!( i16, 1 );
            one_impl!( i32, 1 );
            one_impl!( i64, 1 );
            one_impl!( i128, 1 );

            one_impl!( f32, 1.0 );
            one_impl!( f64, 1.0 );

            impl<T: One> One for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                fn set_one( &mut self ) {
                    self.0.set_one();
                }
                fn one() -> Self {
                    Wrapping( T::one() )
                }
            }
            
            impl<T: ConstOne> ConstOne for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                const ONE: Self = Wrapping( T::ONE );
            }
            #[cfg( has_num_saturating )]
            impl<T: One> One for Saturating<T> where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                fn set_one( &mut self ) {
                    self.0.set_one();
                }
                fn one() -> Self {
                    Saturating( T::one() )
                }
            }
            #[cfg( has_num_saturating )]
            impl<T: ConstOne> ConstOne for Saturating<T> where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                const ONE: Self = Saturating( T::ONE );
            }
           

            /// Returns the additive identity, `0`.
            #[inline( always )] pub fn zero<T: Zero>() -> T {
                Zero::zero()
            }
            /// Returns the multiplicative identity, `1`.
            #[inline( always )] pub fn one<T: One>() -> T {
                One::one()
            }
        } pub use self::identities::{one, zero, ConstOne, ConstZero, One, Zero};

        pub mod int
        {
            use ::
            {
                num::
                {
                    traits::
                    {
                        bounds::Bounded,
                        ops::
                        {
                            checked::*,
                            saturating::Saturating,
                        },
                        Num, NumCast,
                    },
                },
                ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr},
                *,
            };
            /*
            */
            /// Generic trait for primitive integers.
            pub trait PrimInt:
                Sized
                + Copy
                + Num
                + NumCast
                + Bounded
                + PartialOrd
                + Ord
                + Eq
                + Not<Output = Self>
                + BitAnd<Output = Self>
                + BitOr<Output = Self>
                + BitXor<Output = Self>
                + Shl<usize, Output = Self>
                + Shr<usize, Output = Self>
                + CheckedAdd<Output = Self>
                + CheckedSub<Output = Self>
                + CheckedMul<Output = Self>
                + CheckedDiv<Output = Self>
                + Saturating
            {
                /// Returns the number of ones in the binary representation of `self`.
                fn count_ones( self ) -> u32;
                /// Returns the number of zeros in the binary representation of `self`.
                fn count_zeros( self ) -> u32;
                /// Returns the number of leading ones in the binary representation
                /// of `self`.
                fn leading_ones( self ) -> u32 {
                    ( !self ).leading_zeros()
                }
                /// Returns the number of leading zeros in the binary representation
                /// of `self`.
                fn leading_zeros( self ) -> u32;
                /// Returns the number of trailing ones in the binary representation
                /// of `self`.
                fn trailing_ones( self ) -> u32 {
                    ( !self ).trailing_zeros()
                }
                /// Returns the number of trailing zeros in the binary representation
                /// of `self`.
                fn trailing_zeros( self ) -> u32;
                /// Shifts the bits to the left by a specified amount, `n`, wrapping
                /// the truncated bits to the end of the resulting integer.
                fn rotate_left( self, n: u32 ) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, wrapping
                /// the truncated bits to the beginning of the resulting integer.
                fn rotate_right( self, n: u32 ) -> Self;
                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                fn signed_shl( self, n: u32 ) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, copying
                /// the "sign bit" in the most significant bits even for unsigned types.
                fn signed_shr( self, n: u32 ) -> Self;
                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                fn unsigned_shl( self, n: u32 ) -> Self;
                /// Shifts the bits to the right by a specified amount, `n`, filling
                /// zeros in the most significant bits.
                fn unsigned_shr( self, n: u32 ) -> Self;
                /// Reverses the byte order of the integer.
                fn swap_bytes( self ) -> Self;
                /// Reverses the order of bits in the integer.
                fn reverse_bits( self ) -> Self {
                    reverse_bits_fallback( self )
                }
                /// Convert an integer from big endian to the target's endianness.
                fn from_be( x: Self ) -> Self;
                /// Convert an integer from little endian to the target's endianness.
                fn from_le( x: Self ) -> Self;
                /// Convert `self` to big endian from the target's endianness.
                fn to_be( self ) -> Self;
                /// Convert `self` to little endian from the target's endianness.
                fn to_le( self ) -> Self;
                /// Raises self to the power of `exp`, using exponentiation by squaring.
                fn pow( self, exp: u32 ) -> Self;
            }
            fn one_per_byte<P: PrimInt>() -> P {
               
               
               
               
                let mut ret = P::one();
                let mut shift = 8;
                let mut b = ret.count_zeros() >> 3;
                while b != 0 {
                    ret = ( ret << shift ) | ret;
                    shift <<= 1;
                    b >>= 1;
                }
                ret
            }
            fn reverse_bits_fallback<P: PrimInt>( i: P ) -> P {
                let rep_01: P = one_per_byte();
                let rep_03 = ( rep_01 << 1 ) | rep_01;
                let rep_05 = ( rep_01 << 2 ) | rep_01;
                let rep_0f = ( rep_03 << 2 ) | rep_03;
                let rep_33 = ( rep_03 << 4 ) | rep_03;
                let rep_55 = ( rep_05 << 4 ) | rep_05;

               
               
                let mut ret = i.swap_bytes();
                ret = (( ret & rep_0f ) << 4 ) | ( ( ret >> 4 ) & rep_0f );
                ret = (( ret & rep_33 ) << 2 ) | ( ( ret >> 2 ) & rep_33 );
                ret = (( ret & rep_55 ) << 1 ) | ( ( ret >> 1 ) & rep_55 );
                ret
            }
            macro_rules! prim_int_impl {
                ( $T:ty, $S:ty, $U:ty ) => {
                    impl PrimInt for $T {
                        #[inline]
                        fn count_ones( self ) -> u32 {
                            <$T>::count_ones( self )
                        }
                        #[inline]
                        fn count_zeros( self ) -> u32 {
                            <$T>::count_zeros( self )
                        }
                        #[inline]
                        fn leading_ones( self ) -> u32 {
                            <$T>::leading_ones( self )
                        }
                        #[inline]
                        fn leading_zeros( self ) -> u32 {
                            <$T>::leading_zeros( self )
                        }
                        #[inline]
                        fn trailing_ones( self ) -> u32 {
                            <$T>::trailing_ones( self )
                        }
                        #[inline]
                        fn trailing_zeros( self ) -> u32 {
                            <$T>::trailing_zeros( self )
                        }
                        #[inline]
                        fn rotate_left( self, n: u32 ) -> Self {
                            <$T>::rotate_left( self, n )
                        }
                        #[inline]
                        fn rotate_right( self, n: u32 ) -> Self {
                            <$T>::rotate_right( self, n )
                        }
                        #[inline]
                        fn signed_shl( self, n: u32 ) -> Self {
                            ( ( self as $S ) << n ) as $T
                        }
                        #[inline]
                        fn signed_shr( self, n: u32 ) -> Self {
                            ( ( self as $S ) >> n ) as $T
                        }
                        #[inline]
                        fn unsigned_shl( self, n: u32 ) -> Self {
                            ( ( self as $U ) << n ) as $T
                        }
                        #[inline]
                        fn unsigned_shr( self, n: u32 ) -> Self {
                            ( ( self as $U ) >> n ) as $T
                        }
                        #[inline]
                        fn swap_bytes( self ) -> Self {
                            <$T>::swap_bytes( self )
                        }
                        #[inline]
                        fn reverse_bits( self ) -> Self {
                            <$T>::reverse_bits( self )
                        }
                        #[inline]
                        fn from_be( x: Self ) -> Self {
                            <$T>::from_be( x )
                        }
                        #[inline]
                        fn from_le( x: Self ) -> Self {
                            <$T>::from_le( x )
                        }
                        #[inline]
                        fn to_be( self ) -> Self {
                            <$T>::to_be( self )
                        }
                        #[inline]
                        fn to_le( self ) -> Self {
                            <$T>::to_le( self )
                        }
                        #[inline]
                        fn pow( self, exp: u32 ) -> Self {
                            <$T>::pow( self, exp )
                        }
                    }
                };
            }
            
            prim_int_impl!( u8, i8, u8 );
            prim_int_impl!( u16, i16, u16 );
            prim_int_impl!( u32, i32, u32 );
            prim_int_impl!( u64, i64, u64 );
            prim_int_impl!( u128, i128, u128 );
            prim_int_impl!( usize, isize, usize );
            prim_int_impl!( i8, i8, u8 );
            prim_int_impl!( i16, i16, u16 );
            prim_int_impl!( i32, i32, u32 );
            prim_int_impl!( i64, i64, u64 );
            prim_int_impl!( i128, i128, u128 );
            prim_int_impl!( isize, isize, usize );
        } pub use self::int::PrimInt;

        pub mod ops
        {
            use ::
            {
                *,
            };
            /*
            */
            pub mod bytes
            {
                /*!
                */
                use ::
                {
                    borrow::{ Borrow, BorrowMut },
                    cmp::{ Eq, Ord, PartialEq, PartialOrd },
                    fmt::{ Debug },
                    hash::{ Hash },
                    *,
                };
                /*
                */
                pub trait NumBytes:
                    Debug
                    + AsRef<[u8]>
                    + AsMut<[u8]>
                    + PartialEq
                    + Eq
                    + PartialOrd
                    + Ord
                    + Hash
                    + Borrow<[u8]>
                    + BorrowMut<[u8]>
                {
                }
                impl<T> NumBytes for T where
                    T: Debug
                        + AsRef<[u8]>
                        + AsMut<[u8]>
                        + PartialEq
                        + Eq
                        + PartialOrd
                        + Ord
                        + Hash
                        + Borrow<[u8]>
                        + BorrowMut<[u8]>
                        + ?Sized
                {
                }
                pub trait ToBytes {
                    type Bytes: NumBytes;

                    /// Return the memory representation of this number as a byte array in big-endian byte order.
                    fn to_be_bytes( &self ) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in little-endian byte order.
                    fn to_le_bytes( &self ) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in native byte order.
                    fn to_ne_bytes( &self ) -> Self::Bytes {
                        #[cfg( target_endian = "big" )]
                        let bytes = self.to_be_bytes();
                        #[cfg( target_endian = "little" )]
                        let bytes = self.to_le_bytes();
                        bytes
                    }
                }
                pub trait FromBytes: Sized {
                    type Bytes: NumBytes + ?Sized;

                    /// Create a number from its representation as a byte array in big endian.
                    fn from_be_bytes( bytes:&Self::Bytes ) -> Self;

                    /// Create a number from its representation as a byte array in little endian.
                    fn from_le_bytes( bytes:&Self::Bytes ) -> Self;

                    /// Create a number from its memory representation as a byte array in native endianness.
                    fn from_ne_bytes( bytes:&Self::Bytes ) -> Self {
                        #[cfg( target_endian = "big" )]
                        let this = Self::from_be_bytes( bytes );
                        #[cfg( target_endian = "little" )]
                        let this = Self::from_le_bytes( bytes );
                        this
                    }
                }
                macro_rules! float_to_from_bytes_impl {
                    ( $T:ty, $L:expr ) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes( &self ) -> Self::Bytes {
                                <$T>::to_be_bytes( *self )
                            }
                            #[inline]
                            fn to_le_bytes( &self ) -> Self::Bytes {
                                <$T>::to_le_bytes( *self )
                            }
                            #[inline]
                            fn to_ne_bytes( &self ) -> Self::Bytes {
                                <$T>::to_ne_bytes( *self )
                            }
                        }
                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_be_bytes( *bytes )
                            }
                            #[inline]
                            fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_le_bytes( *bytes )
                            }
                            #[inline]
                            fn from_ne_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_ne_bytes( *bytes )
                            }
                        }
                    };
                }
                macro_rules! int_to_from_bytes_impl {
                    ( $T:ty, $L:expr ) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes( &self ) -> Self::Bytes {
                                <$T>::to_be_bytes( *self )
                            }
                            #[inline]
                            fn to_le_bytes( &self ) -> Self::Bytes {
                                <$T>::to_le_bytes( *self )
                            }
                            #[inline]
                            fn to_ne_bytes( &self ) -> Self::Bytes {
                                <$T>::to_ne_bytes( *self )
                            }
                        }
                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_be_bytes( *bytes )
                            }
                            #[inline]
                            fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_le_bytes( *bytes )
                            }
                            #[inline]
                            fn from_ne_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_ne_bytes( *bytes )
                            }
                        }
                    };
                }
                int_to_from_bytes_impl!( u8, 1 );
                int_to_from_bytes_impl!( u16, 2 );
                int_to_from_bytes_impl!( u32, 4 );
                int_to_from_bytes_impl!( u64, 8 );
                int_to_from_bytes_impl!( u128, 16 );
                #[cfg( target_pointer_width = "64" )]
                int_to_from_bytes_impl!( usize, 8 );
                #[cfg( target_pointer_width = "32" )]
                int_to_from_bytes_impl!( usize, 4 );

                int_to_from_bytes_impl!( i8, 1 );
                int_to_from_bytes_impl!( i16, 2 );
                int_to_from_bytes_impl!( i32, 4 );
                int_to_from_bytes_impl!( i64, 8 );
                int_to_from_bytes_impl!( i128, 16 );
                #[cfg( target_pointer_width = "64" )]
                int_to_from_bytes_impl!( isize, 8 );
                #[cfg( target_pointer_width = "32" )]
                int_to_from_bytes_impl!( isize, 4 );

                float_to_from_bytes_impl!( f32, 4 );
                float_to_from_bytes_impl!( f64, 8 );
            }
            
            pub mod checked
            {
                /*!
                */
                use ::
                {
                    ops::{Add, Div, Mul, Rem, Shl, Shr, Sub},
                    *,
                };
                /*
                */
                /// Performs addition, returning `None` if overflow occurred.
                pub trait CheckedAdd: Sized + Add<Self, Output = Self> {
                    /// Adds two numbers, checking for overflow. If overflow happens, `None` is
                    /// returned.
                    fn checked_add( &self, v:&Self ) -> Option<Self>;
                }
                macro_rules! checked_impl {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&$t ) -> Option<$t> {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                }
                checked_impl!( CheckedAdd, checked_add, u8 );
                checked_impl!( CheckedAdd, checked_add, u16 );
                checked_impl!( CheckedAdd, checked_add, u32 );
                checked_impl!( CheckedAdd, checked_add, u64 );
                checked_impl!( CheckedAdd, checked_add, usize );
                checked_impl!( CheckedAdd, checked_add, u128 );

                checked_impl!( CheckedAdd, checked_add, i8 );
                checked_impl!( CheckedAdd, checked_add, i16 );
                checked_impl!( CheckedAdd, checked_add, i32 );
                checked_impl!( CheckedAdd, checked_add, i64 );
                checked_impl!( CheckedAdd, checked_add, isize );
                checked_impl!( CheckedAdd, checked_add, i128 );
                /// Performs subtraction, returning `None` if overflow occurred.
                pub trait CheckedSub: Sized + Sub<Self, Output = Self> {
                    /// Subtracts two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_sub( &self, v:&Self ) -> Option<Self>;
                }
                checked_impl!( CheckedSub, checked_sub, u8 );
                checked_impl!( CheckedSub, checked_sub, u16 );
                checked_impl!( CheckedSub, checked_sub, u32 );
                checked_impl!( CheckedSub, checked_sub, u64 );
                checked_impl!( CheckedSub, checked_sub, usize );
                checked_impl!( CheckedSub, checked_sub, u128 );

                checked_impl!( CheckedSub, checked_sub, i8 );
                checked_impl!( CheckedSub, checked_sub, i16 );
                checked_impl!( CheckedSub, checked_sub, i32 );
                checked_impl!( CheckedSub, checked_sub, i64 );
                checked_impl!( CheckedSub, checked_sub, isize );
                checked_impl!( CheckedSub, checked_sub, i128 );
                /// Performs multiplication, returning `None` if overflow occurred.
                pub trait CheckedMul: Sized + Mul<Self, Output = Self> {
                    /// Multiplies two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_mul( &self, v:&Self ) -> Option<Self>;
                }
                checked_impl!( CheckedMul, checked_mul, u8 );
                checked_impl!( CheckedMul, checked_mul, u16 );
                checked_impl!( CheckedMul, checked_mul, u32 );
                checked_impl!( CheckedMul, checked_mul, u64 );
                checked_impl!( CheckedMul, checked_mul, usize );
                checked_impl!( CheckedMul, checked_mul, u128 );

                checked_impl!( CheckedMul, checked_mul, i8 );
                checked_impl!( CheckedMul, checked_mul, i16 );
                checked_impl!( CheckedMul, checked_mul, i32 );
                checked_impl!( CheckedMul, checked_mul, i64 );
                checked_impl!( CheckedMul, checked_mul, isize );
                checked_impl!( CheckedMul, checked_mul, i128 );
                /// Performs division, returning `None` on division by zero or if overflow
                /// occurred.
                pub trait CheckedDiv: Sized + Div<Self, Output = Self> {
                    /// Divides two numbers, checking for overflow and division by
                    /// zero. If any of that happens, `None` is returned.
                    fn checked_div( &self, v:&Self ) -> Option<Self>;
                }
                checked_impl!( CheckedDiv, checked_div, u8 );
                checked_impl!( CheckedDiv, checked_div, u16 );
                checked_impl!( CheckedDiv, checked_div, u32 );
                checked_impl!( CheckedDiv, checked_div, u64 );
                checked_impl!( CheckedDiv, checked_div, usize );
                checked_impl!( CheckedDiv, checked_div, u128 );

                checked_impl!( CheckedDiv, checked_div, i8 );
                checked_impl!( CheckedDiv, checked_div, i16 );
                checked_impl!( CheckedDiv, checked_div, i32 );
                checked_impl!( CheckedDiv, checked_div, i64 );
                checked_impl!( CheckedDiv, checked_div, isize );
                checked_impl!( CheckedDiv, checked_div, i128 );
                /// Performs integral remainder, returning `None` on division by zero or if overflow occurred.
                pub trait CheckedRem: Sized + Rem<Self, Output = Self> {
                    /// Finds the remainder of dividing two numbers, checking for overflow and division by zero.
                    fn checked_rem( &self, v:&Self ) -> Option<Self>;
                }
                checked_impl!( CheckedRem, checked_rem, u8 );
                checked_impl!( CheckedRem, checked_rem, u16 );
                checked_impl!( CheckedRem, checked_rem, u32 );
                checked_impl!( CheckedRem, checked_rem, u64 );
                checked_impl!( CheckedRem, checked_rem, usize );
                checked_impl!( CheckedRem, checked_rem, u128 );

                checked_impl!( CheckedRem, checked_rem, i8 );
                checked_impl!( CheckedRem, checked_rem, i16 );
                checked_impl!( CheckedRem, checked_rem, i32 );
                checked_impl!( CheckedRem, checked_rem, i64 );
                checked_impl!( CheckedRem, checked_rem, isize );
                checked_impl!( CheckedRem, checked_rem, i128 );

                macro_rules! checked_impl_unary {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self ) -> Option<$t> {
                                <$t>::$method( *self )
                            }
                        }
                    };
                }
                /// Performs negation, returning `None` if the result can't be represented.
                pub trait CheckedNeg: Sized {
                    /// Negates a number, returning `None` for results that can't be represented, like signed `MIN`
                    /// values that can't be positive, or non-zero unsigned values that can't be negative.
                    fn checked_neg( &self ) -> Option<Self>;
                }
                checked_impl_unary!( CheckedNeg, checked_neg, u8 );
                checked_impl_unary!( CheckedNeg, checked_neg, u16 );
                checked_impl_unary!( CheckedNeg, checked_neg, u32 );
                checked_impl_unary!( CheckedNeg, checked_neg, u64 );
                checked_impl_unary!( CheckedNeg, checked_neg, usize );
                checked_impl_unary!( CheckedNeg, checked_neg, u128 );

                checked_impl_unary!( CheckedNeg, checked_neg, i8 );
                checked_impl_unary!( CheckedNeg, checked_neg, i16 );
                checked_impl_unary!( CheckedNeg, checked_neg, i32 );
                checked_impl_unary!( CheckedNeg, checked_neg, i64 );
                checked_impl_unary!( CheckedNeg, checked_neg, isize );
                checked_impl_unary!( CheckedNeg, checked_neg, i128 );
                /// Performs shift left, returning `None` on shifts larger than or equal to the type width.
                pub trait CheckedShl: Sized + Shl<u32, Output = Self> {
                    /// Checked shift left. Computes `self << rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    fn checked_shl( &self, rhs: u32 ) -> Option<Self>;
                }
                macro_rules! checked_shift_impl {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, rhs: u32 ) -> Option<$t> {
                                <$t>::$method( *self, rhs )
                            }
                        }
                    };
                }
                checked_shift_impl!( CheckedShl, checked_shl, u8 );
                checked_shift_impl!( CheckedShl, checked_shl, u16 );
                checked_shift_impl!( CheckedShl, checked_shl, u32 );
                checked_shift_impl!( CheckedShl, checked_shl, u64 );
                checked_shift_impl!( CheckedShl, checked_shl, usize );
                checked_shift_impl!( CheckedShl, checked_shl, u128 );

                checked_shift_impl!( CheckedShl, checked_shl, i8 );
                checked_shift_impl!( CheckedShl, checked_shl, i16 );
                checked_shift_impl!( CheckedShl, checked_shl, i32 );
                checked_shift_impl!( CheckedShl, checked_shl, i64 );
                checked_shift_impl!( CheckedShl, checked_shl, isize );
                checked_shift_impl!( CheckedShl, checked_shl, i128 );
                /// Performs shift right, returning `None` on shifts larger than or equal to the type width.
                pub trait CheckedShr: Sized + Shr<u32, Output = Self> {
                    /// Checked shift right.
                    fn checked_shr( &self, rhs: u32 ) -> Option<Self>;
                }
                checked_shift_impl!( CheckedShr, checked_shr, u8 );
                checked_shift_impl!( CheckedShr, checked_shr, u16 );
                checked_shift_impl!( CheckedShr, checked_shr, u32 );
                checked_shift_impl!( CheckedShr, checked_shr, u64 );
                checked_shift_impl!( CheckedShr, checked_shr, usize );
                checked_shift_impl!( CheckedShr, checked_shr, u128 );

                checked_shift_impl!( CheckedShr, checked_shr, i8 );
                checked_shift_impl!( CheckedShr, checked_shr, i16 );
                checked_shift_impl!( CheckedShr, checked_shr, i32 );
                checked_shift_impl!( CheckedShr, checked_shr, i64 );
                checked_shift_impl!( CheckedShr, checked_shr, isize );
                checked_shift_impl!( CheckedShr, checked_shr, i128 );

            }
            
            pub mod euclid
            {
                /*!
                */
                use ::
                {
                    ops::{Div, Rem},
                    *,
                };
                /*
                */
                pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {
                    /// Calculates Euclidean division, the matching method for `rem_euclid`.
                    fn div_euclid( &self, v:&Self ) -> Self;

                    /// Calculates the least nonnegative remainder of `self ( mod v )`.
                    fn rem_euclid( &self, v:&Self ) -> Self;

                    /// Returns both the quotient and remainder from Euclidean division.
                    fn div_rem_euclid( &self, v:&Self ) -> ( Self, Self ) {
                        ( self.div_euclid( v ), self.rem_euclid( v ) )
                    }
                }
                macro_rules! euclid_forward_impl 
                {
                    ( $( $t:ty )* ) => {$( 
                        impl Euclid for $t {
                            #[inline]
                            fn div_euclid( &self, v:&$t ) -> Self {
                                <$t>::div_euclid( *self, *v )
                            }
                            #[inline]
                            fn rem_euclid( &self, v:&$t ) -> Self {
                                <$t>::rem_euclid( *self, *v )
                            }
                        }
                    )*}
                }
                euclid_forward_impl!( isize i8 i16 i32 i64 i128 );
                euclid_forward_impl!( usize u8 u16 u32 u64 u128 );
                euclid_forward_impl!( f32 f64 );

                pub trait CheckedEuclid: Euclid
                {
                    /// Performs euclid division, returning `None` on division by zero or if overflow occurred.
                    fn checked_div_euclid( &self, v:&Self ) -> Option<Self>;

                    /// Finds the euclid remainder of dividing two numbers, returning `None` on
                    /// division by zero or if overflow occurred.
                    fn checked_rem_euclid( &self, v:&Self ) -> Option<Self>;

                    /// Returns both the quotient and remainder from checked Euclidean division,
                    /// returning `None` on division by zero or if overflow occurred.
                    fn checked_div_rem_euclid( &self, v:&Self ) -> Option<( Self, Self )> {
                        Some( ( self.checked_div_euclid( v )?, self.checked_rem_euclid( v )? ) )
                    }
                }
                macro_rules! checked_euclid_forward_impl 
                {
                    ( $( $t:ty )* ) => {$( 
                        impl CheckedEuclid for $t {
                            #[inline]
                            fn checked_div_euclid( &self, v:&$t ) -> Option<Self> {
                                <$t>::checked_div_euclid( *self, *v )
                            }
                            #[inline]
                            fn checked_rem_euclid( &self, v:&$t ) -> Option<Self> {
                                <$t>::checked_rem_euclid( *self, *v )
                            }
                        }
                    )*}
                }
                checked_euclid_forward_impl!( isize i8 i16 i32 i64 i128 );
                checked_euclid_forward_impl!( usize u8 u16 u32 u64 u128 );
            }
            
            pub mod inv
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                /// Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.
                pub trait Inv {
                    /// The result after applying the operator.
                    type Output;

                    /// Returns the multiplicative inverse of `self`.
                    fn inv( self ) -> Self::Output;
                }
                impl Inv for f32 {
                    type Output = f32;
                    #[inline] fn inv( self ) -> f32 {
                        1.0 / self
                    }
                }
                impl Inv for f64 {
                    type Output = f64;
                    #[inline] fn inv( self ) -> f64 {
                        1.0 / self
                    }
                }
                impl<'a> Inv for &'a f32 {
                    type Output = f32;
                    #[inline] fn inv( self ) -> f32 {
                        1.0 / *self
                    }
                }
                impl<'a> Inv for &'a f64 {
                    type Output = f64;
                    #[inline] fn inv( self ) -> f64 {
                        1.0 / *self
                    }
                }
            }
            
            pub mod mul_add
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                /// Fused multiply-add.
                pub trait MulAdd<A = Self, B = Self> 
                {
                    /// The resulting type after applying the fused multiply-add.
                    type Output;

                    /// Performs the fused multiply-add operation `( self * a ) + b`
                    fn mul_add( self, a: A, b: B ) -> Self::Output;
                }
                /// The fused multiply-add assignment operation `*self = ( *self * a ) + b`
                pub trait MulAddAssign<A = Self, B = Self> 
                {
                    /// Performs the fused multiply-add assignment operation `*self = ( *self * a ) + b`
                    fn mul_add_assign( &mut self, a: A, b: B );
                }
                
                impl MulAdd<f32, f32> for f32                    
                {
                    type Output = Self;

                    #[inline] fn mul_add( self, a: Self, b: Self ) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add( self, a, b )
                    }
                }
                
                impl MulAdd<f64, f64> for f64
                {
                    type Output = Self;

                    #[inline] fn mul_add( self, a: Self, b: Self ) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add( self, a, b )
                    }
                }
                macro_rules! mul_add_impl 
                {
                    ( $trait_name:ident for $( $t:ty )* ) => {$( 
                        impl $trait_name for $t {
                            type Output = Self;

                            #[inline]
                            fn mul_add( self, a: Self, b: Self ) -> Self::Output {
                                ( self * a ) + b
                            }
                        }
                    )*}
                }
                mul_add_impl!( MulAdd for isize i8 i16 i32 i64 i128 );
                mul_add_impl!( MulAdd for usize u8 u16 u32 u64 u128 );
                
                impl MulAddAssign<f32, f32> for f32
                {
                    #[inline] fn mul_add_assign( &mut self, a: Self, b: Self ) {
                        *self = <Self as ::num::traits::Float>::mul_add( *self, a, b )
                    }
                }
                
                impl MulAddAssign<f64, f64> for f64
                {
                    #[inline] fn mul_add_assign( &mut self, a: Self, b: Self ) {
                        *self = <Self as ::num::traits::Float>::mul_add( *self, a, b )
                    }
                }
                macro_rules! mul_add_assign_impl
                {
                    ( $trait_name:ident for $( $t:ty )* ) => {$( 
                        impl $trait_name for $t {
                            #[inline]
                            fn mul_add_assign( &mut self, a: Self, b: Self ) {
                                *self = ( *self * a ) + b
                            }
                        }
                    )*}
                }
                mul_add_assign_impl!( MulAddAssign for isize i8 i16 i32 i64 i128 );
                mul_add_assign_impl!( MulAddAssign for usize u8 u16 u32 u64 u128 );
            }
            
            pub mod overflowing
            {
                /*!
                */
                use ::
                {
                    ops::{Add, Mul, Sub},
                    *,
                };
                /*
                */
                macro_rules! overflowing_impl {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&Self ) -> ( Self, bool ) {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                }
                /// Performs addition with a flag for overflow.
                pub trait OverflowingAdd: Sized + Add<Self, Output = Self> {
                    /// Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_add( &self, v:&Self ) -> ( Self, bool );
                }
                overflowing_impl!( OverflowingAdd, overflowing_add, u8 );
                overflowing_impl!( OverflowingAdd, overflowing_add, u16 );
                overflowing_impl!( OverflowingAdd, overflowing_add, u32 );
                overflowing_impl!( OverflowingAdd, overflowing_add, u64 );
                overflowing_impl!( OverflowingAdd, overflowing_add, usize );
                overflowing_impl!( OverflowingAdd, overflowing_add, u128 );

                overflowing_impl!( OverflowingAdd, overflowing_add, i8 );
                overflowing_impl!( OverflowingAdd, overflowing_add, i16 );
                overflowing_impl!( OverflowingAdd, overflowing_add, i32 );
                overflowing_impl!( OverflowingAdd, overflowing_add, i64 );
                overflowing_impl!( OverflowingAdd, overflowing_add, isize );
                overflowing_impl!( OverflowingAdd, overflowing_add, i128 );
                /// Performs substraction with a flag for overflow.
                pub trait OverflowingSub: Sized + Sub<Self, Output = Self> {
                    /// Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_sub( &self, v:&Self ) -> ( Self, bool );
                }
                overflowing_impl!( OverflowingSub, overflowing_sub, u8 );
                overflowing_impl!( OverflowingSub, overflowing_sub, u16 );
                overflowing_impl!( OverflowingSub, overflowing_sub, u32 );
                overflowing_impl!( OverflowingSub, overflowing_sub, u64 );
                overflowing_impl!( OverflowingSub, overflowing_sub, usize );
                overflowing_impl!( OverflowingSub, overflowing_sub, u128 );

                overflowing_impl!( OverflowingSub, overflowing_sub, i8 );
                overflowing_impl!( OverflowingSub, overflowing_sub, i16 );
                overflowing_impl!( OverflowingSub, overflowing_sub, i32 );
                overflowing_impl!( OverflowingSub, overflowing_sub, i64 );
                overflowing_impl!( OverflowingSub, overflowing_sub, isize );
                overflowing_impl!( OverflowingSub, overflowing_sub, i128 );
                /// Performs multiplication with a flag for overflow.
                pub trait OverflowingMul: Sized + Mul<Self, Output = Self> {
                    /// Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_mul( &self, v:&Self ) -> ( Self, bool );
                }
                overflowing_impl!( OverflowingMul, overflowing_mul, u8 );
                overflowing_impl!( OverflowingMul, overflowing_mul, u16 );
                overflowing_impl!( OverflowingMul, overflowing_mul, u32 );
                overflowing_impl!( OverflowingMul, overflowing_mul, u64 );
                overflowing_impl!( OverflowingMul, overflowing_mul, usize );
                overflowing_impl!( OverflowingMul, overflowing_mul, u128 );

                overflowing_impl!( OverflowingMul, overflowing_mul, i8 );
                overflowing_impl!( OverflowingMul, overflowing_mul, i16 );
                overflowing_impl!( OverflowingMul, overflowing_mul, i32 );
                overflowing_impl!( OverflowingMul, overflowing_mul, i64 );
                overflowing_impl!( OverflowingMul, overflowing_mul, isize );
                overflowing_impl!( OverflowingMul, overflowing_mul, i128 );
            }
            
            pub mod saturating
            {
                /*!
                */
                use ::
                {
                    ops::{Add, Mul, Sub},
                    *,
                };
                /*
                */
                /// Saturating math operations. Deprecated.
                pub trait Saturating
                {
                    /// Saturating addition operator.
                    /// Returns a+b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_add( self, v: Self ) -> Self;

                    /// Saturating subtraction operator.
                    /// Returns a-b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_sub( self, v: Self ) -> Self;
                }
                macro_rules! deprecated_saturating_impl
                {
                    ( $trait_name:ident for $( $t:ty )* ) => {$( 
                        impl $trait_name for $t {
                            #[inline]
                            fn saturating_add( self, v: Self ) -> Self {
                                Self::saturating_add( self, v )
                            }
                            #[inline]
                            fn saturating_sub( self, v: Self ) -> Self {
                                Self::saturating_sub( self, v )
                            }
                        }
                    )*}
                }
                deprecated_saturating_impl!( Saturating for isize i8 i16 i32 i64 i128 );
                deprecated_saturating_impl!( Saturating for usize u8 u16 u32 u64 u128 );

                macro_rules! saturating_impl
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&Self ) -> Self {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                }
                /// Performs addition that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingAdd: Sized + Add<Self, Output = Self>
                {
                    /// Saturating addition. Computes `self + other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_add( &self, v:&Self ) -> Self;
                }
                saturating_impl!( SaturatingAdd, saturating_add, u8 );
                saturating_impl!( SaturatingAdd, saturating_add, u16 );
                saturating_impl!( SaturatingAdd, saturating_add, u32 );
                saturating_impl!( SaturatingAdd, saturating_add, u64 );
                saturating_impl!( SaturatingAdd, saturating_add, usize );
                saturating_impl!( SaturatingAdd, saturating_add, u128 );

                saturating_impl!( SaturatingAdd, saturating_add, i8 );
                saturating_impl!( SaturatingAdd, saturating_add, i16 );
                saturating_impl!( SaturatingAdd, saturating_add, i32 );
                saturating_impl!( SaturatingAdd, saturating_add, i64 );
                saturating_impl!( SaturatingAdd, saturating_add, isize );
                saturating_impl!( SaturatingAdd, saturating_add, i128 );
                /// Performs subtraction that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingSub: Sized + Sub<Self, Output = Self> 
                {
                    /// Saturating subtraction. Computes `self - other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_sub( &self, v:&Self ) -> Self;
                }
                saturating_impl!( SaturatingSub, saturating_sub, u8 );
                saturating_impl!( SaturatingSub, saturating_sub, u16 );
                saturating_impl!( SaturatingSub, saturating_sub, u32 );
                saturating_impl!( SaturatingSub, saturating_sub, u64 );
                saturating_impl!( SaturatingSub, saturating_sub, usize );
                saturating_impl!( SaturatingSub, saturating_sub, u128 );

                saturating_impl!( SaturatingSub, saturating_sub, i8 );
                saturating_impl!( SaturatingSub, saturating_sub, i16 );
                saturating_impl!( SaturatingSub, saturating_sub, i32 );
                saturating_impl!( SaturatingSub, saturating_sub, i64 );
                saturating_impl!( SaturatingSub, saturating_sub, isize );
                saturating_impl!( SaturatingSub, saturating_sub, i128 );
                /// Performs multiplication that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingMul: Sized + Mul<Self, Output = Self> 
                {
                    /// Saturating multiplication. Computes `self * other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_mul( &self, v:&Self ) -> Self;
                }
                saturating_impl!( SaturatingMul, saturating_mul, u8 );
                saturating_impl!( SaturatingMul, saturating_mul, u16 );
                saturating_impl!( SaturatingMul, saturating_mul, u32 );
                saturating_impl!( SaturatingMul, saturating_mul, u64 );
                saturating_impl!( SaturatingMul, saturating_mul, usize );
                saturating_impl!( SaturatingMul, saturating_mul, u128 );

                saturating_impl!( SaturatingMul, saturating_mul, i8 );
                saturating_impl!( SaturatingMul, saturating_mul, i16 );
                saturating_impl!( SaturatingMul, saturating_mul, i32 );
                saturating_impl!( SaturatingMul, saturating_mul, i64 );
                saturating_impl!( SaturatingMul, saturating_mul, isize );
                saturating_impl!( SaturatingMul, saturating_mul, i128 );
            }
            
            pub mod wrapping
            {
                /*!
                */
                use ::
                {
                    num::{ Wrapping },
                    ops::{ Add, Mul, Neg, Shl, Shr, Sub },
                    *,
                };
                /*
                */
                macro_rules! wrapping_impl
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&Self ) -> Self {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                    ( $trait_name:ident, $method:ident, $t:ty, $rhs:ty ) => {
                        impl $trait_name<$rhs> for $t {
                            #[inline]
                            fn $method( &self, v:&$rhs ) -> Self {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                }
                /// Performs addition that wraps around on overflow.
                pub trait WrappingAdd: Sized + Add<Self, Output = Self>
                {
                    /// Wrapping ( modular ) addition. Computes `self + other`, wrapping around at the boundary of
                    /// the type.
                    fn wrapping_add( &self, v:&Self ) -> Self;
                }
                wrapping_impl!( WrappingAdd, wrapping_add, u8 );
                wrapping_impl!( WrappingAdd, wrapping_add, u16 );
                wrapping_impl!( WrappingAdd, wrapping_add, u32 );
                wrapping_impl!( WrappingAdd, wrapping_add, u64 );
                wrapping_impl!( WrappingAdd, wrapping_add, usize );
                wrapping_impl!( WrappingAdd, wrapping_add, u128 );

                wrapping_impl!( WrappingAdd, wrapping_add, i8 );
                wrapping_impl!( WrappingAdd, wrapping_add, i16 );
                wrapping_impl!( WrappingAdd, wrapping_add, i32 );
                wrapping_impl!( WrappingAdd, wrapping_add, i64 );
                wrapping_impl!( WrappingAdd, wrapping_add, isize );
                wrapping_impl!( WrappingAdd, wrapping_add, i128 );
                /// Performs subtraction that wraps around on overflow.
                pub trait WrappingSub: Sized + Sub<Self, Output = Self>
                {
                    /// Wrapping ( modular ) subtraction. Computes `self - other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_sub( &self, v:&Self ) -> Self;
                }
                wrapping_impl!( WrappingSub, wrapping_sub, u8 );
                wrapping_impl!( WrappingSub, wrapping_sub, u16 );
                wrapping_impl!( WrappingSub, wrapping_sub, u32 );
                wrapping_impl!( WrappingSub, wrapping_sub, u64 );
                wrapping_impl!( WrappingSub, wrapping_sub, usize );
                wrapping_impl!( WrappingSub, wrapping_sub, u128 );

                wrapping_impl!( WrappingSub, wrapping_sub, i8 );
                wrapping_impl!( WrappingSub, wrapping_sub, i16 );
                wrapping_impl!( WrappingSub, wrapping_sub, i32 );
                wrapping_impl!( WrappingSub, wrapping_sub, i64 );
                wrapping_impl!( WrappingSub, wrapping_sub, isize );
                wrapping_impl!( WrappingSub, wrapping_sub, i128 );
                /// Performs multiplication that wraps around on overflow.
                pub trait WrappingMul: Sized + Mul<Self, Output = Self>
                {
                    /// Wrapping ( modular ) multiplication. Computes `self * other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_mul( &self, v:&Self ) -> Self;
                }
                wrapping_impl!( WrappingMul, wrapping_mul, u8 );
                wrapping_impl!( WrappingMul, wrapping_mul, u16 );
                wrapping_impl!( WrappingMul, wrapping_mul, u32 );
                wrapping_impl!( WrappingMul, wrapping_mul, u64 );
                wrapping_impl!( WrappingMul, wrapping_mul, usize );
                wrapping_impl!( WrappingMul, wrapping_mul, u128 );

                wrapping_impl!( WrappingMul, wrapping_mul, i8 );
                wrapping_impl!( WrappingMul, wrapping_mul, i16 );
                wrapping_impl!( WrappingMul, wrapping_mul, i32 );
                wrapping_impl!( WrappingMul, wrapping_mul, i64 );
                wrapping_impl!( WrappingMul, wrapping_mul, isize );
                wrapping_impl!( WrappingMul, wrapping_mul, i128 );

                macro_rules! wrapping_unary_impl 
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self ) -> $t {
                                <$t>::$method( *self )
                            }
                        }
                    };
                }
                /// Performs a negation that does not panic.
                pub trait WrappingNeg: Sized 
                {
                    /// Wrapping ( modular ) negation. Computes `-self`,
                    /// wrapping around at the boundary of the type.
                    fn wrapping_neg( &self ) -> Self;
                }
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u8 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u16 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u32 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u64 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, usize );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u128 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i8 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i16 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i32 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i64 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, isize );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i128 );

                macro_rules! wrapping_shift_impl 
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, rhs: u32 ) -> $t {
                                <$t>::$method( *self, rhs )
                            }
                        }
                    };
                }
                /// Performs a left shift that does not panic.
                pub trait WrappingShl: Sized + Shl<usize, Output = Self> 
                {
                    /// Panic-free bitwise shift-left; yields `self << mask( rhs )`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    fn wrapping_shl( &self, rhs: u32 ) -> Self;
                }
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u8 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u16 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u32 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u64 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, usize );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u128 );

                wrapping_shift_impl!( WrappingShl, wrapping_shl, i8 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i16 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i32 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i64 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, isize );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i128 );
                /// Performs a right shift that does not panic.
                pub trait WrappingShr: Sized + Shr<usize, Output = Self> 
                {
                    /// Panic-free bitwise shift-right; yields `self >> mask( rhs )`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    fn wrapping_shr( &self, rhs: u32 ) -> Self;
                }
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u8 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u16 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u32 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u64 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, usize );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u128 );

                wrapping_shift_impl!( WrappingShr, wrapping_shr, i8 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i16 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i32 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i64 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, isize );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i128 );
               
                impl<T: WrappingAdd> WrappingAdd for Wrapping<T> where
                    Wrapping<T>: Add<Output = Wrapping<T>>,
                {
                    fn wrapping_add( &self, v:&Self ) -> Self {
                        Wrapping( self.0.wrapping_add( &v.0 ) )
                    }
                }
                
                impl<T: WrappingSub> WrappingSub for Wrapping<T> where
                    Wrapping<T>: Sub<Output = Wrapping<T>>,
                {
                    fn wrapping_sub( &self, v:&Self ) -> Self {
                        Wrapping( self.0.wrapping_sub( &v.0 ) )
                    }
                }
                impl<T: WrappingMul> WrappingMul for Wrapping<T> where
                    Wrapping<T>: Mul<Output = Wrapping<T>>,
                {
                    fn wrapping_mul( &self, v:&Self ) -> Self {
                        Wrapping( self.0.wrapping_mul( &v.0 ) )
                    }
                }
                impl<T: WrappingNeg> WrappingNeg for Wrapping<T> where
                    Wrapping<T>: Neg<Output = Wrapping<T>>,
                {
                    fn wrapping_neg( &self ) -> Self {
                        Wrapping( self.0.wrapping_neg() )
                    }
                }
                impl<T: WrappingShl> WrappingShl for Wrapping<T> where
                    Wrapping<T>: Shl<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shl( &self, rhs: u32 ) -> Self {
                        Wrapping( self.0.wrapping_shl( rhs ) )
                    }
                }
                impl<T: WrappingShr> WrappingShr for Wrapping<T> where
                    Wrapping<T>: Shr<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shr( &self, rhs: u32 ) -> Self {
                        Wrapping( self.0.wrapping_shr( rhs ) )
                    }
                }
            }
        } pub use self::ops::
        {
            bytes::{ FromBytes, ToBytes },
            checked::{ CheckedAdd, CheckedDiv, CheckedMul, CheckedNeg, CheckedRem, CheckedShl, CheckedShr, CheckedSub },
            euclid::{ CheckedEuclid, Euclid },
            inv::{ Inv },
            mul_add::{ MulAdd, MulAddAssign },
            saturating::{ Saturating, SaturatingAdd, SaturatingMul, SaturatingSub },
            wrapping::{ WrappingAdd, WrappingMul, WrappingNeg, WrappingShl, WrappingShr, WrappingSub },
        };

        pub mod pow
        {
            use ::
            {
                num::
                {
                    traits::{ CheckedMul, One, Float }, Wrapping
                },
                ops::{ Mul },
                *,
            };
            /*
            */
            /// Binary operator for raising a value to a power.
            pub trait Pow<RHS>
            {
                /// The result after applying the operator.
                type Output;
                /// Returns `self` to the power `rhs`.
                fn pow( self, rhs: RHS ) -> Self::Output;
            }
            macro_rules! pow_impl {
                ( $t:ty ) =>
                {
                    pow_impl!( $t, u8 );
                    pow_impl!( $t, usize );
                };
                ( $t:ty, $rhs:ty ) => {
                    pow_impl!( $t, $rhs, usize, pow );
                };
                ( $t:ty, $rhs:ty, $desired_rhs:ty, $method:expr ) => {
                    impl Pow<$rhs> for $t {
                        type Output = $t;
                        #[inline]
                        fn pow( self, rhs: $rhs ) -> $t {
                            ( $method )( self, <$desired_rhs>::from( rhs ) )
                        }
                    }
                    impl<'a> Pow<&'a $rhs> for $t {
                        type Output = $t;
                        #[inline]
                        fn pow( self, rhs:&'a $rhs ) -> $t {
                            ( $method )( self, <$desired_rhs>::from( *rhs ) )
                        }
                    }
                    impl<'a> Pow<$rhs> for &'a $t {
                        type Output = $t;
                        #[inline]
                        fn pow( self, rhs: $rhs ) -> $t {
                            ( $method )( *self, <$desired_rhs>::from( rhs ) )
                        }
                    }
                    impl<'a, 'b> Pow<&'a $rhs> for &'b $t {
                        type Output = $t;
                        #[inline]
                        fn pow( self, rhs:&'a $rhs ) -> $t {
                            ( $method )( *self, <$desired_rhs>::from( *rhs ) )
                        }
                    }
                };
            }
            pow_impl!( u8, u8, u32, u8::pow );
            pow_impl!( u8, u16, u32, u8::pow );
            pow_impl!( u8, u32, u32, u8::pow );
            pow_impl!( u8, usize );
            pow_impl!( i8, u8, u32, i8::pow );
            pow_impl!( i8, u16, u32, i8::pow );
            pow_impl!( i8, u32, u32, i8::pow );
            pow_impl!( i8, usize );
            pow_impl!( u16, u8, u32, u16::pow );
            pow_impl!( u16, u16, u32, u16::pow );
            pow_impl!( u16, u32, u32, u16::pow );
            pow_impl!( u16, usize );
            pow_impl!( i16, u8, u32, i16::pow );
            pow_impl!( i16, u16, u32, i16::pow );
            pow_impl!( i16, u32, u32, i16::pow );
            pow_impl!( i16, usize );
            pow_impl!( u32, u8, u32, u32::pow );
            pow_impl!( u32, u16, u32, u32::pow );
            pow_impl!( u32, u32, u32, u32::pow );
            pow_impl!( u32, usize );
            pow_impl!( i32, u8, u32, i32::pow );
            pow_impl!( i32, u16, u32, i32::pow );
            pow_impl!( i32, u32, u32, i32::pow );
            pow_impl!( i32, usize );
            pow_impl!( u64, u8, u32, u64::pow );
            pow_impl!( u64, u16, u32, u64::pow );
            pow_impl!( u64, u32, u32, u64::pow );
            pow_impl!( u64, usize );
            pow_impl!( i64, u8, u32, i64::pow );
            pow_impl!( i64, u16, u32, i64::pow );
            pow_impl!( i64, u32, u32, i64::pow );
            pow_impl!( i64, usize );

            pow_impl!( u128, u8, u32, u128::pow );
            pow_impl!( u128, u16, u32, u128::pow );
            pow_impl!( u128, u32, u32, u128::pow );
            pow_impl!( u128, usize );

            pow_impl!( i128, u8, u32, i128::pow );
            pow_impl!( i128, u16, u32, i128::pow );
            pow_impl!( i128, u32, u32, i128::pow );
            pow_impl!( i128, usize );

            pow_impl!( usize, u8, u32, usize::pow );
            pow_impl!( usize, u16, u32, usize::pow );
            pow_impl!( usize, u32, u32, usize::pow );
            pow_impl!( usize, usize );
            pow_impl!( isize, u8, u32, isize::pow );
            pow_impl!( isize, u16, u32, isize::pow );
            pow_impl!( isize, u32, u32, isize::pow );
            pow_impl!( isize, usize );
            pow_impl!( Wrapping<u8> );
            pow_impl!( Wrapping<i8> );
            pow_impl!( Wrapping<u16> );
            pow_impl!( Wrapping<i16> );
            pow_impl!( Wrapping<u32> );
            pow_impl!( Wrapping<i32> );
            pow_impl!( Wrapping<u64> );
            pow_impl!( Wrapping<i64> );
            pow_impl!( Wrapping<u128> );
            pow_impl!( Wrapping<i128> );
            pow_impl!( Wrapping<usize> );
            pow_impl!( Wrapping<isize> );

            pow_impl!( f32, i8, i32, <f32 as Float>::powi );
            pow_impl!( f32, u8, i32, <f32 as Float>::powi );
            pow_impl!( f32, i16, i32, <f32 as Float>::powi );
            pow_impl!( f32, u16, i32, <f32 as Float>::powi );
            pow_impl!( f32, i32, i32, <f32 as Float>::powi );
            pow_impl!( f64, i8, i32, <f64 as Float>::powi );
            pow_impl!( f64, u8, i32, <f64 as Float>::powi );
            pow_impl!( f64, i16, i32, <f64 as Float>::powi );
            pow_impl!( f64, u16, i32, <f64 as Float>::powi );
            pow_impl!( f64, i32, i32, <f64 as Float>::powi );
            pow_impl!( f32, f32, f32, <f32 as Float>::powf );
            pow_impl!( f64, f32, f64, <f64 as Float>::powf );
            pow_impl!( f64, f64, f64, <f64 as Float>::powf );            
            /// Raises a value to the power of exp, using exponentiation by squaring.
            #[inline] pub fn pow<T: Clone + One + Mul<T, Output = T>>( mut base: T, mut exp: usize ) -> T 
            {
                if exp == 0 {
                    return T::one();
                }
                while exp & 1 == 0 {
                    base = base.clone() * base;
                    exp >>= 1;
                }
                if exp == 1 {
                    return base;
                }
                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.clone() * base;
                    if exp & 1 == 1 {
                        acc = acc * base.clone();
                    }
                }
                acc
            }
            /// Raises a value to the power of exp, returning `None` if an overflow occurred.
            #[inline] pub fn checked_pow<T: Clone + One + CheckedMul>( mut base: T, mut exp: usize ) -> Option<T> 
            {
                if exp == 0 {
                    return Some( T::one() );
                }
                while exp & 1 == 0 {
                    base = base.checked_mul( &base )?;
                    exp >>= 1;
                }
                if exp == 1 {
                    return Some( base );
                }
                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.checked_mul( &base )?;
                    if exp & 1 == 1 {
                        acc = acc.checked_mul( &base )?;
                    }
                }
                Some( acc )
            }

        } pub use self::pow::{checked_pow, pow, Pow};

        pub mod real
        {
            use ::
            {
                num::traits::{Float, Num, NumCast},
                ops::{ Neg },
                *,
            };
            /*
            */
            /// A trait for real number types that do not necessarily have
            /// floating-point-specific characteristics such as NaN and infinity.
            pub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self>
            {
                /// Returns the smallest finite value that this type can represent.
                fn min_value() -> Self;
                /// Returns the smallest positive, normalized value that this type can represent.
                fn min_positive_value() -> Self;
                /// Returns epsilon, a small positive value.
                fn epsilon() -> Self;
                /// Returns the largest finite value that this type can represent.
                fn max_value() -> Self;
                /// Returns the largest integer less than or equal to a number.
                fn floor( self ) -> Self;
                /// Returns the smallest integer greater than or equal to a number.
                fn ceil( self ) -> Self;
                /// Returns the nearest integer to a number.
                fn round( self ) -> Self;
                /// Return the integer part of a number.
                fn trunc( self ) -> Self;
                /// Returns the fractional part of a number.
                fn fract( self ) -> Self;
                /// Computes the absolute value of `self`.
                fn abs( self ) -> Self;
                /// Returns a number that represents the sign of `self`.
                fn signum( self ) -> Self;
                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and with newer versions of Rust `f64::NAN`.
                fn is_sign_positive( self ) -> bool;
                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.
                fn is_sign_negative( self ) -> bool;
                /// Fused multiply-add.
                fn mul_add( self, a: Self, b: Self ) -> Self;
                /// Take the reciprocal ( inverse ) of a number, `1/x`.
                fn recip( self ) -> Self;
                /// Raise a number to an integer power.
                fn powi( self, n: i32 ) -> Self;
                /// Raise a number to a real number power.
                fn powf( self, n: Self ) -> Self;
                /// Take the square root of a number.
                fn sqrt( self ) -> Self;
                /// Returns `e^( self )`, ( the exponential function ).
                fn exp( self ) -> Self;
                /// Returns `2^( self )`.
                fn exp2( self ) -> Self;
                /// Returns the natural logarithm of the number.
                fn ln( self ) -> Self;
                /// Returns the logarithm of the number with respect to an arbitrary base.
                fn log( self, base: Self ) -> Self;
                /// Returns the base 2 logarithm of the number.
                fn log2( self ) -> Self;
                /// Returns the base 10 logarithm of the number.
                fn log10( self ) -> Self;
                /// Converts radians to degrees.
                fn to_degrees( self ) -> Self;
                /// Converts degrees to radians.
                fn to_radians( self ) -> Self;
                /// Returns the maximum of the two numbers.
                fn max( self, other: Self ) -> Self;
                /// Returns the minimum of the two numbers.
                fn min( self, other: Self ) -> Self;
                /// The positive difference of two numbers.
                fn abs_sub( self, other: Self ) -> Self;
                /// Take the cubic root of a number.
                fn cbrt( self ) -> Self;
                /// Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.
                fn hypot( self, other: Self ) -> Self;
                /// Computes the sine of a number ( in radians ).
                fn sin( self ) -> Self;
                /// Computes the cosine of a number ( in radians ).
                fn cos( self ) -> Self;
                /// Computes the tangent of a number ( in radians ).
                fn tan( self ) -> Self;
                /// Computes the arcsine of a number.
                fn asin( self ) -> Self;
                /// Computes the arccosine of a number.
                fn acos( self ) -> Self;
                /// Computes the arctangent of a number.
                fn atan( self ) -> Self;
                /// Computes the four quadrant arctangent of `self` ( `y` ) and `other` ( `x` ).
                fn atan2( self, other: Self ) -> Self;
                /// Simultaneously computes the sine and cosine of the number, `x`.
                fn sin_cos( self ) -> ( Self, Self );
                /// Returns `e^( self ) - 1` in a way that is accurate even if the number is close to zero.
                fn exp_m1( self ) -> Self;
                /// Returns `ln( 1+n )` more accurately than if the operations were performed separately.
                fn ln_1p( self ) -> Self;
                /// Hyperbolic sine function.
                fn sinh( self ) -> Self;
                /// Hyperbolic cosine function.
                fn cosh( self ) -> Self;
                /// Hyperbolic tangent function.
                fn tanh( self ) -> Self;
                /// Inverse hyperbolic sine function.
                fn asinh( self ) -> Self;
                /// Inverse hyperbolic cosine function.
                fn acosh( self ) -> Self;
                /// Inverse hyperbolic tangent function.
                fn atanh( self ) -> Self;
            }
            
            impl<T: Float> Real for T
            {
                forward! {
                    Float::min_value() -> Self;
                    Float::min_positive_value() -> Self;
                    Float::epsilon() -> Self;
                    Float::max_value() -> Self;
                }
                forward! {
                    Float::floor( self ) -> Self;
                    Float::ceil( self ) -> Self;
                    Float::round( self ) -> Self;
                    Float::trunc( self ) -> Self;
                    Float::fract( self ) -> Self;
                    Float::abs( self ) -> Self;
                    Float::signum( self ) -> Self;
                    Float::is_sign_positive( self ) -> bool;
                    Float::is_sign_negative( self ) -> bool;
                    Float::mul_add( self, a: Self, b: Self ) -> Self;
                    Float::recip( self ) -> Self;
                    Float::powi( self, n: i32 ) -> Self;
                    Float::powf( self, n: Self ) -> Self;
                    Float::sqrt( self ) -> Self;
                    Float::exp( self ) -> Self;
                    Float::exp2( self ) -> Self;
                    Float::ln( self ) -> Self;
                    Float::log( self, base: Self ) -> Self;
                    Float::log2( self ) -> Self;
                    Float::log10( self ) -> Self;
                    Float::to_degrees( self ) -> Self;
                    Float::to_radians( self ) -> Self;
                    Float::max( self, other: Self ) -> Self;
                    Float::min( self, other: Self ) -> Self;
                    Float::abs_sub( self, other: Self ) -> Self;
                    Float::cbrt( self ) -> Self;
                    Float::hypot( self, other: Self ) -> Self;
                    Float::sin( self ) -> Self;
                    Float::cos( self ) -> Self;
                    Float::tan( self ) -> Self;
                    Float::asin( self ) -> Self;
                    Float::acos( self ) -> Self;
                    Float::atan( self ) -> Self;
                    Float::atan2( self, other: Self ) -> Self;
                    Float::sin_cos( self ) -> ( Self, Self );
                    Float::exp_m1( self ) -> Self;
                    Float::ln_1p( self ) -> Self;
                    Float::sinh( self ) -> Self;
                    Float::cosh( self ) -> Self;
                    Float::tanh( self ) -> Self;
                    Float::asinh( self ) -> Self;
                    Float::acosh( self ) -> Self;
                    Float::atanh( self ) -> Self;
                }
            }
        }

        pub mod sign
        {
            use ::
            {
                num::
                {
                    traits::{ float::{ Float, FloatCore }, Num }, Wrapping
                },
                ops::{ Neg },
                *,
            };
            /*
            */
            /// Useful functions for signed numbers ( i.e. numbers that can be negative ).
            pub trait Signed: Sized + Num + Neg<Output = Self>
            {
                /// Computes the absolute value.
                fn abs( &self ) -> Self;
                /// The positive difference of two numbers.
                fn abs_sub( &self, other:&Self ) -> Self;
                /// Returns the sign of the number.
                /// * `-1` if the number is negative
                fn signum( &self ) -> Self;
                /// Returns true if the number is positive and false if the number is zero or negative.
                fn is_positive( &self ) -> bool;
                /// Returns true if the number is negative and false if the number is zero or positive.
                fn is_negative( &self ) -> bool;
            }
            macro_rules! signed_impl {
                ( $( $t:ty )* ) => ( $( 
                    impl Signed for $t {
                        #[inline]
                        fn abs( &self ) -> $t {
                            if self.is_negative() { -*self } else { *self }
                        }
                        #[inline]
                        fn abs_sub( &self, other:&$t ) -> $t {
                            if *self <= *other { 0 } else { *self - *other }
                        }
                        #[inline]
                        fn signum( &self ) -> $t {
                            match *self {
                                n if n > 0 => 1,
                                0 => 0,
                                _ => -1,
                            }
                        }
                        #[inline]
                        fn is_positive( &self ) -> bool { *self > 0 }
                        #[inline]
                        fn is_negative( &self ) -> bool { *self < 0 }
                    }
                )* )
            }
            signed_impl!( isize i8 i16 i32 i64 i128 );

            impl<T: Signed> Signed for Wrapping<T> where
                Wrapping<T>: Num + Neg<Output = Wrapping<T>>,
            {
                #[inline] fn abs( &self ) -> Self {
                    Wrapping( self.0.abs() )
                }
                #[inline] fn abs_sub( &self, other:&Self ) -> Self {
                    Wrapping( self.0.abs_sub( &other.0 ) )
                }
                #[inline] fn signum( &self ) -> Self {
                    Wrapping( self.0.signum() )
                }
                #[inline] fn is_positive( &self ) -> bool {
                    self.0.is_positive()
                }
                #[inline] fn is_negative( &self ) -> bool {
                    self.0.is_negative()
                }
            }
            macro_rules! signed_float_impl {
                ( $t:ty ) => {
                    impl Signed for $t {
                        /// Computes the absolute value. Returns `NAN` if the number is `NAN`.
                        #[inline]
                        fn abs( &self ) -> $t {
                            Float::abs( *self )
                        }
                        /// The positive difference of two numbers. Returns `0.0` if the number is
                        /// less than or equal to `other`, otherwise the difference between`self`
                        /// and `other` is returned.
                        #[inline]
                        fn abs_sub( &self, other:&$t ) -> $t {
                            if *self <= *other {
                                0.
                            } else {
                                *self - *other
                            }
                        }
                        /// # Returns
                        ///
                        /// - `1.0` if the number is positive, `+0.0` or `INFINITY`
                        /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                        /// - `NAN` if the number is NaN
                        #[inline]
                        fn signum( &self ) -> $t {
                            Float::signum( *self )
                        }
                        /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`
                        #[inline]
                        fn is_positive( &self ) -> bool {
                            Float::is_sign_positive( *self )
                        }
                        /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`
                        #[inline]
                        fn is_negative( &self ) -> bool {
                            Float::is_sign_negative( *self )
                        }
                    }
                };
            }
            signed_float_impl!( f32 );
            signed_float_impl!( f64 );
            /// Computes the absolute value.
            #[inline( always )] pub fn abs<T: Signed>( value: T ) -> T {
                value.abs()
            }
            /// The positive difference of two numbers.
            #[inline( always )] pub fn abs_sub<T: Signed>( x: T, y: T ) -> T {
                x.abs_sub( &y )
            }
            /// Returns the sign of the number.
            #[inline( always )] pub fn signum<T: Signed>( value: T ) -> T {
                value.signum()
            }
            /// A trait for values which cannot be negative
            pub trait Unsigned: Num {}
            macro_rules! empty_trait_impl
            {
                ( $name:ident for $( $t:ty )* ) => ( $( 
                    impl $name for $t {}
                )* )
            }
            empty_trait_impl!( Unsigned for usize u8 u16 u32 u64 u128 );

            impl<T: Unsigned> Unsigned for Wrapping<T> where Wrapping<T>: Num {}
        } pub use self::sign::{abs, abs_sub, signum, Signed, Unsigned};
        /// The base trait for numeric types, covering `0` and `1` values,
        /// comparisons, basic numeric operations, and string conversion.
        pub trait Num: PartialEq + Zero + One + NumOps
        {
            type FromStrRadixErr;
            /// Convert from a string and radix ( typically `2..=36` ).
            fn from_str_radix( str:&str, radix: u32 ) -> Result<Self, Self::FromStrRadixErr>;
        }
        /// Generic trait for types implementing basic numeric operations.
        pub trait NumOps<Rhs = Self, Output = Self>:
            Add<Rhs, Output = Output>
            + Sub<Rhs, Output = Output>
            + Mul<Rhs, Output = Output>
            + Div<Rhs, Output = Output>
            + Rem<Rhs, Output = Output>
        {
        }

        impl<T, Rhs, Output> NumOps<Rhs, Output> for T where
            T: Add<Rhs, Output = Output>
                + Sub<Rhs, Output = Output>
                + Mul<Rhs, Output = Output>
                + Div<Rhs, Output = Output>
                + Rem<Rhs, Output = Output>
        {
        }
        /// The trait for `Num` types which also implement numeric operations taking the second operand by reference.
        pub trait NumRef: Num + for<'r> NumOps<&'r Self> {}
        impl<T> NumRef for T where T: Num + for<'r> NumOps<&'r T> {}
        /// Trait for `Num` references which implement numeric operations, taking the second operand either by value or by reference.
        pub trait RefNum<Base>: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        impl<T, Base> RefNum<Base> for T where T: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        /// Generic trait for types implementing numeric assignment operators ( like `+=` ).
        pub trait NumAssignOps<Rhs = Self>:
        AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }

        impl<T, Rhs> NumAssignOps<Rhs> for T where
            T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }
        /// The trait for `Num` types which also implement assignment operators.
        pub trait NumAssign: Num + NumAssignOps {}
        impl<T> NumAssign for T where T: Num + NumAssignOps {}
        /// Trait for `NumAssign` types which also implement assignment operations taking the second operand by reference.
        pub trait NumAssignRef: NumAssign + for<'r> NumAssignOps<&'r Self> {}
        impl<T> NumAssignRef for T where T: NumAssign + for<'r> NumAssignOps<&'r T> {}

        macro_rules! int_trait_impl
        {
            ( $name:ident for $( $t:ty )* ) => ( $( 
                impl $name for $t {
                    type FromStrRadixErr = ::num::ParseIntError;
                    #[inline] fn from_str_radix( s:&str, radix: u32 )
                                    -> Result<Self, ::num::ParseIntError>
                    {
                        <$t>::from_str_radix( s, radix )
                    }
                }
            )* )
        }

        int_trait_impl!( Num for usize u8 u16 u32 u64 u128 );
        int_trait_impl!( Num for isize i8 i16 i32 i64 i128 );

        impl<T: Num> Num for Wrapping<T> where
            Wrapping<T>: NumOps,
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix( str:&str, radix: u32 ) -> Result<Self, Self::FromStrRadixErr> {
                T::from_str_radix( str, radix ).map( Wrapping )
            }
        }
        
        #[derive( Debug )]
        pub enum FloatErrorKind
        {
            Empty,
            Invalid,
        }
        
        #[derive( Debug )]
        pub struct ParseFloatError
        {
            pub kind: FloatErrorKind,
        }

        impl fmt::Display for ParseFloatError
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {let description = match self.kind {
                    FloatErrorKind::Empty => "cannot parse float from empty string",
                    FloatErrorKind::Invalid => "invalid float literal",
                };

                description.fmt( f )
            }
        }

        fn str_to_ascii_lower_eq_str( a:&str, b:&str ) -> bool
        {
            a.len() == b.len()
                && a.bytes().zip( b.bytes() ).all( |( a, b )| {
                    let a_to_ascii_lower = a | ( ( ( b'A' <= a && a <= b'Z' ) as u8 ) << 5 );
                    a_to_ascii_lower == b
                } )
        }
        
        macro_rules! float_trait_impl
        {
            ( $name:ident for $( $t:ident )* ) => ( $( 
                impl $name for $t {
                    type FromStrRadixErr = ParseFloatError;

                    fn from_str_radix( src:&str, radix: u32 )
                                    -> Result<Self, Self::FromStrRadixErr>
                    {
                        use self::FloatErrorKind::*;
                        use self::ParseFloatError as PFE;

                       
                        if radix == 10 {
                            return src.parse().map_err( |_| PFE {
                                kind: if src.is_empty() { Empty } else { Invalid },
                            } );
                        }
                       
                        if str_to_ascii_lower_eq_str( src, "inf" )
                            || str_to_ascii_lower_eq_str( src, "infinity" )
                        {
                            return Ok( ::$t::INFINITY );
                        } else if str_to_ascii_lower_eq_str( src, "-inf" )
                            || str_to_ascii_lower_eq_str( src, "-infinity" )
                        {
                            return Ok( ::$t::NEG_INFINITY );
                        } else if str_to_ascii_lower_eq_str( src, "nan" ) {
                            return Ok( ::$t::NAN );
                        } else if str_to_ascii_lower_eq_str( src, "-nan" ) {
                            return Ok( -::$t::NAN );
                        }
                        fn slice_shift_char( src:&str ) -> Option<( char, &str )> {
                            let mut chars = src.chars();
                            Some( ( chars.next()?, chars.as_str() ) )
                        }
                        let ( is_positive, src ) =  match slice_shift_char( src ) {
                            None             => return Err( PFE { kind: Empty } ),
                            Some( ( '-', "" ) )  => return Err( PFE { kind: Empty } ),
                            Some( ( '-', src ) ) => ( false, src ),
                            Some( ( _, _ ) )     => ( true,  src ),
                        };

                       
                        let mut sig = if is_positive { 0.0 } else { -0.0 };
                       
                        let mut prev_sig = sig;
                        let mut cs = src.chars().enumerate();
                       
                        let mut exp_info = None::<( char, usize )>;

                       
                        for ( i, c ) in cs.by_ref() {
                            match c.to_digit( radix ) {
                                Some( digit ) => {
                                   
                                    sig *= radix as $t;

                                   
                                    if is_positive {
                                        sig += ( digit as isize ) as $t;
                                    } else {
                                        sig -= ( digit as isize ) as $t;
                                    }
                                   
                                   
                                    if prev_sig != 0.0 {
                                        if is_positive && sig <= prev_sig
                                            { return Ok( ::$t::INFINITY ); }
                                        if !is_positive && sig >= prev_sig
                                            { return Ok( ::$t::NEG_INFINITY ); }
                                       
                                        if is_positive && ( prev_sig != ( sig - digit as $t ) / radix as $t )
                                            { return Ok( ::$t::INFINITY ); }
                                        if !is_positive && ( prev_sig != ( sig + digit as $t ) / radix as $t )
                                            { return Ok( ::$t::NEG_INFINITY ); }
                                    }
                                    prev_sig = sig;
                                },
                                None => match c {
                                    'e' | 'E' | 'p' | 'P' => {
                                        exp_info = Some( ( c, i + 1 ) );
                                        break; 
                                    },
                                    '.' => {
                                        break; 
                                    },
                                    _ => {
                                        return Err( PFE { kind: Invalid } );
                                    },
                                },
                            }
                        }
                       
                       
                        if exp_info.is_none() {
                            let mut power = 1.0;
                            for ( i, c ) in cs.by_ref() {
                                match c.to_digit( radix ) {
                                    Some( digit ) => {
                                       
                                        power /= radix as $t;
                                       
                                        sig = if is_positive {
                                            sig + ( digit as $t ) * power
                                        } else {
                                            sig - ( digit as $t ) * power
                                        };
                                       
                                        if is_positive && sig < prev_sig
                                            { return Ok( ::$t::INFINITY ); }
                                        if !is_positive && sig > prev_sig
                                            { return Ok( ::$t::NEG_INFINITY ); }
                                        prev_sig = sig;
                                    },
                                    None => match c {
                                        'e' | 'E' | 'p' | 'P' => {
                                            exp_info = Some( ( c, i + 1 ) );
                                            break;
                                        },
                                        _ => {
                                            return Err( PFE { kind: Invalid } );
                                        },
                                    },
                                }
                            }
                        }
                       
                        let exp = match exp_info {
                            Some( ( c, offset ) ) => {
                                let base = match c {
                                    'E' | 'e' if radix == 10 => 10.0,
                                    'P' | 'p' if radix == 16 => 2.0,
                                    _ => return Err( PFE { kind: Invalid } ),
                                };

                               
                                let src = &src[offset..];
                                let ( is_positive, exp ) = match slice_shift_char( src ) {
                                    Some( ( '-', src ) ) => ( false, src.parse::<usize>() ),
                                    Some( ( '+', src ) ) => ( true,  src.parse::<usize>() ),
                                    Some( ( _, _ ) )     => ( true,  src.parse::<usize>() ),
                                    None             => return Err( PFE { kind: Invalid } ),
                                };

                                                    fn pow( base: $t, exp: usize ) -> $t {
                                    Float::powi( base, exp as i32 )
                                }
                               

                                match ( is_positive, exp ) {
                                    ( true,  Ok( exp ) ) => pow( base, exp ),
                                    ( false, Ok( exp ) ) => 1.0 / pow( base, exp ),
                                    ( _, Err( _ ) )      => return Err( PFE { kind: Invalid } ),
                                }
                            },
                            None => 1.0,
                        };

                        Ok( sig * exp )
                    }
                }
            )* )
        }
        
        float_trait_impl!( Num for f32 f64 );
        /// A value bounded by a minimum and a maximum
        #[inline] pub fn clamp<T: PartialOrd>( input: T, min: T, max: T ) -> T
        {
            debug_assert!( min <= max, "min must be less than or equal to max" );
            if input < min {
                min
            } else if input > max {
                max
            } else {
                input
            }
        }
        /// A value bounded by a minimum value
        #[inline] pub fn clamp_min<T: PartialOrd>( input: T, min: T ) -> T
        {
            debug_assert!( min == min, "min must not be NAN" );
            if input < min {
                min
            } else {
                input
            }
        }
        /// A value bounded by a maximum value
        #[inline] pub fn clamp_max<T: PartialOrd>( input: T, max: T ) -> T
        {
            debug_assert!( max == max, "max must not be NAN" );
            if input > max {
                max
            } else {
                input
            }
        }
    }
    /*
    */
    pub mod integers
    {
        //! Integer trait and functions.
        use ::
        {
            num::{ traits::{ Num, Signed, Zero } },
            ops::{ Add },
            *,
        };
        /*
        */
        pub mod average
        {
            /*!
            */
            use ::
            {
                num::integers::{ Integer },
                ops::{BitAnd, BitOr, BitXor, Shr},
                *,
            };
            /*
            */
            /// Provides methods to compute the average of two integers, without overflows.
            pub trait Average: Integer {
                /// Returns the ceiling value of the average of `self` and `other`.
                fn average_floor( &self, other:&Self ) -> Self;
                fn average_ceil( &self, other:&Self ) -> Self;
            }
            
            impl<I> Average for I where
            I: Integer + Shr<usize, Output = I>,
            for<'a, 'b> &'a I: BitAnd<&'b I, Output = I> 
            + BitOr<&'b I, Output = I> 
            + BitXor<&'b I, Output = I>,
            {
                /// Returns the floor value of the average of `self` and `other`.
                #[inline] fn average_floor( &self, other:&I ) -> I {
                    ( self & other ) + ( ( self ^ other ) >> 1 )
                }
                /// Returns the ceil value of the average of `self` and `other`.
                #[inline] fn average_ceil( &self, other:&I ) -> I {
                    ( self | other ) - ( ( self ^ other ) >> 1 )
                }
            }
            /// Returns the floor value of the average of `x` and `y` --
            /// see [Average::average_floor]( trait.Average.html#tymethod.average_floor ).
            #[inline] pub fn average_floor<T: Average>( x: T, y: T ) -> T {
                x.average_floor( &y )
            }
            /// Returns the ceiling value of the average of `x` and `y` --
            /// see [Average::average_ceil]( trait.Average.html#tymethod.average_ceil ).
            #[inline] pub fn average_ceil<T: Average>( x: T, y: T ) -> T {
                x.average_ceil( &y )
            }
        } pub use self::average::{average_ceil, average_floor, Average};

        pub mod roots
        {
            /*!
            */
            use ::
            {
                num::
                {
                    traits::{checked_pow, PrimInt},
                    integers::{ Integer },
                },
                *,
            };
            /*
            */
            /// Provides methods to compute an integer's square root, cube root,
            /// and arbitrary `n`th root.
            pub trait Roots: Integer {
                /// Returns the truncated principal `n`th root of an integer
                /// -- `if x >= 0 { x } else { x }`
                fn nth_root( &self, n: u32 ) -> Self;
                /// Returns the truncated principal square root of an integer -- `x`
                ///
                /// This is solving for `r` in `r = x`, rounding toward zero.
                #[inline] fn sqrt( &self ) -> Self {
                    self.nth_root( 2 )
                }
                /// Returns the truncated principal cube root of an integer --
                /// `if x >= 0 { x } else { x }`
                ///
                /// This is solving for `r` in `r = x`, rounding toward zero.
                #[inline] fn cbrt( &self ) -> Self {
                    self.nth_root( 3 )
                }
            }
            /// Returns the truncated principal square root of an integer --
            /// see [Roots::sqrt]( trait.Roots.html#method.sqrt ).
            #[inline] pub fn sqrt<T: Roots>( x: T ) -> T {
                x.sqrt()
            }
            /// Returns the truncated principal cube root of an integer --
            /// see [Roots::cbrt]( trait.Roots.html#method.cbrt ).
            #[inline] pub fn cbrt<T: Roots>( x: T ) -> T {
                x.cbrt()
            }
            /// Returns the truncated principal `n`th root of an integer --
            /// see [Roots::nth_root]( trait.Roots.html#tymethod.nth_root ).
            #[inline] pub fn nth_root<T: Roots>( x: T, n: u32 ) -> T {
                x.nth_root( n )
            }
            macro_rules! signed_roots {
                ( $T:ty, $U:ty ) => {
                    impl Roots for $T {
                        #[inline]
                        fn nth_root( &self, n: u32 ) -> Self {
                            if *self >= 0 {
                                ( *self as $U ).nth_root( n ) as Self
                            } else {
                                assert!( n.is_odd(), "even roots of a negative are imaginary" );
                                -( ( self.wrapping_neg() as $U ).nth_root( n ) as Self )
                            }
                        }
                        #[inline]
                        fn sqrt( &self ) -> Self {
                            assert!( *self >= 0, "the square root of a negative is imaginary" );
                            ( *self as $U ).sqrt() as Self
                        }
                        #[inline]
                        fn cbrt( &self ) -> Self {
                            if *self >= 0 {
                                ( *self as $U ).cbrt() as Self
                            } else {
                                -( ( self.wrapping_neg() as $U ).cbrt() as Self )
                            }
                        }
                    }
                };
            }
            signed_roots!( i8, u8 );
            signed_roots!( i16, u16 );
            signed_roots!( i32, u32 );
            signed_roots!( i64, u64 );
            signed_roots!( i128, u128 );
            signed_roots!( isize, usize );

            #[inline] fn fixpoint<T, F>( mut x: T, f: F ) -> T
            where
                T: Integer + Copy,
                F: Fn( T ) -> T,
            {
                let mut xn = f( x );
                while x < xn {
                    x = xn;
                    xn = f( x );
                }
                while x > xn {
                    x = xn;
                    xn = f( x );
                }
                x
            }
            #[inline] fn bits<T>() -> u32 {
                8 * mem::size_of::<T>() as u32
            }
            #[inline] fn log2<T: PrimInt>( x: T ) -> u32
            {
                debug_assert!( x > T::zero() );
                bits::<T>() - 1 - x.leading_zeros()
            }
            macro_rules! unsigned_roots {
                ( $T:ident ) => {
                    impl Roots for $T {
                        #[inline]
                        fn nth_root( &self, n: u32 ) -> Self {
                            fn go( a: $T, n: u32 ) -> $T {
                               
                                match n {
                                    0 => panic!( "can't find a root of degree 0!" ),
                                    1 => return a,
                                    2 => return a.sqrt(),
                                    3 => return a.cbrt(),
                                    _ => (),
                                }
                               
                                if bits::<$T>() <= n || a < ( 1 << n ) {
                                    return ( a > 0 ) as $T;
                                }
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        ( a as u64 ).nth_root( n ) as $T
                                    } else {
                                        let lo = ( a >> n ).nth_root( n ) << 1;
                                        let hi = lo + 1;
                                       
                                       
                                        if hi.next_power_of_two().trailing_zeros() * n >= bits::<$T>() {
                                            match checked_pow( hi, n as usize ) {
                                                Some( x ) if x <= a => hi,
                                                _ => lo,
                                            }
                                        } else {
                                            if hi.pow( n ) <= a {
                                                hi
                                            } else {
                                                lo
                                            }
                                        }
                                    };
                                }
                                
                                #[inline] fn guess( x: $T, n: u32 ) -> $T {
                                   
                                    if bits::<$T>() <= 32 || x <= ::u32::MAX as $T {
                                        1 << ( ( log2( x ) + n - 1 ) / n )
                                    } else {
                                        ( ( x as f64 ).ln() / f64::from( n ) ).exp() as $T
                                    }
                                }
                                
                                let n1 = n - 1;
                                let next = |x: $T| {
                                    let y = match checked_pow( x, n1 as usize ) {
                                        Some( ax ) => a / ax,
                                        None => 0,
                                    };
                                    ( y + x * n1 as $T ) / n as $T
                                };
                                fixpoint( guess( a, n ), next )
                            }
                            go( *self, n )
                        }
                        #[inline]
                        fn sqrt( &self ) -> Self {
                            fn go( a: $T ) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        ( a as u64 ).sqrt() as $T
                                    } else {
                                        let lo = ( a >> 2u32 ).sqrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }
                                if a < 4 {
                                    return ( a > 0 ) as $T;
                                }
                                                    #[inline]
                                fn guess( x: $T ) -> $T {
                                    ( x as f64 ).sqrt() as $T
                                }
                                
                                let next = |x: $T| ( a / x + x ) >> 1;
                                fixpoint( guess( a ), next )
                            }
                            go( *self )
                        }
                        #[inline]
                        fn cbrt( &self ) -> Self {
                            fn go( a: $T ) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        ( a as u64 ).cbrt() as $T
                                    } else {
                                        let lo = ( a >> 3u32 ).cbrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }
                                if bits::<$T>() <= 32 {
                                   
                                    let mut x = a;
                                    let mut y2 = 0;
                                    let mut y = 0;
                                    let smax = bits::<$T>() / 3;
                                    for s in ( 0..smax + 1 ).rev() {
                                        let s = s * 3;
                                        y2 *= 4;
                                        y *= 2;
                                        let b = 3 * ( y2 + y ) + 1;
                                        if x >> s >= b {
                                            x -= b << s;
                                            y2 += 2 * y + 1;
                                            y += 1;
                                        }
                                    }
                                    return y;
                                }
                                if a < 8 {
                                    return ( a > 0 ) as $T;
                                }
                                if a <= ::u32::MAX as $T {
                                    return ( a as u32 ).cbrt() as $T;
                                }
                                                    #[inline]
                                fn guess( x: $T ) -> $T {
                                    ( x as f64 ).cbrt() as $T
                                }
                                
                                let next = |x: $T| ( a / ( x * x ) + x * 2 ) / 3;
                                fixpoint( guess( a ), next )
                            }
                            go( *self )
                        }
                    }
                };
            }
            unsigned_roots!( u8 );
            unsigned_roots!( u16 );
            unsigned_roots!( u32 );
            unsigned_roots!( u64 );
            unsigned_roots!( u128 );
            unsigned_roots!( usize );
        } pub use self::roots::{cbrt, nth_root, sqrt, Roots};

        pub trait Integer: Sized + Num + PartialOrd + Ord + Eq 
        {
            /// Floored integer division.
            fn div_floor( &self, other:&Self ) -> Self;
            /// Floored integer modulo.
            fn mod_floor( &self, other:&Self ) -> Self;
            /// Ceiled integer division.
            fn div_ceil( &self, other:&Self ) -> Self {
                let ( q, r ) = self.div_mod_floor( other );
                if r.is_zero() {
                    q
                } else {
                    q + Self::one()
                }
            }
            /// Greatest Common Divisor ( GCD ).
            fn gcd( &self, other:&Self ) -> Self;
            /// Lowest Common Multiple ( LCM ).
            /// ~~~
            fn lcm( &self, other:&Self ) -> Self;
            /// Greatest Common Divisor ( GCD ) and
            /// Lowest Common Multiple ( LCM ) together.
            #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self ) {
                ( self.gcd( other ), self.lcm( other ) )
            }
            /// Greatest common divisor and Bzout coefficients.
            #[inline] fn extended_gcd( &self, other:&Self ) -> ExtendedGcd<Self> where
                Self: Clone,
            {
                let mut s = ( Self::zero(), Self::one() );
                let mut t = ( Self::one(), Self::zero() );
                let mut r = ( other.clone(), self.clone() );

                while !r.0.is_zero() {
                    let q = r.1.clone() / r.0.clone();
                    let f = |mut r: ( Self, Self )| {
                        mem::swap( &mut r.0, &mut r.1 );
                        r.0 = r.0 - q.clone() * r.1.clone();
                        r
                    };
                    r = f( r );
                    s = f( s  );
                    t = f( t );
                }
                if r.1 >= Self::zero() {
                    ExtendedGcd {
                        gcd: r.1,
                        x: s.1,
                        y: t.1,
                    }
                } else {
                    ExtendedGcd {
                        gcd: Self::zero() - r.1,
                        x: Self::zero() - s.1,
                        y: Self::zero() - t.1,
                    }
                }
            }
            /// Greatest common divisor, least common multiple, and Bzout coefficients.
            #[inline] fn extended_gcd_lcm( &self, other:&Self ) -> ( ExtendedGcd<Self>, Self )
            where
                Self: Clone + Signed,
            {
                ( self.extended_gcd( other ), self.lcm( other ) )
            }
            /// Deprecated, use `is_multiple_of` instead.
            #[deprecated( note = "Please use is_multiple_of instead" )]
            #[inline] fn divides( &self, other:&Self ) -> bool {
                self.is_multiple_of( other )
            }
            /// Returns `true` if `self` is a multiple of `other`.
            fn is_multiple_of( &self, other:&Self ) -> bool;
            /// Returns `true` if the number is even.
            fn is_even( &self ) -> bool;
            /// Returns `true` if the number is odd.
            fn is_odd( &self ) -> bool;
            /// Simultaneous truncated integer division and modulus.
            fn div_rem( &self, other:&Self ) -> ( Self, Self );
            /// Simultaneous floored integer division and modulus.
            fn div_mod_floor( &self, other:&Self ) -> ( Self, Self ) {
                ( self.div_floor( other ), self.mod_floor( other ) )
            }
            /// Rounds up to nearest multiple of argument.
            #[inline] fn next_multiple_of( &self, other:&Self ) -> Self
            where
                Self: Clone,
            {
                let m = self.mod_floor( other );
                self.clone()
                    + if m.is_zero() {
                        Self::zero()
                    } else {
                        other.clone() - m
                    }
            }
            /// Rounds down to nearest multiple of argument.
            #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self
            where
                Self: Clone,
            {
                self.clone() - self.mod_floor( other )
            }
            /// Decrements self by one.
            /// ~~~
            fn dec( &mut self )
            where
                Self: Clone,
            {
                *self = self.clone() - Self::one()
            }
            /// Increments self by one.
            /// ~~~
            fn inc( &mut self )
            where
                Self: Clone,
            {
                *self = self.clone() + Self::one()
            }
        }
        /// Greatest common divisor and Bzout coefficients.
        #[derive( Debug, Clone, Copy, PartialEq, Eq )]
        pub struct ExtendedGcd<A> 
        {
            pub gcd: A,
            pub x: A,
            pub y: A,
        }
        /// Simultaneous integer division and modulus
        #[inline] pub fn div_rem<T: Integer>( x: T, y: T ) -> ( T, T ) 
        {
            x.div_rem( &y )
        }
        /// Floored integer division
        #[inline] pub fn div_floor<T: Integer>( x: T, y: T ) -> T 
        {
            x.div_floor( &y )
        }
        /// Floored integer modulus
        #[inline] pub fn mod_floor<T: Integer>( x: T, y: T ) -> T 
        {
            x.mod_floor( &y )
        }
        /// Simultaneous floored integer division and modulus
        #[inline] pub fn div_mod_floor<T: Integer>( x: T, y: T ) -> ( T, T ) 
        {
            x.div_mod_floor( &y )
        }
        /// Ceiled integer division
        #[inline] pub fn div_ceil<T: Integer>( x: T, y: T ) -> T 
        {
            x.div_ceil( &y )
        }
        /// Calculates the Greatest Common Divisor ( GCD ) of the number and `other`.
        #[inline( always )] pub fn gcd<T: Integer>( x: T, y: T ) -> T 
        {
            x.gcd( &y )
        }
        /// Calculates the Lowest Common Multiple ( LCM ) of the number and `other`.
        #[inline( always )] pub fn lcm<T: Integer>( x: T, y: T ) -> T 
        {
            x.lcm( &y )
        }
        /// Calculates the Greatest Common Divisor ( GCD ) and Lowest Common Multiple ( LCM ) of the number and `other`.
        #[inline( always )] pub fn gcd_lcm<T: Integer>( x: T, y: T ) -> ( T, T ) 
        {
            x.gcd_lcm( &y )
        }

        macro_rules! impl_integer_for_isize 
        {
            ( $T:ty, $test_mod:ident ) => {
                impl Integer for $T {
                    /// Floored integer division
                    #[inline] fn div_floor( &self, other:&Self ) -> Self {
                       
                       
                        let ( d, r ) = self.div_rem( other );
                        if ( r > 0 && *other < 0 ) || ( r < 0 && *other > 0 ) {
                            d - 1
                        } else {
                            d
                        }
                    }
                    /// Floored integer modulo
                    #[inline] fn mod_floor( &self, other:&Self ) -> Self {
                       
                       
                        let r = *self % *other;
                        if ( r > 0 && *other < 0 ) || ( r < 0 && *other > 0 ) {
                            r + *other
                        } else {
                            r
                        }
                    }
                    /// Calculates `div_floor` and `mod_floor` simultaneously
                    #[inline] fn div_mod_floor( &self, other:&Self ) -> ( Self, Self ) {
                       
                       
                        let ( d, r ) = self.div_rem( other );
                        if ( r > 0 && *other < 0 ) || ( r < 0 && *other > 0 ) {
                            ( d - 1, r + *other )
                        } else {
                            ( d, r )
                        }
                    }
                    #[inline] fn div_ceil( &self, other:&Self ) -> Self {
                        let ( d, r ) = self.div_rem( other );
                        if ( r > 0 && *other > 0 ) || ( r < 0 && *other < 0 ) {
                            d + 1
                        } else {
                            d
                        }
                    }
                    /// Calculates the Greatest Common Divisor ( GCD ) of the number and
                    /// `other`. The result is always non-negative.
                    #[inline] fn gcd( &self, other:&Self ) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return ( m | n ).abs();
                        }
                       
                        let shift = ( m | n ).trailing_zeros();

                       
                       
                       
                       

                       
                       
                       
                        if m == Self::min_value() || n == Self::min_value() {
                            return ( 1 << shift ).abs();
                        }
                       
                        m = m.abs();
                        n = n.abs();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }
                    #[inline] fn extended_gcd_lcm( &self, other:&Self ) -> ( ExtendedGcd<Self>, Self ) {
                        let egcd = self.extended_gcd( other );
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            ( *self * ( *other / egcd.gcd ) ).abs()
                        };
                        ( egcd, lcm )
                    }
                    /// Calculates the Lowest Common Multiple ( LCM ) of the number and
                    /// `other`.
                    #[inline] fn lcm( &self, other:&Self ) -> Self {
                        self.gcd_lcm( other ).1
                    }
                    /// Calculates the Greatest Common Divisor ( GCD ) and
                    /// Lowest Common Multiple ( LCM ) of the number and `other`.
                    #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self ) {
                        if self.is_zero() && other.is_zero() {
                            return ( Self::zero(), Self::zero() );
                        }
                        let gcd = self.gcd( other );
                       
                        let lcm = ( *self * ( *other / gcd ) ).abs();
                        ( gcd, lcm )
                    }
                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline] fn is_multiple_of( &self, other:&Self ) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }
                    /// Returns `true` if the number is divisible by `2`
                    #[inline] fn is_even( &self ) -> bool {
                        ( *self ) & 1 == 0
                    }
                    /// Returns `true` if the number is not divisible by `2`
                    #[inline] fn is_odd( &self ) -> bool {
                        !self.is_even()
                    }
                    /// Simultaneous truncated integer division and modulus.
                    #[inline] fn div_rem( &self, other:&Self ) -> ( Self, Self ) {
                        ( *self / *other, *self % *other )
                    }
                    /// Rounds up to nearest multiple of argument.
                    #[inline] fn next_multiple_of( &self, other:&Self ) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }
                        let m = Integer::mod_floor( self, other );
                        *self + if m == 0 { 0 } else { other - m }
                    }
                    /// Rounds down to nearest multiple of argument.
                    #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }
                        *self - Integer::mod_floor( self, other )
                    }
                }
            };
        }

        impl_integer_for_isize!( i8, test_integer_i8 );
        impl_integer_for_isize!( i16, test_integer_i16 );
        impl_integer_for_isize!( i32, test_integer_i32 );
        impl_integer_for_isize!( i64, test_integer_i64 );
        impl_integer_for_isize!( i128, test_integer_i128 );
        impl_integer_for_isize!( isize, test_integer_isize );

        macro_rules! impl_integer_for_usize 
        {
            ( $T:ty, $test_mod:ident ) => {
                impl Integer for $T {
                    /// Unsigned integer division. Returns the same result as `div` ( `/` ).
                    #[inline] fn div_floor( &self, other:&Self ) -> Self {
                        *self / *other
                    }
                    /// Unsigned integer modulo operation. Returns the same result as `rem` ( `%` ).
                    #[inline] fn mod_floor( &self, other:&Self ) -> Self {
                        *self % *other
                    }
                    #[inline] fn div_ceil( &self, other:&Self ) -> Self {
                        *self / *other + ( 0 != *self % *other ) as Self
                    }
                    /// Calculates the Greatest Common Divisor ( GCD ) of the number and `other`
                    #[inline] fn gcd( &self, other:&Self ) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return m | n;
                        }
                       
                        let shift = ( m | n ).trailing_zeros();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }
                    #[inline] fn extended_gcd_lcm( &self, other:&Self ) -> ( ExtendedGcd<Self>, Self ) {
                        let egcd = self.extended_gcd( other );
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            *self * ( *other / egcd.gcd )
                        };
                        ( egcd, lcm )
                    }
                    /// Calculates the Lowest Common Multiple ( LCM ) of the number and `other`.
                    #[inline] fn lcm( &self, other:&Self ) -> Self {
                        self.gcd_lcm( other ).1
                    }
                    /// Calculates the Greatest Common Divisor ( GCD ) and
                    /// Lowest Common Multiple ( LCM ) of the number and `other`.
                    #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self ) {
                        if self.is_zero() && other.is_zero() {
                            return ( Self::zero(), Self::zero() );
                        }
                        let gcd = self.gcd( other );
                        let lcm = *self * ( *other / gcd );
                        ( gcd, lcm )
                    }
                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline] fn is_multiple_of( &self, other:&Self ) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }
                    /// Returns `true` if the number is divisible by `2`.
                    #[inline] fn is_even( &self ) -> bool {
                        *self % 2 == 0
                    }
                    /// Returns `true` if the number is not divisible by `2`.
                    #[inline] fn is_odd( &self ) -> bool {
                        !self.is_even()
                    }
                    /// Simultaneous truncated integer division and modulus.
                    #[inline] fn div_rem( &self, other:&Self ) -> ( Self, Self ) {
                        ( *self / *other, *self % *other )
                    }
                }
            };
        }

        impl_integer_for_usize!( u8, test_integer_u8 );
        impl_integer_for_usize!( u16, test_integer_u16 );
        impl_integer_for_usize!( u32, test_integer_u32 );
        impl_integer_for_usize!( u64, test_integer_u64 );
        impl_integer_for_usize!( u128, test_integer_u128 );
        impl_integer_for_usize!( usize, test_integer_usize );
        /// An iterator over binomial coefficients.
        pub struct IterBinomial<T> 
        {
            a: T,
            n: T,
            k: T,
        }

        impl<T> IterBinomial<T> where
            T: Integer,
        {
            /// For a given n, iterate over all binomial coefficients binomial( n, k ), for k=0...n.
            /// be no overflow:
            ///
            /// type | n
            /// -----|---
            /// u8   | 10
            /// i8   |  9
            /// u16  | 18
            /// i16  | 17
            /// u32  | 34
            /// i32  | 33
            /// u64  | 67
            /// i64  | 66
            ///
            /// For larger n, `T` should be a bigint type.
            pub fn new( n: T ) -> IterBinomial<T> {
                IterBinomial {
                    k: T::zero(),
                    a: T::one(),
                    n,
                }
            }
        }

        impl<T> Iterator for IterBinomial<T> where
        T: Integer + Clone,
        {
            type Item = T;

            fn next( &mut self ) -> Option<T> {
                if self.k > self.n {
                    return None;
                }
                self.a = if !self.k.is_zero() {
                    multiply_and_divide( 
                        self.a.clone(),
                        self.n.clone() - self.k.clone() + T::one(),
                        self.k.clone(),
                    )
                } else {
                    T::one()
                };
                self.k = self.k.clone() + T::one();
                Some( self.a.clone() )
            }
        }
        /// Calculate r * a / b, avoiding overflows and fractions.
        fn multiply_and_divide<T: Integer + Clone>( r: T, a: T, b: T ) -> T
        {
           
            let g = gcd( r.clone(), b.clone() );
            r / g.clone() * ( a / ( b / g ) )
        }
        /// Calculate the binomial coefficient.
        pub fn binomial<T: Integer + Clone>( mut n: T, k: T ) -> T
        {
           
            if k > n {
                return T::zero();
            }
            if k > n.clone() - k.clone() {
                return binomial( n.clone(), n - k );
            }
            let mut r = T::one();
            let mut d = T::one();
            loop {
                if d > k {
                    break;
                }
                r = multiply_and_divide( r, n.clone(), d.clone() );
                n = n - T::one();
                d = d + T::one();
            }
            r
        }
        /// Calculate the multinomial coefficient.
        pub fn multinomial<T: Integer + Clone>( k:&[T] ) -> T where
            for<'a> T: Add<&'a T, Output = T>,
        {
            let mut r = T::one();
            let mut p = T::zero();
            for i in k {
                p = p + i;
                r = r * binomial( p.clone(), i.clone() );
            }
            r
        }
    }
    /*
    */
    pub mod big
    {
        //! Big Integer Types for Rust
        use ::
        {
            *,
        };
        /*
        */
        pub mod int
        {
            use ::
            {
                cmp::{ Ordering::{self, Equal} },
                default::{ Default },
                num::
                {
                    traits::{ ConstZero, Num, One, Pow, Signed, Zero },
                    integers::{Integer, Roots},
                    big::
                    {
                        digit::BigDigit,
                        uint::{BigUint, IntDigits, to_str_radix_reversed, U32Digits, U64Digits},
                    },
                },
                ops::{ Neg, Not },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /*
            */
            use self::Sign::{Minus, NoSign, Plus};

            pub mod addition
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Sum },
                    num::
                    {
                        big::{ IsizePromotion, UsizePromotion },
                        traits::{ CheckedAdd },
                    },
                    ops::{ Add, AddAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{ Negative, Positive };
                use super::Sign::{ Minus, NoSign, Plus };
                use super::{ BigInt, UnsignedAbs };
                /*
                */
                macro_rules! bigint_add 
                {
                    ( $a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr ) => {
                        match ( $a.sign, $b.sign ) {
                            ( _, NoSign ) => $a_owned,
                            ( NoSign, _ ) => $b_owned,
                           
                            ( Plus, Plus ) | ( Minus, Minus ) => BigInt::from_biguint( $a.sign, $a_data + $b_data ),
                           
                            ( Plus, Minus ) | ( Minus, Plus ) => match $a.data.cmp( &$b.data ) {
                                Less => BigInt::from_biguint( $b.sign, $b_data - $a_data ),
                                Greater => BigInt::from_biguint( $a.sign, $a_data - $b_data ),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }
                impl Add<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other:&BigInt ) -> BigInt {
                        bigint_add!( 
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }
                impl Add<BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: BigInt ) -> BigInt {
                        bigint_add!( self, self.clone(), &self.data, other, other, other.data )
                    }
                }
                impl Add<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other:&BigInt ) -> BigInt {
                        bigint_add!( self, self, self.data, other, other.clone(), &other.data )
                    }
                }
                impl Add<BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: BigInt ) -> BigInt {
                        bigint_add!( self, self, self.data, other, other, other.data )
                    }
                }
                impl AddAssign<&BigInt> for BigInt 
                {
                    #[inline] fn add_assign( &mut self, other:&BigInt ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                forward_val_assign!( impl AddAssign for BigInt, add_assign );

                promote_all_scalars!( impl Add for BigInt, add );
                promote_all_scalars_assign!( impl AddAssign for BigInt, add_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u32> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u64> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u128> for BigInt, add );

                impl Add<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: u32 ) -> BigInt {
                        match self.sign {
                            NoSign => From::from( other ),
                            Plus => BigInt::from( self.data + other ),
                            Minus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Less => BigInt::from( other - self.data ),
                                Greater => -BigInt::from( self.data - other ),
                            },
                        }
                    }
                }
                impl AddAssign<u32> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: u32 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                impl Add<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: u64 ) -> BigInt {
                        match self.sign {
                            NoSign => From::from( other ),
                            Plus => BigInt::from( self.data + other ),
                            Minus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Less => BigInt::from( other - self.data ),
                                Greater => -BigInt::from( self.data - other ),
                            },
                        }
                    }
                }
                impl AddAssign<u64> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: u64 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                impl Add<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: u128 ) -> BigInt {
                        match self.sign {
                            NoSign => BigInt::from( other ),
                            Plus => BigInt::from( self.data + other ),
                            Minus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Less => BigInt::from( other - self.data ),
                                Greater => -BigInt::from( self.data - other ),
                            },
                        }
                    }
                }
                impl AddAssign<u128> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: u128 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<i32> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<i64> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<i128> for BigInt, add );

                impl Add<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self + u,
                            Negative( u ) => self - u,
                        }
                    }
                }
                impl AddAssign<i32> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self += u,
                            Negative( u ) => *self -= u,
                        }
                    }
                }
                impl Add<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self + u,
                            Negative( u ) => self - u,
                        }
                    }
                }
                impl AddAssign<i64> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self += u,
                            Negative( u ) => *self -= u,
                        }
                    }
                }
                impl Add<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self + u,
                            Negative( u ) => self - u,
                        }
                    }
                }
                impl AddAssign<i128> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self += u,
                            Negative( u ) => *self -= u,
                        }
                    }
                }
                impl CheckedAdd for BigInt
                {
                    #[inline] fn checked_add( &self, v:&BigInt ) -> Option<BigInt> {
                        Some( self.add( v ) )
                    }
                }
                impl_sum_iter_type!( BigInt );
            }
            pub mod division
            {
                use ::
                {
                    num::
                    {
                        big::{IsizePromotion, UsizePromotion},
                        integers::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, Signed, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::NoSign;
                use super::{BigInt, UnsignedAbs};
                /*
                */
                forward_all_binop_to_ref_ref!( impl Div for BigInt, div );

                impl Div<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other:&BigInt ) -> BigInt {
                        let ( q, _ ) = self.div_rem( other );
                        q
                    }
                }
                impl DivAssign<&BigInt> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other:&BigInt ) {
                        *self = &*self / other;
                    }
                }
                forward_val_assign!( impl DivAssign for BigInt, div_assign );

                promote_all_scalars!( impl Div for BigInt, div );
                promote_all_scalars_assign!( impl DivAssign for BigInt, div_assign );
                forward_all_scalar_binop_to_val_val!( impl Div<u32> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u64> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u128> for BigInt, div );

                impl Div<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: u32 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data / other )
                    }
                }
                impl DivAssign<u32> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: u32 ) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Div<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        BigInt::from_biguint( other.sign, self / other.data )
                    }
                }
                impl Div<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: u64 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data / other )
                    }
                }
                impl DivAssign<u64> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: u64 ) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Div<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        BigInt::from_biguint( other.sign, self / other.data )
                    }
                }
                impl Div<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: u128 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data / other )
                    }
                }
                impl DivAssign<u128> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: u128 ) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Div<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        BigInt::from_biguint( other.sign, self / other.data )
                    }
                }
                forward_all_scalar_binop_to_val_val!( impl Div<i32> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<i64> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<i128> for BigInt, div );

                impl Div<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self / u,
                            Negative( u ) => -self / u,
                        }
                    }
                }
                impl DivAssign<i32> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self /= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }
                impl Div<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u / other,
                            Negative( u ) => u / -other,
                        }
                    }
                }
                impl Div<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self / u,
                            Negative( u ) => -self / u,
                        }
                    }
                }
                impl DivAssign<i64> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self /= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }
                impl Div<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u / other,
                            Negative( u ) => u / -other,
                        }
                    }
                }
                impl Div<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self / u,
                            Negative( u ) => -self / u,
                        }
                    }
                }
                impl DivAssign<i128> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self /= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }
                impl Div<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u / other,
                            Negative( u ) => u / -other,
                        }
                    }
                }
                forward_all_binop_to_ref_ref!( impl Rem for BigInt, rem );

                impl Rem<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other:&BigInt ) -> BigInt {
                        if let Some( other ) = other.to_u32() {
                            self % other
                        } else if let Some( other ) = other.to_i32() {
                            self % other
                        } else {
                            let ( _, r ) = self.div_rem( other );
                            r
                        }
                    }
                }
                impl RemAssign<&BigInt> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other:&BigInt ) {
                        *self = &*self % other;
                    }
                }
                forward_val_assign!( impl RemAssign for BigInt, rem_assign );

                promote_all_scalars!( impl Rem for BigInt, rem );
                promote_all_scalars_assign!( impl RemAssign for BigInt, rem_assign );
                forward_all_scalar_binop_to_val_val!( impl Rem<u32> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u64> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u128> for BigInt, rem );

                impl Rem<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: u32 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data % other )
                    }
                }
                impl RemAssign<u32> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: u32 ) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Rem<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        BigInt::from( self % other.data )
                    }
                }
                impl Rem<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: u64 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data % other )
                    }
                }
                impl RemAssign<u64> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: u64 ) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Rem<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        BigInt::from( self % other.data )
                    }
                }
                impl Rem<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: u128 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data % other )
                    }
                }
                impl RemAssign<u128> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: u128 ) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Rem<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        BigInt::from( self % other.data )
                    }
                }
                forward_all_scalar_binop_to_val_val!( impl Rem<i32> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<i64> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<i128> for BigInt, rem );

                impl Rem<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: i32 ) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }
                impl RemAssign<i32> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: i32 ) {
                        *self %= other.unsigned_abs();
                    }
                }
                impl Rem<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u % other,
                            Negative( u ) => -( u % other ),
                        }
                    }
                }
                impl Rem<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: i64 ) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }
                impl RemAssign<i64> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: i64 ) {
                        *self %= other.unsigned_abs();
                    }
                }
                impl Rem<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u % other,
                            Negative( u ) => -( u % other ),
                        }
                    }
                }
                impl Rem<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: i128 ) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }
                impl RemAssign<i128> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: i128 ) {
                        *self %= other.unsigned_abs();
                    }
                }
                impl Rem<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u % other,
                            Negative( u ) => -( u % other ),
                        }
                    }
                }
                impl CheckedDiv for BigInt
                {
                    #[inline] fn checked_div( &self, v:&BigInt ) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div( v ) )
                    }
                }
                impl CheckedEuclid for BigInt
                {
                    #[inline] fn checked_div_euclid( &self, v:&BigInt ) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div_euclid( v ) )
                    }
                    #[inline] fn checked_rem_euclid( &self, v:&BigInt ) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.rem_euclid( v ) )
                    }
                    fn checked_div_rem_euclid( &self, v:&Self ) -> Option<( Self, Self )> {
                        Some( self.div_rem_euclid( v ) )
                    }
                }
                impl Euclid for BigInt
                {
                    #[inline] fn div_euclid( &self, v:&BigInt ) -> BigInt {
                        let ( q, r ) = self.div_rem( v );
                        if r.is_negative() {
                            if v.is_positive() {
                                q - 1
                            } else {
                                q + 1
                            }
                        } else {
                            q
                        }
                    }
                    #[inline] fn rem_euclid( &self, v:&BigInt ) -> BigInt {
                        let r = self % v;
                        if r.is_negative() {
                            if v.is_positive() {
                                r + v
                            } else {
                                r - v
                            }
                        } else {
                            r
                        }
                    }
                    fn div_rem_euclid( &self, v:&Self ) -> ( Self, Self ) {
                        let ( q, r ) = self.div_rem( v );
                        if r.is_negative() {
                            if v.is_positive() {
                                ( q - 1, r + v )
                            } else {
                                ( q + 1, r - v )
                            }
                        } else {
                            ( q, r )
                        }
                    }
                }
            }
            
            pub mod multiplication
            {
                use ::
                {
                    iter::{ Product },
                    num::
                    {
                        big::{IsizePromotion, UsizePromotion},
                        traits::{CheckedMul, One, Zero},
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::{self, Minus, NoSign, Plus};
                use super::{BigInt, UnsignedAbs};
                /*
                */
                impl Mul<Sign> for Sign {
                    type Output = Sign;

                    #[inline] fn mul( self, other: Sign ) -> Sign {
                        match ( self, other ) {
                            ( NoSign, _ ) | ( _, NoSign ) => NoSign,
                            ( Plus, Plus ) | ( Minus, Minus ) => Plus,
                            ( Plus, Minus ) | ( Minus, Plus ) => Minus,
                        }
                    }
                }
                macro_rules! impl_mul {
                    ( $( impl Mul<$Other:ty> for $Self:ty; )* ) => {$( 
                        impl Mul<$Other> for $Self {
                            type Output = BigInt;

                            #[inline]
                            fn mul( self, other: $Other ) -> BigInt {
                               
                                let BigInt { data: x, .. } = self;
                                let BigInt { data: y, .. } = other;
                                BigInt::from_biguint( self.sign * other.sign, x * y )
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigInt> for BigInt;
                    impl Mul<BigInt> for &BigInt;
                    impl Mul<&BigInt> for BigInt;
                    impl Mul<&BigInt> for &BigInt;
                }
                macro_rules! impl_mul_assign {
                    ( $( impl MulAssign<$Other:ty> for BigInt; )* ) => {$( 
                        impl MulAssign<$Other> for BigInt {
                            #[inline]
                            fn mul_assign( &mut self, other: $Other ) {
                               
                                let BigInt { data: y, .. } = other;
                                self.data *= y;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                } else {
                                    self.sign = self.sign * other.sign;
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigInt> for BigInt;
                    impl MulAssign<&BigInt> for BigInt;
                }
                promote_all_scalars!( impl Mul for BigInt, mul );
                promote_all_scalars_assign!( impl MulAssign for BigInt, mul_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u32> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u64> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u128> for BigInt, mul );

                impl Mul<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: u32 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data * other )
                    }
                }
                impl MulAssign<u32> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: u32 ) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Mul<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: u64 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data * other )
                    }
                }
                impl MulAssign<u64> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: u64 ) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Mul<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: u128 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data * other )
                    }
                }
                impl MulAssign<u128> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: u128 ) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i32> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i64> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i128> for BigInt, mul );

                impl Mul<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self * u,
                            Negative( u ) => -self * u,
                        }
                    }
                }
                impl MulAssign<i32> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self *= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }
                impl Mul<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self * u,
                            Negative( u ) => -self * u,
                        }
                    }
                }
                impl MulAssign<i64> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self *= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }
                impl Mul<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self * u,
                            Negative( u ) => -self * u,
                        }
                    }
                }
                impl MulAssign<i128> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self *= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }
                impl CheckedMul for BigInt
                {
                    #[inline] fn checked_mul( &self, v:&BigInt ) -> Option<BigInt> {
                        Some( self.mul( v ) )
                    }
                }
                impl_product_iter_type!( BigInt );

            }
            pub mod subtraction
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    num::{ traits::CheckedSub },
                    ops::{ Sub, SubAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::{Minus, NoSign, Plus};
                use super::{BigInt, UnsignedAbs};
                /*
                */
                macro_rules! bigint_sub
                {
                    ( $a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr ) => {
                        match ( $a.sign, $b.sign ) {
                            ( _, NoSign ) => $a_owned,
                            ( NoSign, _ ) => -$b_owned,
                           
                            ( Plus, Minus ) | ( Minus, Plus ) => BigInt::from_biguint( $a.sign, $a_data + $b_data ),
                           
                            ( Plus, Plus ) | ( Minus, Minus ) => match $a.data.cmp( &$b.data ) {
                                Less => BigInt::from_biguint( -$a.sign, $b_data - $a_data ),
                                Greater => BigInt::from_biguint( $a.sign, $a_data - $b_data ),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }
                impl Sub<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other:&BigInt ) -> BigInt {
                        bigint_sub!( 
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }
                impl Sub<BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        bigint_sub!( self, self.clone(), &self.data, other, other, other.data )
                    }
                }
                impl Sub<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other:&BigInt ) -> BigInt {
                        bigint_sub!( self, self, self.data, other, other.clone(), &other.data )
                    }
                }
                impl Sub<BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        bigint_sub!( self, self, self.data, other, other, other.data )
                    }
                }
                impl SubAssign<&BigInt> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other:&BigInt ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                forward_val_assign!( impl SubAssign for BigInt, sub_assign );

                promote_all_scalars!( impl Sub for BigInt, sub );
                promote_all_scalars_assign!( impl SubAssign for BigInt, sub_assign );
                forward_all_scalar_binop_to_val_val!( impl Sub<u32> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u64> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u128> for BigInt, sub );

                impl Sub<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: u32 ) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from( other ),
                            Minus => -BigInt::from( self.data + other ),
                            Plus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from( self.data - other ),
                                Less => -BigInt::from( other - self.data ),
                            },
                        }
                    }
                }
                impl SubAssign<u32> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: u32 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                impl Sub<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        -( other - self )
                    }
                }
                impl Sub<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        -( other - self )
                    }
                }
                impl Sub<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        -( other - self )
                    }
                }
                impl Sub<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: u64 ) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from( other ),
                            Minus => -BigInt::from( self.data + other ),
                            Plus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from( self.data - other ),
                                Less => -BigInt::from( other - self.data ),
                            },
                        }
                    }
                }
                impl SubAssign<u64> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: u64 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                impl Sub<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: u128 ) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from( other ),
                            Minus => -BigInt::from( self.data + other ),
                            Plus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from( self.data - other ),
                                Less => -BigInt::from( other - self.data ),
                            },
                        }
                    }
                }
                impl SubAssign<u128> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: u128 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                forward_all_scalar_binop_to_val_val!( impl Sub<i32> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<i64> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<i128> for BigInt, sub );

                impl Sub<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self - u,
                            Negative( u ) => self + u,
                        }
                    }
                }
                impl SubAssign<i32> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self -= u,
                            Negative( u ) => *self += u,
                        }
                    }
                }
                impl Sub<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u - other,
                            Negative( u ) => -other - u,
                        }
                    }
                }
                impl Sub<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self - u,
                            Negative( u ) => self + u,
                        }
                    }
                }
                impl SubAssign<i64> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self -= u,
                            Negative( u ) => *self += u,
                        }
                    }
                }
                impl Sub<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u - other,
                            Negative( u ) => -other - u,
                        }
                    }
                }
                impl Sub<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self - u,
                            Negative( u ) => self + u,
                        }
                    }
                }
                impl SubAssign<i128> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self -= u,
                            Negative( u ) => *self += u,
                        }
                    }
                }
                impl Sub<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u - other,
                            Negative( u ) => -other - u,
                        }
                    }
                }
                impl CheckedSub for BigInt
                {
                    #[inline] fn checked_sub( &self, v:&BigInt ) -> Option<BigInt> {
                        Some( self.sub( v ) )
                    }
                }
            }
            pub mod bits
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    num::
                    {
                        big::
                        {
                            uint::{ IntDigits },
                            digit::{ BigDigit, DoubleBigDigit },
                        },
                        traits::{ToPrimitive, Zero},
                    },
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                    vec::{ Vec },
                    *,
                };
                use super::BigInt;
                use super::Sign::{Minus, NoSign, Plus};
                /*
                */
                #[inline] fn negate_carry( a: BigDigit, acc:&mut DoubleBigDigit ) -> BigDigit
                {
                    *acc += DoubleBigDigit::from( !a );
                    let lo = *acc as BigDigit;
                    *acc >>= ::num::big::digit::BITS;
                    lo
                }
                
                fn bitand_pos_neg( a:&mut [BigDigit], b:&[BigDigit] ) 
                {
                    let mut carry_b = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai &= twos_b;
                    }
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                }
                fn bitand_neg_pos( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = twos_a & bi;
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => a.truncate( b.len() ),
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().cloned() );
                        }
                    }
                }
                fn bitand_neg_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_and = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( twos_a & twos_b, &mut carry_and );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry( *ai, &mut carry_a );
                                *ai = negate_carry( twos_a, &mut carry_and );
                            }
                            debug_assert!( carry_a == 0 );
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_b = negate_carry( bi, &mut carry_b );
                                negate_carry( twos_b, &mut carry_and )
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                    if carry_and != 0 {
                        a.push( 1 );
                    }
                }
                forward_val_val_binop!( impl BitAnd for BigInt, bitand );
                forward_ref_val_binop_big!( impl BitAnd for BigInt, bitand );
                
                impl BitAnd<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitand( self, other:&BigInt ) -> BigInt {
                        match ( self.sign, other.sign ) {
                            ( NoSign, _ ) | ( _, NoSign ) => BigInt::ZERO,
                            ( Plus, Plus ) => BigInt::from( &self.data & &other.data ),
                            ( Plus, Minus ) => self.clone() & other,
                            ( Minus, Plus ) => other.clone() & self,
                            ( Minus, Minus ) => {
                               
                                if self.len() >= other.len() {
                                    self.clone() & other
                                } else {
                                    other.clone() & self
                                }
                            }
                        }
                    }
                }
                impl BitAnd<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitand( mut self, other:&BigInt ) -> BigInt {
                        self &= other;
                        self
                    }
                }
                forward_val_assign!( impl BitAndAssign for BigInt, bitand_assign );

                impl BitAndAssign<&BigInt> for BigInt {
                    fn bitand_assign( &mut self, other:&BigInt ) {
                        match ( self.sign, other.sign ) {
                            ( NoSign, _ ) => {}
                            ( _, NoSign ) => self.set_zero(),
                            ( Plus, Plus ) => {
                                self.data &= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            ( Plus, Minus ) => {
                                bitand_pos_neg( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                            ( Minus, Plus ) => {
                                bitand_neg_pos( self.digits_mut(), other.digits() );
                                self.sign = Plus;
                                self.normalize();
                            }
                            ( Minus, Minus ) => {
                                bitand_neg_neg( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                        }
                    }
                }
                fn bitor_pos_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( *ai | twos_b, &mut carry_or );
                    }
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            a.truncate( b.len() );
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_b = negate_carry( bi, &mut carry_b );
                                negate_carry( twos_b, &mut carry_or )
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                   
                    debug_assert!( carry_or == 0 );
                }
                fn bitor_neg_pos( a:&mut [BigDigit], b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_or = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = negate_carry( twos_a | bi, &mut carry_or );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    if a.len() > b.len() {
                        for ai in a[b.len()..].iter_mut() {
                            let twos_a = negate_carry( *ai, &mut carry_a );
                            *ai = negate_carry( twos_a, &mut carry_or );
                        }
                        debug_assert!( carry_a == 0 );
                    }
                   
                    debug_assert!( carry_or == 0 );
                }
                fn bitor_neg_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( twos_a | twos_b, &mut carry_or );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    if a.len() > b.len() {
                        a.truncate( b.len() );
                    }
                   
                    debug_assert!( carry_or == 0 );
                }
                forward_val_val_binop!( impl BitOr for BigInt, bitor );
                forward_ref_val_binop_big!( impl BitOr for BigInt, bitor );               
               
                impl BitOr<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitor( self, other:&BigInt ) -> BigInt {
                        match ( self.sign, other.sign ) {
                            ( NoSign, _ ) => other.clone(),
                            ( _, NoSign ) => self.clone(),
                            ( Plus, Plus ) => BigInt::from( &self.data | &other.data ),
                            ( Plus, Minus ) => other.clone() | self,
                            ( Minus, Plus ) => self.clone() | other,
                            ( Minus, Minus ) => {
                               
                                if self.len() <= other.len() {
                                    self.clone() | other
                                } else {
                                    other.clone() | self
                                }
                            }
                        }
                    }
                }
                impl BitOr<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitor( mut self, other:&BigInt ) -> BigInt {
                        self |= other;
                        self
                    }
                }
                forward_val_assign!( impl BitOrAssign for BigInt, bitor_assign );

                impl BitOrAssign<&BigInt> for BigInt {
                    fn bitor_assign( &mut self, other:&BigInt ) {
                        match ( self.sign, other.sign ) {
                            ( _, NoSign ) => {}
                            ( NoSign, _ ) => self.clone_from( other ),
                            ( Plus, Plus ) => self.data |= &other.data,
                            ( Plus, Minus ) => {
                                bitor_pos_neg( self.digits_mut(), other.digits() );
                                self.sign = Minus;
                                self.normalize();
                            }
                            ( Minus, Plus ) => {
                                bitor_neg_pos( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                            ( Minus, Minus ) => {
                                bitor_neg_neg( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                        }
                    }
                }
                fn bitxor_pos_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_b = 1;
                    let mut carry_xor = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( *ai ^ twos_b, &mut carry_xor );
                    }
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_b = !0;
                                *ai = negate_carry( *ai ^ twos_b, &mut carry_xor );
                            }
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_b = negate_carry( bi, &mut carry_b );
                                negate_carry( twos_b, &mut carry_xor )
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                    if carry_xor != 0 {
                        a.push( 1 );
                    }
                }
                fn bitxor_neg_pos( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_xor = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = negate_carry( twos_a ^ bi, &mut carry_xor );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry( *ai, &mut carry_a );
                                *ai = negate_carry( twos_a, &mut carry_xor );
                            }
                            debug_assert!( carry_a == 0 );
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_a = !0;
                                negate_carry( twos_a ^ bi, &mut carry_xor )
                            } ) );
                        }
                    }
                    if carry_xor != 0 {
                        a.push( 1 );
                    }
                }
                fn bitxor_neg_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = twos_a ^ twos_b;
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry( *ai, &mut carry_a );
                                let twos_b = !0;
                                *ai = twos_a ^ twos_b;
                            }
                            debug_assert!( carry_a == 0 );
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_a = !0;
                                let twos_b = negate_carry( bi, &mut carry_b );
                                twos_a ^ twos_b
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                }
                forward_all_binop_to_val_ref_commutative!( impl BitXor for BigInt, bitxor );

                impl BitXor<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitxor( mut self, other:&BigInt ) -> BigInt {
                        self ^= other;
                        self
                    }
                }
                forward_val_assign!( impl BitXorAssign for BigInt, bitxor_assign );

                impl BitXorAssign<&BigInt> for BigInt
                {
                    fn bitxor_assign( &mut self, other:&BigInt ) {
                        match ( self.sign, other.sign ) {
                            ( _, NoSign ) => {}
                            ( NoSign, _ ) => self.clone_from( other ),
                            ( Plus, Plus ) => {
                                self.data ^= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            ( Plus, Minus ) => {
                                bitxor_pos_neg( self.digits_mut(), other.digits() );
                                self.sign = Minus;
                                self.normalize();
                            }
                            ( Minus, Plus ) => {
                                bitxor_neg_pos( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                            ( Minus, Minus ) => {
                                bitxor_neg_neg( self.digits_mut(), other.digits() );
                                self.sign = Plus;
                                self.normalize();
                            }
                        }
                    }
                }
                pub fn set_negative_bit( x:&mut BigInt, bit: u64, value: bool )
                {
                    debug_assert_eq!( x.sign, Minus );
                    let data = &mut x.data;

                    let bits_per_digit = u64::from( ::num::big::digit::BITS );
                    if bit >= bits_per_digit * data.len() as u64 {
                        if !value {
                            data.set_bit( bit, true );
                        }
                    } else {
                       
                       
                       
                       
                       
                       
                        let trailing_zeros = data.trailing_zeros().unwrap();
                        if bit > trailing_zeros {
                            data.set_bit( bit, !value );
                        } else if bit == trailing_zeros && !value {
                           
                           
                           
                           
                           
                            let bit_index = ( bit / bits_per_digit ).to_usize().unwrap();
                            let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                            let mut digit_iter = data.digits_mut().iter_mut().skip( bit_index );
                            let mut carry_in = 1;
                            let mut carry_out = 1;

                            let digit = digit_iter.next().unwrap();
                            let twos_in = negate_carry( *digit, &mut carry_in );
                            let twos_out = twos_in & !bit_mask;
                            *digit = negate_carry( twos_out, &mut carry_out );

                            for digit in digit_iter {
                                if carry_in == 0 && carry_out == 0 {
                                   
                                    break;
                                }
                                let twos = negate_carry( *digit, &mut carry_in );
                                *digit = negate_carry( twos, &mut carry_out );
                            }
                            if carry_out != 0 {
                               
                                debug_assert_eq!( carry_in, 0 );
                                data.digits_mut().push( 1 );
                            }
                        } else if bit < trailing_zeros && value {
                           
                           
                           
                           
                           
                           
                            let index_lo = ( bit / bits_per_digit ).to_usize().unwrap();
                            let index_hi = ( trailing_zeros / bits_per_digit ).to_usize().unwrap();
                            let bit_mask_lo = ::num::big::digit::MAX << ( bit % bits_per_digit );
                            let bit_mask_hi =
                                ::num::big::digit::MAX >> ( bits_per_digit - 1 - ( trailing_zeros % bits_per_digit ) );
                            let digits = data.digits_mut();

                            if index_lo == index_hi {
                                digits[index_lo] ^= bit_mask_lo & bit_mask_hi;
                            } else {
                                digits[index_lo] = bit_mask_lo;
                                for digit in &mut digits[index_lo + 1..index_hi] {
                                    *digit = ::num::big::digit::MAX;
                                }
                                digits[index_hi] ^= bit_mask_hi;
                            }
                        } else {
                           
                           
                           
                        }
                    }
                }
            }
            pub mod convert
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    convert::{ TryFrom },
                    num::
                    {
                        big::{ BigUint, ParseBigIntError, ToBigUint, TryFromBigIntError },
                        traits::{ FromPrimitive, Num, One, ToPrimitive, Zero },
                    },
                    str::{ self, FromStr },
                    vec::{ Vec },
                    *,
                };
                use super::Sign::{self, Minus, NoSign, Plus};
                use super::{BigInt, ToBigInt};
                /*
                */
                impl FromStr for BigInt
                {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str( s:&str ) -> Result<BigInt, ParseBigIntError> {
                        BigInt::from_str_radix( s, 10 )
                    }
                }
                impl Num for BigInt
                {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a [`BigInt`].
                    #[inline] fn from_str_radix( mut s:&str, radix: u32 ) -> Result<BigInt, ParseBigIntError> {
                        let sign = if let Some( tail ) = s.strip_prefix( '-' ) {
                            if !tail.starts_with( '+' ) {
                                s = tail
                            }
                            Minus
                        } else {
                            Plus
                        };
                        let bu = BigUint::from_str_radix( s, radix )?;
                        Ok( BigInt::from_biguint( sign, bu ) )
                    }
                }
                impl ToPrimitive for BigInt
                {
                    #[inline] fn to_i64( &self ) -> Option<i64> {
                        match self.sign {
                            Plus => self.data.to_i64(),
                            NoSign => Some( 0 ),
                            Minus => {
                                let n = self.data.to_u64()?;
                                let m: u64 = 1 << 63;
                                match n.cmp( &m ) {
                                    Less => Some( -( n as i64 ) ),
                                    Equal => Some( i64::MIN ),
                                    Greater => None,
                                }
                            }
                        }
                    }
                    #[inline] fn to_i128( &self ) -> Option<i128> {
                        match self.sign {
                            Plus => self.data.to_i128(),
                            NoSign => Some( 0 ),
                            Minus => {
                                let n = self.data.to_u128()?;
                                let m: u128 = 1 << 127;
                                match n.cmp( &m ) {
                                    Less => Some( -( n as i128 ) ),
                                    Equal => Some( i128::MIN ),
                                    Greater => None,
                                }
                            }
                        }
                    }
                    #[inline] fn to_u64( &self ) -> Option<u64> {
                        match self.sign {
                            Plus => self.data.to_u64(),
                            NoSign => Some( 0 ),
                            Minus => None,
                        }
                    }
                    #[inline] fn to_u128( &self ) -> Option<u128> {
                        match self.sign {
                            Plus => self.data.to_u128(),
                            NoSign => Some( 0 ),
                            Minus => None,
                        }
                    }
                    #[inline] fn to_f32( &self ) -> Option<f32> {
                        let n = self.data.to_f32()?;
                        Some( if self.sign == Minus { -n } else { n } )
                    }
                    #[inline] fn to_f64( &self ) -> Option<f64> {
                        let n = self.data.to_f64()?;
                        Some( if self.sign == Minus { -n } else { n } )
                    }
                }
                macro_rules! impl_try_from_bigint 
                {
                    ( $T:ty, $to_ty:path ) => {
                        impl TryFrom<&BigInt> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from( value:&BigInt ) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty( value ).ok_or( TryFromBigIntError::new( () ) )
                            }
                        }
                        impl TryFrom<BigInt> for $T {
                            type Error = TryFromBigIntError<BigInt>;

                            #[inline]
                            fn try_from( value: BigInt ) -> Result<$T, TryFromBigIntError<BigInt>> {
                                <$T>::try_from( &value ).map_err( |_| TryFromBigIntError::new( value ) )
                            }
                        }
                    };
                }
                impl_try_from_bigint!( u8, ToPrimitive::to_u8 );
                impl_try_from_bigint!( u16, ToPrimitive::to_u16 );
                impl_try_from_bigint!( u32, ToPrimitive::to_u32 );
                impl_try_from_bigint!( u64, ToPrimitive::to_u64 );
                impl_try_from_bigint!( usize, ToPrimitive::to_usize );
                impl_try_from_bigint!( u128, ToPrimitive::to_u128 );

                impl_try_from_bigint!( i8, ToPrimitive::to_i8 );
                impl_try_from_bigint!( i16, ToPrimitive::to_i16 );
                impl_try_from_bigint!( i32, ToPrimitive::to_i32 );
                impl_try_from_bigint!( i64, ToPrimitive::to_i64 );
                impl_try_from_bigint!( isize, ToPrimitive::to_isize );
                impl_try_from_bigint!( i128, ToPrimitive::to_i128 );

                impl FromPrimitive for BigInt
                {
                    #[inline] fn from_i64( n: i64 ) -> Option<BigInt> {
                        Some( BigInt::from( n ) )
                    }
                    #[inline] fn from_i128( n: i128 ) -> Option<BigInt> {
                        Some( BigInt::from( n ) )
                    }
                    #[inline] fn from_u64( n: u64 ) -> Option<BigInt> {
                        Some( BigInt::from( n ) )
                    }
                    #[inline] fn from_u128( n: u128 ) -> Option<BigInt> {
                        Some( BigInt::from( n ) )
                    }
                    #[inline] fn from_f64( n: f64 ) -> Option<BigInt> {
                        if n >= 0.0 {
                            BigUint::from_f64( n ).map( BigInt::from )
                        } else {
                            let x = BigUint::from_f64( -n )?;
                            Some( -BigInt::from( x ) )
                        }
                    }
                }
                impl From<i64> for BigInt
                {
                    #[inline] fn from( n: i64 ) -> Self {
                        if n >= 0 {
                            BigInt::from( n as u64 )
                        } else {
                            let u = u64::MAX - ( n as u64 ) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from( u ),
                            }
                        }
                    }
                }
                impl From<i128> for BigInt
                {
                    #[inline] fn from( n: i128 ) -> Self {
                        if n >= 0 {
                            BigInt::from( n as u128 )
                        } else {
                            let u = u128::MAX - ( n as u128 ) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from( u ),
                            }
                        }
                    }
                }
                macro_rules! impl_bigint_from_int 
                {
                    ( $T:ty ) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from( n: $T ) -> Self {
                                BigInt::from( n as i64 )
                            }
                        }
                    };
                }
                impl_bigint_from_int!( i8 );
                impl_bigint_from_int!( i16 );
                impl_bigint_from_int!( i32 );
                impl_bigint_from_int!( isize );

                impl From<u64> for BigInt
                {
                    #[inline] fn from( n: u64 ) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from( n ),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }
                impl From<u128> for BigInt
                {
                    #[inline] fn from( n: u128 ) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from( n ),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }
                macro_rules! impl_bigint_from_uint 
                {
                    ( $T:ty ) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from( n: $T ) -> Self {
                                BigInt::from( n as u64 )
                            }
                        }
                    };
                }
                impl_bigint_from_uint!( u8 );
                impl_bigint_from_uint!( u16 );
                impl_bigint_from_uint!( u32 );
                impl_bigint_from_uint!( usize );

                impl From<BigUint> for BigInt
                {
                    #[inline] fn from( n: BigUint ) -> Self {
                        if n.is_zero() {
                            Self::ZERO
                        } else {
                            BigInt {
                                sign: Plus,
                                data: n,
                            }
                        }
                    }
                }
                impl ToBigInt for BigInt
                {
                    #[inline] fn to_bigint( &self ) -> Option<BigInt> {
                        Some( self.clone() )
                    }
                }
                impl ToBigInt for BigUint
                {
                    #[inline] fn to_bigint( &self ) -> Option<BigInt> {
                        if self.is_zero() {
                            Some( BigInt::ZERO )
                        } else {
                            Some( BigInt {
                                sign: Plus,
                                data: self.clone(),
                            } )
                        }
                    }
                }
                impl ToBigUint for BigInt
                {
                    #[inline] fn to_biguint( &self ) -> Option<BigUint> {
                        match self.sign() {
                            Plus => Some( self.data.clone() ),
                            NoSign => Some( BigUint::ZERO ),
                            Minus => None,
                        }
                    }
                }
                impl TryFrom<&BigInt> for BigUint
                {
                    type Error = TryFromBigIntError<()>;

                    #[inline] fn try_from( value:&BigInt ) -> Result<BigUint, TryFromBigIntError<()>> {
                        value
                            .to_biguint()
                            .ok_or_else( || TryFromBigIntError::new( () ) )
                    }
                }
                impl TryFrom<BigInt> for BigUint
                {
                    type Error = TryFromBigIntError<BigInt>;

                    #[inline] fn try_from( value: BigInt ) -> Result<BigUint, TryFromBigIntError<BigInt>> {
                        if value.sign() == Sign::Minus {
                            Err( TryFromBigIntError::new( value ) )
                        } else {
                            Ok( value.data )
                        }
                    }
                }
                macro_rules! impl_to_bigint
                {
                    ( $T:ty, $from_ty:path ) => {
                        impl ToBigInt for $T {
                            #[inline]
                            fn to_bigint( &self ) -> Option<BigInt> {
                                $from_ty( *self )
                            }
                        }
                    };
                }
                impl_to_bigint!( isize, FromPrimitive::from_isize );
                impl_to_bigint!( i8, FromPrimitive::from_i8 );
                impl_to_bigint!( i16, FromPrimitive::from_i16 );
                impl_to_bigint!( i32, FromPrimitive::from_i32 );
                impl_to_bigint!( i64, FromPrimitive::from_i64 );
                impl_to_bigint!( i128, FromPrimitive::from_i128 );

                impl_to_bigint!( usize, FromPrimitive::from_usize );
                impl_to_bigint!( u8, FromPrimitive::from_u8 );
                impl_to_bigint!( u16, FromPrimitive::from_u16 );
                impl_to_bigint!( u32, FromPrimitive::from_u32 );
                impl_to_bigint!( u64, FromPrimitive::from_u64 );
                impl_to_bigint!( u128, FromPrimitive::from_u128 );

                impl_to_bigint!( f32, FromPrimitive::from_f32 );
                impl_to_bigint!( f64, FromPrimitive::from_f64 );

                impl From<bool> for BigInt 
                {
                    fn from( x: bool ) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }
                #[inline] pub fn from_signed_bytes_be( digits:&[u8] ) -> BigInt 
                {
                    let sign = match digits.first() {
                        Some( v ) if *v > 0x7f => Sign::Minus,
                        Some( _ ) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from( digits );
                        twos_complement_be( &mut digits );
                        BigInt::from_biguint( sign, BigUint::from_bytes_be( &digits ) )
                    } else {
                        BigInt::from_biguint( sign, BigUint::from_bytes_be( digits ) )
                    }
                }
                #[inline] pub fn from_signed_bytes_le( digits:&[u8] ) -> BigInt 
                {
                    let sign = match digits.last() {
                        Some( v ) if *v > 0x7f => Sign::Minus,
                        Some( _ ) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from( digits );
                        twos_complement_le( &mut digits );
                        BigInt::from_biguint( sign, BigUint::from_bytes_le( &digits ) )
                    } else {
                        BigInt::from_biguint( sign, BigUint::from_bytes_le( digits ) )
                    }
                }
                #[inline] pub fn to_signed_bytes_be( x:&BigInt ) -> Vec<u8> 
                {
                    let mut bytes = x.data.to_bytes_be();
                    let first_byte = bytes.first().cloned().unwrap_or( 0 );
                    if first_byte > 0x7f
                        && !( first_byte == 0x80 && bytes.iter().skip( 1 ).all( Zero::is_zero ) && x.sign == Sign::Minus )
                    {
                       
                        bytes.insert( 0, 0 );
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_be( &mut bytes );
                    }
                    bytes
                }
                #[inline] pub fn to_signed_bytes_le( x:&BigInt ) -> Vec<u8> 
                {
                    let mut bytes = x.data.to_bytes_le();
                    let last_byte = bytes.last().cloned().unwrap_or( 0 );
                    if last_byte > 0x7f
                        && !( last_byte == 0x80
                            && bytes.iter().rev().skip( 1 ).all( Zero::is_zero )
                            && x.sign == Sign::Minus )
                    {
                       
                        bytes.push( 0 );
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_le( &mut bytes );
                    }
                    bytes
                }
                /// Perform in-place two's complement of the given binary representation, in little-endian byte order.
                #[inline] fn twos_complement_le( digits:&mut [u8] )
                {
                    twos_complement( digits )
                }
                /// Perform in-place two's complement of the given binary representation in big-endian byte order.
                #[inline] fn twos_complement_be( digits:&mut [u8] )
                {
                    twos_complement( digits.iter_mut().rev() )
                }
                /// Perform in-place two's complement of the given digit iterator starting from the least significant byte.
                #[inline] fn twos_complement<'a, I>( digits: I ) where
                I: IntoIterator<Item = &'a mut u8>
                {
                    let mut carry = true;
                    for d in digits {
                        *d = !*d;
                        if carry {
                            *d = d.wrapping_add( 1 );
                            carry = d.is_zero();
                        }
                    }
                }
            }
            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::{ BigUint }, 
                        integers::Integer,
                        traits::{Pow, Signed, Zero},
                    },
                    *,
                };
                use super::BigInt;
                use super::Sign::{self, Minus, Plus};
                /*
                */
                /// Help function for pow
                ///
                /// Computes the effect of the exponent on the sign.
                #[inline] fn powsign<T: Integer>( sign: Sign, other:&T ) -> Sign {
                    if other.is_zero() {
                        Plus
                    } else if sign != Minus || other.is_odd() {
                        sign
                    } else {
                        -sign
                    }
                }
                macro_rules! pow_impl {
                    ( $T:ty ) => {
                        impl Pow<$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs: $T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, &rhs ), self.data.pow( rhs ) )
                            }
                        }
                        impl Pow<&$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs:&$T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, rhs ), self.data.pow( rhs ) )
                            }
                        }
                        impl Pow<$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs: $T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, &rhs ), Pow::pow( &self.data, rhs ) )
                            }
                        }
                        impl Pow<&$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs:&$T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, rhs ), Pow::pow( &self.data, rhs ) )
                            }
                        }
                    };
                }
                pow_impl!( u8 );
                pow_impl!( u16 );
                pow_impl!( u32 );
                pow_impl!( u64 );
                pow_impl!( usize );
                pow_impl!( u128 );
                pow_impl!( BigUint );

                pub( super ) fn modpow( x:&BigInt, exponent:&BigInt, modulus:&BigInt ) -> BigInt {
                    assert!( 
                        !exponent.is_negative(),
                        "negative exponentiation is not supported!"
                     );
                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );

                    let result = x.data.modpow( &exponent.data, &modulus.data );
                    if result.is_zero() {
                        return BigInt::ZERO;
                    }
                   
                    let ( sign, mag ) = match ( x.is_negative() && exponent.is_odd(), modulus.is_negative() ) {
                        ( false, false ) => ( Plus, result ),
                        ( true, false ) => ( Plus, &modulus.data - result ),
                        ( false, true ) => ( Minus, &modulus.data - result ),
                        ( true, true ) => ( Minus, result ),
                    };
                    BigInt::from_biguint( sign, mag )
                }
            }
            pub mod shift
            {
                use ::
                {
                    num::traits::{ PrimInt, Signed, Zero },
                    ops::{ Shl, ShlAssign, Shr, ShrAssign },
                    *,
                };
                use super::BigInt;
                use super::Sign::NoSign;
                /*
                */
                macro_rules! impl_shift
                {
                    ( @ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty ) => {
                        impl $Shx<&$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigInt {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $Shx<&$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigInt {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigInt {
                            #[inline]
                            fn $shx_assign( &mut self, rhs:&$rhs ) {
                                $ShxAssign::$shx_assign( self, *rhs );
                            }
                        }
                    };
                    ( $( $rhs:ty ),+ ) => {$( 
                        impl Shl<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigInt {
                                BigInt::from_biguint( self.sign, self.data << rhs )
                            }
                        }
                        impl Shl<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigInt {
                                BigInt::from_biguint( self.sign, &self.data << rhs )
                            }
                        }
                        impl ShlAssign<$rhs> for BigInt {
                            #[inline]
                            fn shl_assign( &mut self, rhs: $rhs ) {
                                self.data <<= rhs
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }
                        impl Shr<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigInt {
                                let round_down = shr_round_down( &self, rhs );
                                let data = self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint( self.sign, data )
                            }
                        }
                        impl Shr<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigInt {
                                let round_down = shr_round_down( self, rhs );
                                let data = &self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint( self.sign, data )
                            }
                        }
                        impl ShrAssign<$rhs> for BigInt {
                            #[inline]
                            fn shr_assign( &mut self, rhs: $rhs ) {
                                let round_down = shr_round_down( self, rhs );
                                self.data >>= rhs;
                                if round_down {
                                    self.data += 1u8;
                                } else if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }
                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
                
                fn shr_round_down<T: PrimInt>( i:&BigInt, shift: T ) -> bool
                {
                    if i.is_negative() {
                        let zeros = i.trailing_zeros().expect( "negative values are non-zero" );
                        shift > T::zero() && shift.to_u64().map( |shift| zeros < shift ).unwrap_or( true )
                    } else {
                        false
                    }
                }
            }
            /// A `Sign` is a [`BigInt`]'s composing element.
            #[derive( PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash )]
            pub enum Sign 
            {
                Minus,
                NoSign,
                Plus,
            }
            
            impl Neg for Sign 
            {
                type Output = Sign;
                /// Negate `Sign` value.
                #[inline] fn neg( self ) -> Sign {
                    match self {
                        Minus => Plus,
                        NoSign => NoSign,
                        Plus => Minus,
                    }
                }
            }
            /// A big signed integer type.
            pub struct BigInt 
            {
                sign: Sign,
                data: BigUint,
            }
                       
            impl Clone for BigInt
            {
                #[inline] fn clone( &self ) -> Self {
                    BigInt {
                        sign: self.sign,
                        data: self.data.clone(),
                    }
                }
                #[inline] fn clone_from( &mut self, other:&Self ) {
                    self.sign = other.sign;
                    self.data.clone_from( &other.data );
                }
            }
            
            impl hash::Hash for BigInt
            {
                #[inline] fn hash<H: hash::Hasher>( &self, state:&mut H ) {
                    debug_assert!( ( self.sign != NoSign ) ^ self.data.is_zero() );
                    self.sign.hash( state  );
                    if self.sign != NoSign {
                        self.data.hash( state  );
                    }
                }
            }
            
            impl PartialEq for BigInt
            {
                #[inline] fn eq( &self, other:&BigInt ) -> bool {
                    debug_assert!( ( self.sign != NoSign ) ^ self.data.is_zero() );
                    debug_assert!( ( other.sign != NoSign ) ^ other.data.is_zero() );
                    self.sign == other.sign && ( self.sign == NoSign || self.data == other.data )
                }
            }
            
            impl Eq for BigInt {}
            
            impl PartialOrd for BigInt
            {
                #[inline] fn partial_cmp( &self, other:&BigInt ) -> Option<Ordering> {
                    Some( self.cmp( other ) )
                }
            }
            
            impl Ord for BigInt
            {
                #[inline] fn cmp( &self, other:&BigInt ) -> Ordering {
                    debug_assert!( ( self.sign != NoSign ) ^ self.data.is_zero() );
                    debug_assert!( ( other.sign != NoSign ) ^ other.data.is_zero() );
                    let scmp = self.sign.cmp( &other.sign );
                    if scmp != Equal {
                        return scmp;
                    }
                    match self.sign {
                        NoSign => Equal,
                        Plus => self.data.cmp( &other.data ),
                        Minus => other.data.cmp( &self.data ),
                    }
                }
            }
            
            impl Default for BigInt
            {
                #[inline] fn default() -> BigInt {
                    Self::ZERO
                }
            }
            
            impl fmt::Debug for BigInt
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    fmt::Display::fmt( self, f )
                }
            }
            
            impl fmt::Display for BigInt
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "", &self.data.to_str_radix( 10 ) )
                }
            }
            
            impl fmt::Binary for BigInt
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "0b", &self.data.to_str_radix( 2 ) )
                }
            }
            
            impl fmt::Octal for BigInt
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "0o", &self.data.to_str_radix( 8 ) )
                }
            }
            
            impl fmt::LowerHex for BigInt
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "0x", &self.data.to_str_radix( 16 ) )
                }
            }
            
            impl fmt::UpperHex for BigInt
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    let mut s = self.data.to_str_radix( 16 );
                    s.make_ascii_uppercase();
                    f.pad_integral( !self.is_negative(), "0x", &s )
                }
            }
            
            impl Not for BigInt
            {
                type  Output = BigInt;

                fn not( mut self ) -> BigInt {
                    match self.sign {
                        NoSign | Plus => {
                            self.data += 1u32;
                            self.sign = Minus;
                        }
                        Minus => {
                            self.data -= 1u32;
                            self.sign = if self.data.is_zero() { NoSign } else { Plus };
                        }
                    }
                    self
                }
            }
            
            impl Not for &BigInt
            {
                type  Output = BigInt;

                fn not( self ) -> BigInt {
                    match self.sign {
                        NoSign => -BigInt::one(),
                        Plus => -BigInt::from( &self.data + 1u32 ),
                        Minus => BigInt::from( &self.data - 1u32 ),
                    }
                }
            }
            
            impl Zero for BigInt
            {
                #[inline] fn zero() -> BigInt {
                    Self::ZERO
                }
                #[inline] fn set_zero( &mut self ) {
                    self.data.set_zero();
                    self.sign = NoSign;
                }
                #[inline] fn is_zero( &self ) -> bool {
                    self.sign == NoSign
                }
            }
            
            impl ConstZero for BigInt 
            {
               
                const ZERO: Self = Self::ZERO;
            }
            
            impl One for BigInt
            {
                #[inline] fn one() -> BigInt {
                    BigInt {
                        sign: Plus,
                        data: BigUint::one(),
                    }
                }
                #[inline] fn set_one( &mut self ) {
                    self.data.set_one();
                    self.sign = Plus;
                }
                #[inline] fn is_one( &self ) -> bool {
                    self.sign == Plus && self.data.is_one()
                }
            }
            
            impl Signed for BigInt
            {
                #[inline] fn abs( &self ) -> BigInt {
                    match self.sign {
                        Plus | NoSign => self.clone(),
                        Minus => BigInt::from( self.data.clone() ),
                    }
                }
                #[inline] fn abs_sub( &self, other:&BigInt ) -> BigInt {
                    if *self <= *other {
                        Self::ZERO
                    } else {
                        self - other
                    }
                }
                #[inline] fn signum( &self ) -> BigInt {
                    match self.sign {
                        Plus => BigInt::one(),
                        Minus => -BigInt::one(),
                        NoSign => Self::ZERO,
                    }
                }
                #[inline] fn is_positive( &self ) -> bool {
                    self.sign == Plus
                }
                #[inline] fn is_negative( &self ) -> bool {
                    self.sign == Minus
                }
            }
            trait UnsignedAbs 
            {
                type Unsigned;

                fn checked_uabs( self ) -> CheckedUnsignedAbs<Self::Unsigned>;
            }
            enum CheckedUnsignedAbs<T> 
            {
                Positive( T ),
                Negative( T ),
            } use self::CheckedUnsignedAbs::{Negative, Positive};

            macro_rules! impl_unsigned_abs
            {
                ( $Signed:ty, $Unsigned:ty ) => {
                    impl UnsignedAbs for $Signed {
                        type Unsigned = $Unsigned;

                        #[inline]
                        fn checked_uabs( self ) -> CheckedUnsignedAbs<Self::Unsigned> {
                            if self >= 0 {
                                Positive( self as $Unsigned )
                            } else {
                                Negative( self.wrapping_neg() as $Unsigned )
                            }
                        }
                    }
                };
            }
            impl_unsigned_abs!( i8, u8 );
            impl_unsigned_abs!( i16, u16 );
            impl_unsigned_abs!( i32, u32 );
            impl_unsigned_abs!( i64, u64 );
            impl_unsigned_abs!( i128, u128 );
            impl_unsigned_abs!( isize, usize );

            impl Neg for BigInt
            {
                type  Output = BigInt;

                #[inline] fn neg( mut self ) -> BigInt {
                    self.sign = -self.sign;
                    self
                }
            }
            
            impl Neg for &BigInt
            {
                type Output = BigInt;

                #[inline] fn neg( self ) -> BigInt 
                {
                    -self.clone()
                }
            }
            
            impl Integer for BigInt
            {
                #[inline] fn div_rem( &self, other:&BigInt ) -> ( BigInt, BigInt ) {
                   
                    let ( d_ui, r_ui ) = self.data.div_rem( &other.data );
                    let d = BigInt::from_biguint( self.sign, d_ui );
                    let r = BigInt::from_biguint( self.sign, r_ui );
                    if other.is_negative() {
                        ( -d, r )
                    } else {
                        ( d, r )
                    }
                }
                #[inline] fn div_floor( &self, other:&BigInt ) -> BigInt {
                    let ( d_ui, m ) = self.data.div_mod_floor( &other.data );
                    let d = BigInt::from( d_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => d,
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => {
                            if m.is_zero() {
                                -d
                            } else {
                                -d - 1u32
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
                }
                #[inline] fn mod_floor( &self, other:&BigInt ) -> BigInt {
                   
                    let m_ui = self.data.mod_floor( &other.data );
                    let m = BigInt::from_biguint( other.sign, m_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => m,
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => {
                            if m.is_zero() {
                                m
                            } else {
                                other - m
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
                }
                fn div_mod_floor( &self, other:&BigInt ) -> ( BigInt, BigInt ) {
                   
                    let ( d_ui, m_ui ) = self.data.div_mod_floor( &other.data );
                    let d = BigInt::from( d_ui );
                    let m = BigInt::from_biguint( other.sign, m_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => ( d, m ),
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => {
                            if m.is_zero() {
                                ( -d, m )
                            } else {
                                ( -d - 1u32, other - m )
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
                }
                #[inline] fn div_ceil( &self, other:&Self ) -> Self {
                    let ( d_ui, m ) = self.data.div_mod_floor( &other.data );
                    let d = BigInt::from( d_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => -d,
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => {
                            if m.is_zero() {
                                d
                            } else {
                                d + 1u32
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
                }
                /// Calculates the Greatest Common Divisor ( GCD ) of the number and `other`.
                #[inline] fn gcd( &self, other:&BigInt ) -> BigInt {
                    BigInt::from( self.data.gcd( &other.data ) )
                }
                /// Calculates the Lowest Common Multiple ( LCM ) of the number and `other`.
                #[inline] fn lcm( &self, other:&BigInt ) -> BigInt {
                    BigInt::from( self.data.lcm( &other.data ) )
                }
                /// Calculates the Greatest Common Divisor ( GCD ) and
                /// Lowest Common Multiple ( LCM ) together.
                #[inline] fn gcd_lcm( &self, other:&BigInt ) -> ( BigInt, BigInt ) {
                    let ( gcd, lcm ) = self.data.gcd_lcm( &other.data );
                    ( BigInt::from( gcd ), BigInt::from( lcm ) )
                }
                /// Greatest common divisor, least common multiple, and Bzout coefficients.
                #[inline] fn extended_gcd_lcm( &self, other:&BigInt ) -> ( ::num::integers::ExtendedGcd<BigInt>, BigInt ) {
                    let egcd = self.extended_gcd( other );
                    let lcm = if egcd.gcd.is_zero() {
                        Self::ZERO
                    } else {
                        BigInt::from( &self.data / &egcd.gcd.data * &other.data )
                    };
                    ( egcd, lcm )
                }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides( &self, other:&BigInt ) -> bool {
                    self.is_multiple_of( other )
                }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of( &self, other:&BigInt ) -> bool {
                    self.data.is_multiple_of( &other.data )
                }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even( &self ) -> bool {
                    self.data.is_even()
                }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd( &self ) -> bool {
                    self.data.is_odd()
                }
                /// Rounds up to nearest multiple of argument.
                #[inline] fn next_multiple_of( &self, other:&Self ) -> Self {
                    let m = self.mod_floor( other );
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + ( other - m )
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self {
                    self - self.mod_floor( other )
                }
                fn dec( &mut self ) {
                    *self -= 1u32;
                }
                fn inc( &mut self ) {
                    *self += 1u32;
                }
            }
            
            impl Roots for BigInt
            {
                fn nth_root( &self, n: u32 ) -> Self
                {
                    assert!( 
                        !( self.is_negative() && n.is_even() ),
                        "root of degree {} is imaginary",
                        n
                     );

                    BigInt::from_biguint( self.sign, self.data.nth_root( n ) )
                }
                fn sqrt( &self ) -> Self
                {
                    assert!( !self.is_negative(), "square root is imaginary" );

                    BigInt::from_biguint( self.sign, self.data.sqrt() )
                }
                fn cbrt( &self ) -> Self
                {
                    BigInt::from_biguint( self.sign, self.data.cbrt() )
                }
            }
            
            impl IntDigits for BigInt
            {
                #[inline] fn digits( &self ) -> &[BigDigit] { self.data.digits() }
                #[inline] fn digits_mut( &mut self ) -> &mut Vec<BigDigit> { self.data.digits_mut() }
                #[inline] fn normalize( &mut self )
                {
                    self.data.normalize();
                    if self.data.is_zero() { self.sign = NoSign; }
                }
                #[inline] fn capacity( &self ) -> usize { self.data.capacity() }
                #[inline] fn len( &self ) -> usize { self.data.len() }
            }
            /// A generic trait for converting a value to a [`BigInt`].
            pub trait ToBigInt
            {
                /// Converts the value of `self` to a [`BigInt`].
                fn to_bigint( &self ) -> Option<BigInt>;
            }
            
            impl BigInt
            {
                /// A constant `BigInt` with value 0, useful for static initialization.
                pub const ZERO: Self = BigInt {
                    sign: NoSign,
                    data: BigUint::ZERO,
                };
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn new( sign: Sign, digits: Vec<u32> ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::new( digits ) )
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_biguint( mut sign: Sign, mut data: BigUint ) -> BigInt {
                    if sign == NoSign {
                        data.assign_from_slice( &[] );
                    } else if data.is_zero() {
                        sign = NoSign;
                    }
                    BigInt { sign, data }
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_slice( sign: Sign, slice:&[u32] ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::from_slice( slice ) )
                }
                /// Reinitializes a [`BigInt`].
                #[inline] pub fn assign_from_slice( &mut self, sign: Sign, slice:&[u32] ) {
                    if sign == NoSign {
                        self.set_zero();
                    } else {
                        self.data.assign_from_slice( slice );
                        self.sign = if self.data.is_zero() { NoSign } else { sign };
                    }
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_bytes_be( sign: Sign, bytes:&[u8] ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::from_bytes_be( bytes ) )
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn from_bytes_le( sign: Sign, bytes:&[u8] ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::from_bytes_le( bytes ) )
                }
                /// Creates and initializes a [`BigInt`] from an array of bytes in
                /// two's complement binary representation.
                #[inline] pub fn from_signed_bytes_be( digits:&[u8] ) -> BigInt {
                    convert::from_signed_bytes_be( digits )
                }
                /// Creates and initializes a [`BigInt`] from an array of bytes in two's complement.
                #[inline] pub fn from_signed_bytes_le( digits:&[u8] ) -> BigInt {
                    convert::from_signed_bytes_le( digits )
                }
                /// Creates and initializes a [`BigInt`].
                #[inline] pub fn parse_bytes( buf:&[u8], radix: u32 ) -> Option<BigInt> {
                    let s = str::from_utf8( buf ).ok()?;
                    BigInt::from_str_radix( s, radix ).ok()
                }
                /// Creates and initializes a [`BigInt`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                pub fn from_radix_be( sign: Sign, buf:&[u8], radix: u32 ) -> Option<BigInt> {
                    let u = BigUint::from_radix_be( buf, radix )?;
                    Some( BigInt::from_biguint( sign, u ) )
                }
                /// Creates and initializes a [`BigInt`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                pub fn from_radix_le( sign: Sign, buf:&[u8], radix: u32 ) -> Option<BigInt> {
                    let u = BigUint::from_radix_le( buf, radix )?;
                    Some( BigInt::from_biguint( sign, u ) )
                }
                /// Returns the sign and the byte representation of the [`BigInt`] in big-endian byte order.
                #[inline] pub fn to_bytes_be( &self ) -> ( Sign, Vec<u8> ) {
                    ( self.sign, self.data.to_bytes_be() )
                }
                /// Returns the sign and the byte representation of the [`BigInt`] in little-endian byte order.
                #[inline] pub fn to_bytes_le( &self ) -> ( Sign, Vec<u8> ) {
                    ( self.sign, self.data.to_bytes_le() )
                }
                /// Returns the sign and the `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn to_u32_digits( &self ) -> ( Sign, Vec<u32> ) {
                    ( self.sign, self.data.to_u32_digits() )
                }
                /// Returns the sign and the `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn to_u64_digits( &self ) -> ( Sign, Vec<u64> ) {
                    ( self.sign, self.data.to_u64_digits() )
                }
                /// Returns an iterator of `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u32_digits( &self ) -> U32Digits<'_> {
                    self.data.iter_u32_digits()
                }
                /// Returns an iterator of `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                #[inline] pub fn iter_u64_digits( &self ) -> U64Digits<'_> {
                    self.data.iter_u64_digits()
                }
                /// Returns the two's-complement byte representation of the [`BigInt`] in big-endian byte order.
                #[inline] pub fn to_signed_bytes_be( &self ) -> Vec<u8> {
                    convert::to_signed_bytes_be( self )
                }
                /// Returns the two's-complement byte representation of the [`BigInt`] in little-endian byte order.
                #[inline] pub fn to_signed_bytes_le( &self ) -> Vec<u8> {
                    convert::to_signed_bytes_le( self )
                }
                /// Returns the integer formatted as a string in the given radix.
                #[inline] pub fn to_str_radix( &self, radix: u32 ) -> String {
                    let mut v = to_str_radix_reversed( &self.data, radix );

                    if self.is_negative() {
                        v.push( b'-' );
                    }
                    v.reverse();
                    unsafe { String::from_utf8_unchecked( v ) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be( &self, radix: u32 ) -> ( Sign, Vec<u8> ) {
                    ( self.sign, self.data.to_radix_be( radix ) )
                }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le( &self, radix: u32 ) -> ( Sign, Vec<u8> ) {
                    ( self.sign, self.data.to_radix_le( radix ) )
                }
                /// Returns the sign of the [`BigInt`] as a [`Sign`].
                #[inline] pub fn sign( &self ) -> Sign {
                    self.sign
                }
                /// Returns the magnitude of the [`BigInt`] as a [`BigUint`].
                #[inline] pub fn magnitude( &self ) -> &BigUint {
                    &self.data
                }
                /// Convert this [`BigInt`] into its [`Sign`] and [`BigUint`] magnitude,
                /// the reverse of [`BigInt::from_biguint()`].
                #[inline] pub fn into_parts( self ) -> ( Sign, BigUint ) {
                    ( self.sign, self.data )
                }
                /// Determines the fewest bits necessary to express the [`BigInt`],
                /// not including the sign.
                #[inline] pub fn bits( &self ) -> u64 {
                    self.data.bits()
                }
                /// Converts this [`BigInt`] into a [`BigUint`], if it's not negative.
                #[inline] pub fn to_biguint( &self ) -> Option<BigUint> {
                    match self.sign {
                        Plus => Some( self.data.clone() ),
                        NoSign => Some( BigUint::ZERO ),
                        Minus => None,
                    }
                }
                #[inline] pub fn checked_add( &self, v:&BigInt ) -> Option<BigInt> {
                    Some( self + v )
                }
                #[inline] pub fn checked_sub( &self, v:&BigInt ) -> Option<BigInt> {
                    Some( self - v )
                }
                #[inline] pub fn checked_mul( &self, v:&BigInt ) -> Option<BigInt> {
                    Some( self * v )
                }
                #[inline] pub fn checked_div( &self, v:&BigInt ) -> Option<BigInt> {
                    if v.is_zero() {
                        return None;
                    }
                    Some( self / v )
                }
                /// Returns `self ^ exponent`.
                pub fn pow( &self, exponent: u32 ) -> Self {
                    Pow::pow( self, exponent )
                }
                /// Returns `( self ^ exponent ) mod modulus`
                pub fn modpow( &self, exponent:&Self, modulus:&Self ) -> Self {
                    power::modpow( self, exponent, modulus )
                }
                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                pub fn modinv( &self, modulus:&Self ) -> Option<Self> {
                    let result = self.data.modinv( &modulus.data )?;
                   
                    let ( sign, mag ) = match ( self.is_negative(), modulus.is_negative() ) {
                        ( false, false ) => ( Plus, result ),
                        ( true, false ) => ( Plus, &modulus.data - result ),
                        ( false, true ) => ( Minus, &modulus.data - result ),
                        ( true, true ) => ( Minus, result ),
                    };
                    Some( BigInt::from_biguint( sign, mag ) )
                }
                /// Returns the truncated principal square root of `self` --
                /// see [`::num::integers::Roots::sqrt()`].
                pub fn sqrt( &self ) -> Self {
                    Roots::sqrt( self )
                }
                /// Returns the truncated principal cube root of `self` --
                /// see [`::num::integers::Roots::cbrt()`].
                pub fn cbrt( &self ) -> Self {
                    Roots::cbrt( self )
                }
                /// Returns the truncated principal `n`th root of `self` --
                /// See [`::num::integers::Roots::nth_root()`].
                pub fn nth_root( &self, n: u32 ) -> Self {
                    Roots::nth_root( self, n )
                }
                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros( &self ) -> Option<u64> {
                    self.data.trailing_zeros()
                }
                /// Returns whether the bit in position `bit` is set,
                /// using the two's complement for negative numbers
                pub fn bit( &self, bit: u64 ) -> bool
                {
                    if self.is_negative()
                    {
                        if bit >= u64::from( ::num::big::digit::BITS ) * self.len() as u64
                        {
                            true
                        }
                        
                        else
                        {
                            let trailing_zeros = self.data.trailing_zeros().unwrap();
                            match Ord::cmp( &bit, &trailing_zeros ) {
                                Ordering::Less => false,
                                Ordering::Equal => true,
                                Ordering::Greater => !self.data.bit( bit ),
                            }
                        }
                    }
                    
                    else
                    {
                        self.data.bit( bit )
                    }
                }
                /// Sets or clears the bit in the given position, using the two's complement for negative numbers.
                pub fn set_bit( &mut self, bit: u64, value: bool )
                {
                    match self.sign {
                        Sign::Plus => self.data.set_bit( bit, value ),
                        Sign::Minus => bits::set_negative_bit( self, bit, value ),
                        Sign::NoSign => {
                            if value {
                                self.data.set_bit( bit, true );
                                self.sign = Sign::Plus;
                            } else {
                               
                            }
                        }
                    }
                   
                    self.normalize();
                }
            }
            
            impl ::num::traits::FromBytes for BigInt
            {
                type  Bytes = [u8];

                fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_signed_bytes_be( bytes )
                }
                fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_signed_bytes_le( bytes )
                }
            }
            
            impl ::num::traits::ToBytes for BigInt
            {
                type  Bytes = Vec<u8>;

                fn to_be_bytes( &self ) -> Self::Bytes {
                    self.to_signed_bytes_be()
                }
                fn to_le_bytes( &self ) -> Self::Bytes {
                    self.to_signed_bytes_le()
                }
            }
        }

        pub mod rand
        {
            //! Randomization of big integers
            use ::
            {
                num::
                {
                    big::{ uint::biguint_from_vec, BigInt, BigUint, Sign::* },
                    integers::{ Integer },
                    traits::{ ToPrimitive, Zero },
                },
                rand::
                {
                    Rng,
                    distributions::uniform::{SampleBorrow, SampleUniform, UniformSampler},
                    prelude::Distribution,
                },
                *,
            };
            /*
            */
            /// A trait for sampling random big integers.
            pub trait RandBigInt
            {
                /// Generate a random [`BigUint`] of the given bit size.
                fn gen_biguint( &mut self, bit_size: u64 ) -> BigUint;
                /// Generate a random [ BigInt`] of the given bit size.
                fn gen_bigint( &mut self, bit_size: u64 ) -> BigInt;
                /// Generate a random [`BigUint`] less than the given bound. Fails
                /// when the bound is zero.
                fn gen_biguint_below( &mut self, bound:&BigUint ) -> BigUint;
                /// Generate a random [`BigUint`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_biguint_range( &mut self, lbound:&BigUint, ubound:&BigUint ) -> BigUint;
                /// Generate a random [`BigInt`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_bigint_range( &mut self, lbound:&BigInt, ubound:&BigInt ) -> BigInt;
            }
            fn gen_bits<R: Rng + ?Sized>( rng:&mut R, data:&mut [u32], rem: u64 ) 
            {
               
                rng.fill( data );
                if rem > 0 {
                    let last = data.len() - 1;
                    data[last] >>= 32 - rem;
                }
            }
            
            impl<R: Rng + ?Sized> RandBigInt for R 
            {
                cfg_digit!( 
                    fn gen_biguint( &mut self, bit_size: u64 ) -> BigUint {
                        let ( digits, rem ) = bit_size.div_rem( &32 );
                        let len = ( digits + ( rem > 0 ) as u64 )
                            .to_usize()
                            .expect( "capacity overflow" );
                        let mut data = vec![0u32; len];
                        gen_bits( self, &mut data, rem );
                        biguint_from_vec( data )
                    }
                    fn gen_biguint( &mut self, bit_size: u64 ) -> BigUint {
                        use ::slice;

                        let ( digits, rem ) = bit_size.div_rem( &32 );
                        let len = ( digits + ( rem > 0 ) as u64 )
                            .to_usize()
                            .expect( "capacity overflow" );
                        let native_digits = Integer::div_ceil( &bit_size, &64 );
                        let native_len = native_digits.to_usize().expect( "capacity overflow" );
                        let mut data = vec![0u64; native_len];
                        unsafe {
                           
                            let ptr = data.as_mut_ptr() as *mut u32;
                            debug_assert!( native_len * 2 >= len );
                            let data = slice::from_raw_parts_mut( ptr, len );
                            gen_bits( self, data, rem );
                        }
                        #[cfg( target_endian = "big" )]
                        for digit in &mut data {
                           
                            *digit = ( *digit << 32 ) | ( *digit >> 32 );
                        }
                        biguint_from_vec( data )
                    }
                 );

                fn gen_bigint( &mut self, bit_size: u64 ) -> BigInt {
                    loop {
                       
                        let biguint = self.gen_biguint( bit_size );
                       
                        let sign = if biguint.is_zero() {
                           
                           
                           
                           
                            if self.gen() {
                                continue;
                            } else {
                                NoSign
                            }
                        } else if self.gen() {
                            Plus
                        } else {
                            Minus
                        };
                        return BigInt::from_biguint( sign, biguint );
                    }
                }
                fn gen_biguint_below( &mut self, bound:&BigUint ) -> BigUint {
                    assert!( !bound.is_zero() );
                    let bits = bound.bits();
                    loop {
                        let n = self.gen_biguint( bits );
                        if n < *bound {
                            return n;
                        }
                    }
                }
                fn gen_biguint_range( &mut self, lbound:&BigUint, ubound:&BigUint ) -> BigUint {
                    assert!( *lbound < *ubound );
                    if lbound.is_zero() {
                        self.gen_biguint_below( ubound )
                    } else {
                        lbound + self.gen_biguint_below( &( ubound - lbound ) )
                    }
                }
                fn gen_bigint_range( &mut self, lbound:&BigInt, ubound:&BigInt ) -> BigInt {
                    assert!( *lbound < *ubound );
                    if lbound.is_zero() {
                        BigInt::from( self.gen_biguint_below( ubound.magnitude() ) )
                    } else if ubound.is_zero() {
                        lbound + BigInt::from( self.gen_biguint_below( lbound.magnitude() ) )
                    } else {
                        let delta = ubound - lbound;
                        lbound + BigInt::from( self.gen_biguint_below( delta.magnitude() ) )
                    }
                }
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigUint`].
            #[derive( Clone, Debug )]
            pub struct UniformBigUint 
            {
                base: BigUint,
                len: BigUint,
            }
            
            impl UniformSampler for UniformBigUint 
            {
                type X = BigUint;

                #[inline] fn new<B1, B2>( low_b: B1, high_b: B2 ) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low < high );
                    UniformBigUint {
                        len: high - low,
                        base: low.clone(),
                    }
                }
                #[inline] fn new_inclusive<B1, B2>( low_b: B1, high_b: B2 ) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low <= high );
                    Self::new( low, high + 1u32 )
                }
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> Self::X {
                    &self.base + rng.gen_biguint_below( &self.len )
                }
                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>( low: B1, high: B2, rng:&mut R ) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_biguint_range( low.borrow(), high.borrow() )
                }
            }
            
            impl SampleUniform for BigUint 
            {
                type Sampler = UniformBigUint;
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigInt`].
            #[derive( Clone, Debug )]
            pub struct UniformBigInt 
            {
                base: BigInt,
                len: BigUint,
            }
            
            impl UniformSampler for UniformBigInt 
            {
                type X = BigInt;

                #[inline] fn new<B1, B2>( low_b: B1, high_b: B2 ) -> Self where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low < high );
                    UniformBigInt {
                        len: ( high - low ).into_parts().1,
                        base: low.clone(),
                    }
                }
                
                #[inline] fn new_inclusive<B1, B2>( low_b: B1, high_b: B2 ) -> Self where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low <= high );
                    Self::new( low, high + 1u32 )
                }

                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> Self::X 
                {
                    &self.base + BigInt::from( rng.gen_biguint_below( &self.len ) )
                }

                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>( low: B1, high: B2, rng:&mut R ) -> Self::X where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    rng.gen_bigint_range( low.borrow(), high.borrow() )
                }
            }
            
            impl SampleUniform for BigInt 
            {
                type Sampler = UniformBigInt;
            }
            /// A random distribution for [`BigUint`] and [`BigInt`] values of a particular bit size.
            #[derive( Clone, Copy, Debug )]
            pub struct RandomBits 
            {
                bits: u64,
            }
            
            impl RandomBits 
            {
                #[inline] pub fn new( bits: u64 ) -> RandomBits {
                    RandomBits { bits }
                }
            }
            
            impl Distribution<BigUint> for RandomBits 
            {
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> BigUint {
                    rng.gen_biguint( self.bits )
                }
            }
            
            impl Distribution<BigInt> for RandomBits 
            {
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> BigInt {
                    rng.gen_bigint( self.bits )
                }
            }
        }

        pub mod uint
        {
            use ::
            {
                cmp::{ self, Ordering },
                default::{ Default },
                num::
                {
                    big::digit::{ self, BigDigit },
                    integers::{ Integer, Roots },
                    traits::{ ConstZero, Num, One, Pow, ToPrimitive, Unsigned, Zero },
                },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /*
            */            
            pub mod addition
            {
                /*!
                */
                use ::
                {
                    iter::{ Sum },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit}, UsizePromotion
                        },
                        traits::CheckedAdd,
                    },
                    ops::{ Add, AddAssign },
                    *,
                };

                use super::{BigUint, IntDigits};
                /*
                */
                use ::arch::x86_64 as arch;
                
                cfg_64!( 
                    #[inline] fn adc( carry: u8, a: u64, b: u64, out:&mut u64 ) -> u8 {
                       
                       
                        unsafe { arch::_addcarry_u64( carry, a, b, out ) }
                    }
                 );
                /// Two argument addition of raw slices, `a += b`, returning the carry.
                #[inline] pub fn __add2( a:&mut [BigDigit], b:&[BigDigit] ) -> BigDigit {
                    debug_assert!( a.len() >= b.len() );

                    let mut carry = 0;
                    let ( a_lo, a_hi ) = a.split_at_mut( b.len() );

                    for ( a, b ) in a_lo.iter_mut().zip( b ) {
                        carry = adc( carry, *a, *b, a );
                    }
                    if carry != 0 {
                        for a in a_hi {
                            carry = adc( carry, *a, 0, a );
                            if carry == 0 {
                                break;
                            }
                        }
                    }
                    carry as BigDigit
                }
                /// Two argument addition of raw slices:
                /// a += b
                ///
                /// The caller _must_ ensure that a is big enough to store the result - typically this means
                /// resizing a to max( a.len(), b.len() ) + 1, to fit a possible carry.
                pub( super ) fn add2( a:&mut [BigDigit], b:&[BigDigit] ) {
                    let carry = __add2( a, b );

                    debug_assert!( carry == 0 );
                }
                forward_all_binop_to_val_ref_commutative!( impl Add for BigUint, add );
                forward_val_assign!( impl AddAssign for BigUint, add_assign );

                impl Add<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn add( mut self, other:&BigUint ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<&BigUint> for BigUint
                {
                    #[inline] fn add_assign( &mut self, other:&BigUint ) {
                        let self_len = self.data.len();
                        let carry = if self_len < other.data.len() {
                            let lo_carry = __add2( &mut self.data[..], &other.data[..self_len] );
                            self.data.extend_from_slice( &other.data[self_len..] );
                            __add2( &mut self.data[self_len..], &[lo_carry] )
                        } else {
                            __add2( &mut self.data[..], &other.data[..] )
                        };
                        if carry != 0 {
                            self.data.push( carry );
                        }
                    }
                }
                promote_unsigned_scalars!( impl Add for BigUint, add );
                promote_unsigned_scalars_assign!( impl AddAssign for BigUint, add_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u32> for BigUint, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u64> for BigUint, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u128> for BigUint, add );

                impl Add<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn add( mut self, other: u32 ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<u32> for BigUint
                {
                    #[inline] fn add_assign( &mut self, other: u32 ) {
                        if other != 0 {
                            if self.data.is_empty() {
                                self.data.push( 0 );
                            }
                            let carry = __add2( &mut self.data, &[other as BigDigit] );
                            if carry != 0 {
                                self.data.push( carry );
                            }
                        }
                    }
                }
                impl Add<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn add( mut self, other: u64 ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<u64> for BigUint {
                    cfg_digit!( 
                        #[inline]
                        fn add_assign( &mut self, other: u64 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push( 0 );
                                }
                                let carry = __add2( &mut self.data, &[lo, hi] );
                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }
                        #[inline]
                        fn add_assign( &mut self, other: u64 ) {
                            if other != 0 {
                                if self.data.is_empty() {
                                    self.data.push( 0 );
                                }
                                let carry = __add2( &mut self.data, &[other as BigDigit] );
                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }
                     );
                }
                impl Add<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn add( mut self, other: u128 ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<u128> for BigUint {
                    cfg_digit!( 
                        #[inline]
                        fn add_assign( &mut self, other: u128 ) {
                            if other <= u128::from( u64::MAX ) {
                                *self += other as u64
                            } else {
                                let ( a, b, c, d ) = super::u32_from_u128( other );
                                let carry = if a > 0 {
                                    while self.data.len() < 4 {
                                        self.data.push( 0 );
                                    }
                                    __add2( &mut self.data, &[d, c, b, a] )
                                } else {
                                    debug_assert!( b > 0 );
                                    while self.data.len() < 3 {
                                        self.data.push( 0 );
                                    }
                                    __add2( &mut self.data, &[d, c, b] )
                                };

                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }
                        #[inline]
                        fn add_assign( &mut self, other: u128 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push( 0 );
                                }
                                let carry = __add2( &mut self.data, &[lo, hi] );
                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }
                     );
                }
                impl CheckedAdd for BigUint
                {
                    #[inline] fn checked_add( &self, v:&BigUint ) -> Option<BigUint> {
                        Some( self.add( v ) )
                    }
                }
                impl_sum_iter_type!( BigUint );

            }
            pub mod division
            {
                /*!
                */
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit, DoubleBigDigit}, UsizePromotion
                        },
                        integers::Integer,
                        traits::{CheckedDiv, CheckedEuclid, Euclid, One, ToPrimitive, Zero},
                    },
                    ops::{Div, DivAssign, Rem, RemAssign},
                    *,
                };
                
                use super::addition::__add2;
                use super::{cmp_slice, BigUint};
                /*
                */
                pub const FAST_DIV_WIDE: bool = true;
                /// Divide a two digit numerator by a one digit divisor, returns quotient and remainder.
                #[inline] fn div_wide( hi: BigDigit, lo: BigDigit, divisor: BigDigit ) -> ( BigDigit, BigDigit )
                {
                   
                   
                   
                    debug_assert!( hi < divisor );

                   
                   
                   
                   
                    unsafe {
                        let ( div, rem );

                        cfg_digit!( 
                            macro_rules! div {
                                () => {
                                    "div {0:e}"
                                };
                            }
                            macro_rules! div {
                                () => {
                                    "div {0:r}"
                                };
                            }
                         );

                        ::arch::asm!( 
                            div!(),
                            in( reg ) divisor,
                            inout( "dx" ) hi => rem,
                            inout( "ax" ) lo => div,
                            options( pure, nomem, nostack ),
                         );

                        ( div, rem )
                    }
                }
                /// For small divisors, we can divide without promoting to `DoubleBigDigit`
                /// by using half-size pieces of digit, like long-division.
                #[inline] fn div_half( rem: BigDigit, digit: BigDigit, divisor: BigDigit ) -> ( BigDigit, BigDigit )
                {
                    use ::num::big::digit::{HALF, HALF_BITS};
                    debug_assert!( rem < divisor && divisor <= HALF );
                    let ( hi, rem ) = (( rem << HALF_BITS ) | ( digit >> HALF_BITS ) ).div_rem( &divisor );
                    let ( lo, rem ) = (( rem << HALF_BITS ) | ( digit & HALF ) ).div_rem( &divisor );
                    ( ( hi << HALF_BITS ) | lo, rem )
                }
                #[inline] pub fn div_rem_digit( mut a: BigUint, b: BigDigit ) -> ( BigUint, BigDigit )
                {
                    if b == 0 {
                        panic!( "attempt to divide by zero" )
                    }
                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= ::num::big::digit::HALF {
                        for d in a.data.iter_mut().rev() {
                            let ( q, r ) = div_half( rem, *d, b );
                            *d = q;
                            rem = r;
                        }
                    } else {
                        for d in a.data.iter_mut().rev() {
                            let ( q, r ) = div_wide( rem, *d, b );
                            *d = q;
                            rem = r;
                        }
                    }
                    ( a.normalized(), rem )
                }
                #[inline] fn rem_digit( a:&BigUint, b: BigDigit ) -> BigDigit
                {
                    if b == 0 {
                        panic!( "attempt to divide by zero" )
                    }
                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= ::num::big::digit::HALF {
                        for &digit in a.data.iter().rev() {
                            let ( _, r ) = div_half( rem, digit, b );
                            rem = r;
                        }
                    } else {
                        for &digit in a.data.iter().rev() {
                            let ( _, r ) = div_wide( rem, digit, b );
                            rem = r;
                        }
                    }
                    rem
                }
                /// Subtract a multiple.
                fn sub_mul_digit_same_len( a:&mut [BigDigit], b:&[BigDigit], c: BigDigit ) -> BigDigit
                {
                    debug_assert!( a.len() == b.len() );

                   
                   
                    let mut offset_carry = ::num::big::digit::MAX;

                    for ( x, y ) in a.iter_mut().zip( b ) {
                       
                       
                       
                       
                        let offset_sum = ::num::big::digit::to_doublebigdigit( ::num::big::digit::MAX, *x )
                            - ::num::big::digit::MAX as DoubleBigDigit
                            + offset_carry as DoubleBigDigit
                            - *y as DoubleBigDigit * c as DoubleBigDigit;

                        let ( new_offset_carry, new_x ) = ::num::big::digit::from_doublebigdigit( offset_sum );
                        offset_carry = new_offset_carry;
                        *x = new_x;
                    }
                   
                    ::num::big::digit::MAX - offset_carry
                }
                fn div_rem( mut u: BigUint, mut d: BigUint ) -> ( BigUint, BigUint )
                {
                    if d.is_zero() {
                        panic!( "attempt to divide by zero" )
                    }
                    if u.is_zero() {
                        return ( BigUint::ZERO, BigUint::ZERO );
                    }
                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return ( u, BigUint::ZERO );
                        }
                        let ( div, rem ) = div_rem_digit( u, d.data[0] );
                       
                        d.data.clear();
                        d += rem;
                        return ( div, d );
                    }
                   
                    match u.cmp( &d ) {
                        Less => return ( BigUint::ZERO, u ),
                        Equal => {
                            u.set_one();
                            return ( u, BigUint::ZERO );
                        }
                        Greater => {}
                    }
                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core( u, &d.data )
                    } else {
                        let ( q, r ) = div_rem_core( u << shift, &( d << shift ).data );
                       
                        ( q, r >> shift )
                    }
                }
                pub( super ) fn div_rem_ref( u:&BigUint, d:&BigUint ) -> ( BigUint, BigUint )
                {
                    if d.is_zero() {
                        panic!( "attempt to divide by zero" )
                    }
                    if u.is_zero() {
                        return ( BigUint::ZERO, BigUint::ZERO );
                    }
                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return ( u.clone(), BigUint::ZERO );
                        }
                        let ( div, rem ) = div_rem_digit( u.clone(), d.data[0] );
                        return ( div, rem.into() );
                    }
                   
                    match u.cmp( d ) {
                        Less => return ( BigUint::ZERO, u.clone() ),
                        Equal => return ( One::one(), BigUint::ZERO ),
                        Greater => {}
                    }
                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core( u.clone(), &d.data )
                    } else {
                        let ( q, r ) = div_rem_core( u << shift, &( d << shift ).data );
                       
                        ( q, r >> shift )
                    }
                }
                /// An implementation of the base division algorithm.
                fn div_rem_core( mut a: BigUint, b:&[BigDigit] ) -> ( BigUint, BigUint )
                {
                    debug_assert!( a.data.len() >= b.len() && b.len() > 1 );
                    debug_assert!( b.last().unwrap().leading_zeros() == 0 );

                   
                   
                    //
                   
                   
                    //
                   
                    //
                   
                   
                   
                   
                    //
                   
                   
                   

                   
                    let mut a0 = 0;

                   
                    let b0 = b[b.len() - 1];
                    let b1 = b[b.len() - 2];

                    let q_len = a.data.len() - b.len() + 1;
                    let mut q = BigUint {
                        data: vec![0; q_len],
                    };

                    for j in ( 0..q_len ).rev() {
                        debug_assert!( a.data.len() == b.len() + j );

                        let a1 = *a.data.last().unwrap();
                        let a2 = a.data[a.data.len() - 2];

                       
                       
                        let ( mut q0, mut r ) = if a0 < b0 {
                            let ( q0, r ) = div_wide( a0, a1, b0 );
                            ( q0, r as DoubleBigDigit )
                        } else {
                            debug_assert!( a0 == b0 );
                           
                           
                            ( ::num::big::digit::MAX, a0 as DoubleBigDigit + a1 as DoubleBigDigit )
                        };

                       
                        //
                       
                       
                        //
                       
                       
                       
                        while r <= ::num::big::digit::MAX as DoubleBigDigit
                            && ::num::big::digit::to_doublebigdigit( r as BigDigit, a2 )
                                < q0 as DoubleBigDigit * b1 as DoubleBigDigit
                        {
                            q0 -= 1;
                            r += b0 as DoubleBigDigit;
                        }
                       
                       

                        let mut borrow = sub_mul_digit_same_len( &mut a.data[j..], b, q0 );
                        if borrow > a0 {
                           
                            q0 -= 1;
                            borrow -= __add2( &mut a.data[j..], b );
                        }
                       
                        debug_assert!( borrow == a0 );

                        q.data[j] = q0;

                       
                        a0 = a.data.pop().unwrap();
                    }
                    a.data.push( a0 );
                    a.normalize();

                    debug_assert_eq!( cmp_slice( &a.data, b ), Less );

                    ( q.normalized(), a )
                }
                forward_val_ref_binop_big!( impl Div for BigUint, div );
                forward_ref_val_binop_big!( impl Div for BigUint, div );
                forward_val_assign!( impl DivAssign for BigUint, div_assign );

                impl Div<BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: BigUint ) -> BigUint {
                        let ( q, _ ) = div_rem( self, other );
                        q
                    }
                }
                impl Div<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other:&BigUint ) -> BigUint {
                        let ( q, _ ) = self.div_rem( other );
                        q
                    }
                }
                impl DivAssign<&BigUint> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other:&BigUint ) {
                        *self = &*self / other;
                    }
                }
                promote_unsigned_scalars!( impl Div for BigUint, div );
                promote_unsigned_scalars_assign!( impl DivAssign for BigUint, div_assign );
                forward_all_scalar_binop_to_val_val!( impl Div<u32> for BigUint, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u64> for BigUint, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u128> for BigUint, div );

                impl Div<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: u32 ) -> BigUint {
                        let ( q, _ ) = div_rem_digit( self, other as BigDigit );
                        q
                    }
                }
                impl DivAssign<u32> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other: u32 ) {
                        *self = &*self / other;
                    }
                }
                impl Div<BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn div( self, other: BigUint ) -> BigUint {
                        match other.data.len() {
                            0 => panic!( "attempt to divide by zero" ),
                            1 => From::from( self as BigDigit / other.data[0] ),
                            _ => BigUint::ZERO,
                        }
                    }
                }
                impl Div<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: u64 ) -> BigUint {
                        let ( q, _ ) = div_rem( self, From::from( other ) );
                        q
                    }
                }
                impl DivAssign<u64> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other: u64 ) {
                       
                        let temp = mem::replace( self, Self::ZERO );
                        *self = temp / other;
                    }
                }
                impl Div<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline]
                        fn div( self, other: BigUint ) -> BigUint {
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / u64::from( other.data[0] ) ),
                                2 => From::from( self / ::num::big::digit::to_doublebigdigit( other.data[1], other.data[0] ) ),
                                _ => BigUint::ZERO,
                            }
                        }
                        #[inline]
                        fn div( self, other: BigUint ) -> BigUint {
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / other.data[0] ),
                                _ => BigUint::ZERO,
                            }
                        }
                     );
                }
                impl Div<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: u128 ) -> BigUint {
                        let ( q, _ ) = div_rem( self, From::from( other ) );
                        q
                    }
                }
                impl DivAssign<u128> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other: u128 ) {
                        *self = &*self / other;
                    }
                }
                impl Div<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline]
                        fn div( self, other: BigUint ) -> BigUint {
                            use super::u32_to_u128;
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / u128::from( other.data[0] ) ),
                                2 => From::from( 
                                    self / u128::from( ::num::big::digit::to_doublebigdigit( other.data[1], other.data[0] ) ),
                                ),
                                3 => From::from( self / u32_to_u128( 0, other.data[2], other.data[1], other.data[0] ) ),
                                4 => From::from( 
                                    self / u32_to_u128( other.data[3], other.data[2], other.data[1], other.data[0] ),
                                ),
                                _ => BigUint::ZERO,
                            }
                        }
                        #[inline]
                        fn div( self, other: BigUint ) -> BigUint {
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / other.data[0] as u128 ),
                                2 => From::from( self / ::num::big::digit::to_doublebigdigit( other.data[1], other.data[0] ) ),
                                _ => BigUint::ZERO,
                            }
                        }
                     );
                }
                forward_val_ref_binop_big!( impl Rem for BigUint, rem );
                forward_ref_val_binop_big!( impl Rem for BigUint, rem );
                forward_val_assign!( impl RemAssign for BigUint, rem_assign );

                impl Rem<BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: BigUint ) -> BigUint {
                        if let Some( other ) = other.to_u32() {
                            &self % other
                        } else {
                            let ( _, r ) = div_rem( self, other );
                            r
                        }
                    }
                }
                impl Rem<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other:&BigUint ) -> BigUint {
                        if let Some( other ) = other.to_u32() {
                            self % other
                        } else {
                            let ( _, r ) = self.div_rem( other );
                            r
                        }
                    }
                }
                impl RemAssign<&BigUint> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other:&BigUint ) {
                        *self = &*self % other;
                    }
                }
                promote_unsigned_scalars!( impl Rem for BigUint, rem );
                promote_unsigned_scalars_assign!( impl RemAssign for BigUint, rem_assign );
                forward_all_scalar_binop_to_ref_val!( impl Rem<u32> for BigUint, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u64> for BigUint, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u128> for BigUint, rem );

                impl Rem<u32> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: u32 ) -> BigUint {
                        rem_digit( self, other as BigDigit ).into()
                    }
                }
                impl RemAssign<u32> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other: u32 ) {
                        *self = &*self % other;
                    }
                }
                impl Rem<&BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn rem( mut self, other:&BigUint ) -> BigUint {
                        self %= other;
                        From::from( self )
                    }
                }
                macro_rules! impl_rem_assign_scalar {
                    ( $scalar:ty, $to_scalar:ident ) => {
                        forward_val_assign_scalar!( impl RemAssign for BigUint, $scalar, rem_assign );
                        impl RemAssign<&BigUint> for $scalar {
                            #[inline]
                            fn rem_assign( &mut self, other:&BigUint ) {
                                *self = match other.$to_scalar() {
                                    None => *self,
                                    Some( 0 ) => panic!( "attempt to divide by zero" ),
                                    Some( v ) => *self % v
                                };
                            }
                        }
                    }
                }
               
                impl_rem_assign_scalar!( u128, to_u128 );
                impl_rem_assign_scalar!( usize, to_usize );
                impl_rem_assign_scalar!( u64, to_u64 );
                impl_rem_assign_scalar!( u32, to_u32 );
                impl_rem_assign_scalar!( u16, to_u16 );
                impl_rem_assign_scalar!( u8, to_u8 );
                impl_rem_assign_scalar!( i128, to_i128 );
                impl_rem_assign_scalar!( isize, to_isize );
                impl_rem_assign_scalar!( i64, to_i64 );
                impl_rem_assign_scalar!( i32, to_i32 );
                impl_rem_assign_scalar!( i16, to_i16 );
                impl_rem_assign_scalar!( i8, to_i8 );

                impl Rem<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: u64 ) -> BigUint {
                        let ( _, r ) = div_rem( self, From::from( other ) );
                        r
                    }
                }
                impl RemAssign<u64> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other: u64 ) {
                        *self = &*self % other;
                    }
                }
                impl Rem<BigUint> for u64 {
                    type Output = BigUint;

                    #[inline] fn rem( mut self, other: BigUint ) -> BigUint {
                        self %= other;
                        From::from( self )
                    }
                }
                impl Rem<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: u128 ) -> BigUint {
                        let ( _, r ) = div_rem( self, From::from( other ) );
                        r
                    }
                }
                impl RemAssign<u128> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other: u128 ) {
                        *self = &*self % other;
                    }
                }
                impl Rem<BigUint> for u128 {
                    type Output = BigUint;

                    #[inline] fn rem( mut self, other: BigUint ) -> BigUint {
                        self %= other;
                        From::from( self )
                    }
                }
                impl CheckedDiv for BigUint
                {
                    #[inline] fn checked_div( &self, v:&BigUint ) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div( v ) )
                    }
                }
                impl CheckedEuclid for BigUint
                {
                    #[inline] fn checked_div_euclid( &self, v:&BigUint ) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div_euclid( v ) )
                    }
                    #[inline] fn checked_rem_euclid( &self, v:&BigUint ) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.rem_euclid( v ) )
                    }
                    fn checked_div_rem_euclid( &self, v:&Self ) -> Option<( Self, Self )> {
                        Some( self.div_rem_euclid( v ) )
                    }
                }
                impl Euclid for BigUint
                {
                    #[inline] fn div_euclid( &self, v:&BigUint ) -> BigUint {
                       
                        self / v
                    }
                    #[inline] fn rem_euclid( &self, v:&BigUint ) -> BigUint {
                       
                        self % v
                    }
                    fn div_rem_euclid( &self, v:&Self ) -> ( Self, Self ) {
                       
                        self.div_rem( v )
                    }
                }
            }
            pub mod multiplication
            {
                /*!
                */
                use ::
                {
                    cmp::{ Ordering },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit, DoubleBigDigit},
                            Sign::{self, Minus, NoSign, Plus},
                            {BigInt, UsizePromotion},
                        },
                        traits::{ CheckedMul, FromPrimitive, One, Zero },
                    },
                    ops::{Mul, MulAssign},
                    *,
                };
                use super::addition::{__add2, add2};
                use super::subtraction::sub2;
                use super::{biguint_from_vec, cmp_slice, BigUint, IntDigits};
                /*
                */
                #[inline] pub fn mac_with_carry( 
                    a: BigDigit,
                    b: BigDigit,
                    c: BigDigit,
                    acc:&mut DoubleBigDigit,
                ) -> BigDigit {
                    *acc += DoubleBigDigit::from( a );
                    *acc += DoubleBigDigit::from( b ) * DoubleBigDigit::from( c );
                    let lo = *acc as BigDigit;
                    *acc >>= ::num::big::digit::BITS;
                    lo
                }
                #[inline] fn mul_with_carry( a: BigDigit, b: BigDigit, acc:&mut DoubleBigDigit ) -> BigDigit {
                    *acc += DoubleBigDigit::from( a ) * DoubleBigDigit::from( b );
                    let lo = *acc as BigDigit;
                    *acc >>= ::num::big::digit::BITS;
                    lo
                }
                /// Three argument multiply accumulate:
                /// acc += b * c
                fn mac_digit( acc:&mut [BigDigit], b:&[BigDigit], c: BigDigit ) {
                    if c == 0 {
                        return;
                    }
                    let mut carry = 0;
                    let ( a_lo, a_hi ) = acc.split_at_mut( b.len() );

                    for ( a, &b ) in a_lo.iter_mut().zip( b ) {
                        *a = mac_with_carry( *a, b, c, &mut carry );
                    }
                    let ( carry_hi, carry_lo ) = ::num::big::digit::from_doublebigdigit( carry );

                    let final_carry = if carry_hi == 0 {
                        __add2( a_hi, &[carry_lo] )
                    } else {
                        __add2( a_hi, &[carry_hi, carry_lo] )
                    };
                    assert_eq!( final_carry, 0, "carry overflow during multiplication!" );
                }
                fn bigint_from_slice( slice:&[BigDigit] ) -> BigInt {
                    BigInt::from( biguint_from_vec( slice.to_vec() ) )
                }
                /// Three argument multiply accumulate:
                /// acc += b * c
                #[allow( clippy::many_single_char_names )]
                fn mac3( mut acc:&mut [BigDigit], mut b:&[BigDigit], mut c:&[BigDigit] ) {
                   
                    if let Some( &0 ) = b.first() {
                        if let Some( nz ) = b.iter().position( |&d| d != 0 ) {
                            b = &b[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }
                    if let Some( &0 ) = c.first() {
                        if let Some( nz ) = c.iter().position( |&d| d != 0 ) {
                            c = &c[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }
                    let acc = acc;
                    let ( x, y ) = if b.len() < c.len() { ( b, c ) } else { ( c, b ) };

                   
                    //
                   
                   
                   
                   
                   
                   
                    //
                   
                   

                    if x.len() <= 32 {
                       
                        for ( i, xi ) in x.iter().enumerate() {
                            mac_digit( &mut acc[i..], y, *xi );
                        }
                    } else if x.len() * 2 <= y.len() {
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                        let m2 = y.len() / 2;
                        let ( low2, high2 ) = y.split_at( m2 );

                       
                        mac3( acc, x, low2 );
                        mac3( &mut acc[m2..], x, high2 );
                    } else if x.len() <= 256 {
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       

                       
                       
                        let b = x.len() / 2;
                        let ( x0, x1 ) = x.split_at( b );
                        let ( y0, y1 ) = y.split_at( b );

                       
                       
                        let len = x1.len() + y1.len() + 1;
                        let mut p = BigUint { data: vec![0; len] };

                       
                        mac3( &mut p.data, x1, y1 );

                       
                        p.normalize();

                        add2( &mut acc[b..], &p.data );
                        add2( &mut acc[b * 2..], &p.data );

                       
                        p.data.truncate( 0 );
                        p.data.resize( len, 0 );

                       
                        mac3( &mut p.data, x0, y0 );
                        p.normalize();

                        add2( acc, &p.data );
                        add2( &mut acc[b..], &p.data );

                       
                       
                        let ( j0_sign, j0 ) = sub_sign( x1, x0 );
                        let ( j1_sign, j1 ) = sub_sign( y1, y0 );

                        match j0_sign * j1_sign {
                            Plus => {
                                p.data.truncate( 0 );
                                p.data.resize( len, 0 );

                                mac3( &mut p.data, &j0.data, &j1.data );
                                p.normalize();

                                sub2( &mut acc[b..], &p.data );
                            }
                            Minus => {
                                mac3( &mut acc[b..], &j0.data, &j1.data );
                            }
                            NoSign => (),
                        }
                    } else {
                       
                        //
                       
                       
                        //
                       
                       
                       
                        let i = y.len() / 3 + 1;

                        let x0_len = Ord::min( x.len(), i );
                        let x1_len = Ord::min( x.len() - x0_len, i );

                        let y0_len = i;
                        let y1_len = Ord::min( y.len() - y0_len, i );

                       
                       
                       
                        //
                       
                        let x0 = bigint_from_slice( &x[..x0_len] );
                        let x1 = bigint_from_slice( &x[x0_len..x0_len + x1_len] );
                        let x2 = bigint_from_slice( &x[x0_len + x1_len..] );

                       
                        let y0 = bigint_from_slice( &y[..y0_len] );
                        let y1 = bigint_from_slice( &y[y0_len..y0_len + y1_len] );
                        let y2 = bigint_from_slice( &y[y0_len + y1_len..] );

                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                       

                       
                        let p = &x0 + &x2;

                       
                        let q = &y0 + &y2;

                       
                        let p2 = &p - &x1;

                       
                        let q2 = &q - &y1;

                       
                        let r0 = &x0 * &y0;

                       
                        let r4 = &x2 * &y2;

                       
                        let r1 = ( p + x1 ) * ( q + y1 );

                       
                        let r2 = &p2 * &q2;

                       
                        let r3 = (( p2 + x2 ) * 2 - x0 ) * ( ( q2 + y2 ) * 2 - y0 );

                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        let mut comp3: BigInt = ( r3 - &r1 ) / 3u32;
                        let mut comp1: BigInt = ( r1 - &r2 ) >> 1;
                        let mut comp2: BigInt = r2 - &r0;
                        comp3 = (( &comp2 - comp3 ) >> 1 ) + ( &r4 << 1 );
                        comp2 += &comp1 - &r4;
                        comp1 -= &comp3;

                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                       
                       
                       
                        //
                       
                        for ( j, result ) in [&r0, &comp1, &comp2, &comp3, &r4].iter().enumerate().rev() {
                            match result.sign() {
                                Plus => add2( &mut acc[i * j..], result.digits() ),
                                Minus => sub2( &mut acc[i * j..], result.digits() ),
                                NoSign => {}
                            }
                        }
                    }
                }
                fn mul3( x:&[BigDigit], y:&[BigDigit] ) -> BigUint {
                    let len = x.len() + y.len() + 1;
                    let mut prod = BigUint { data: vec![0; len] };

                    mac3( &mut prod.data, x, y );
                    prod.normalized()
                }
                fn scalar_mul( a:&mut BigUint, b: BigDigit ) {
                    match b {
                        0 => a.set_zero(),
                        1 => {}
                        _ => {
                            if b.is_power_of_two() {
                                *a <<= b.trailing_zeros();
                            } else {
                                let mut carry = 0;
                                for a in a.data.iter_mut() {
                                    *a = mul_with_carry( *a, b, &mut carry );
                                }
                                if carry != 0 {
                                    a.data.push( carry as BigDigit );
                                }
                            }
                        }
                    }
                }
                fn sub_sign( mut a:&[BigDigit], mut b:&[BigDigit] ) -> ( Sign, BigUint ) {
                   
                    if let Some( &0 ) = a.last() {
                        a = &a[..a.iter().rposition( |&x| x != 0 ).map_or( 0, |i| i + 1 )];
                    }
                    if let Some( &0 ) = b.last() {
                        b = &b[..b.iter().rposition( |&x| x != 0 ).map_or( 0, |i| i + 1 )];
                    }
                    match cmp_slice( a, b ) {
                        Ordering::Greater => {
                            let mut a = a.to_vec();
                            sub2( &mut a, b );
                            ( Plus, biguint_from_vec( a ) )
                        }
                        Ordering::Less => {
                            let mut b = b.to_vec();
                            sub2( &mut b, a );
                            ( Minus, biguint_from_vec( b ) )
                        }
                        Ordering::Equal => ( NoSign, BigUint::ZERO ),
                    }
                }
                macro_rules! impl_mul {
                    ( $( impl Mul<$Other:ty> for $Self:ty; )* ) => {$( 
                        impl Mul<$Other> for $Self {
                            type Output = BigUint;

                            #[inline]
                            fn mul( self, other: $Other ) -> BigUint {
                                match ( &*self.data, &*other.data ) {
                                   
                                    ( &[], _ ) | ( _, &[] ) => BigUint::ZERO,
                                   
                                    ( _, &[digit] ) => self * digit,
                                    ( &[digit], _ ) => other * digit,
                                   
                                    ( x, y ) => mul3( x, y ),
                                }
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigUint> for BigUint;
                    impl Mul<BigUint> for &BigUint;
                    impl Mul<&BigUint> for BigUint;
                    impl Mul<&BigUint> for &BigUint;
                }
                macro_rules! impl_mul_assign {
                    ( $( impl MulAssign<$Other:ty> for BigUint; )* ) => {$( 
                        impl MulAssign<$Other> for BigUint {
                            #[inline]
                            fn mul_assign( &mut self, other: $Other ) {
                                match ( &*self.data, &*other.data ) {
                                   
                                    ( &[], _ ) => {},
                                    ( _, &[] ) => self.set_zero(),
                                   
                                    ( _, &[digit] ) => *self *= digit,
                                    ( &[digit], _ ) => *self = other * digit,
                                   
                                    ( x, y ) => *self = mul3( x, y ),
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigUint> for BigUint;
                    impl MulAssign<&BigUint> for BigUint;
                }
                promote_unsigned_scalars!( impl Mul for BigUint, mul );
                promote_unsigned_scalars_assign!( impl MulAssign for BigUint, mul_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u32> for BigUint, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u64> for BigUint, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u128> for BigUint, mul );

                impl Mul<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn mul( mut self, other: u32 ) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u32> for BigUint
                {
                    #[inline] fn mul_assign( &mut self, other: u32 ) {
                        scalar_mul( self, other as BigDigit );
                    }
                }
                impl Mul<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn mul( mut self, other: u64 ) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u64> for BigUint {
                    cfg_digit!( 
                        #[inline]
                        fn mul_assign( &mut self, other: u64 ) {
                            if let Some( other ) = BigDigit::from_u64( other ) {
                                scalar_mul( self, other );
                            } else {
                                let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                                *self = mul3( &self.data, &[lo, hi] );
                            }
                        }
                        #[inline]
                        fn mul_assign( &mut self, other: u64 ) {
                            scalar_mul( self, other );
                        }
                     );
                }
                impl Mul<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn mul( mut self, other: u128 ) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u128> for BigUint {
                    cfg_digit!( 
                        #[inline]
                        fn mul_assign( &mut self, other: u128 ) {
                            if let Some( other ) = BigDigit::from_u128( other ) {
                                scalar_mul( self, other );
                            } else {
                                *self = match super::u32_from_u128( other ) {
                                    ( 0, 0, c, d ) => mul3( &self.data, &[d, c] ),
                                    ( 0, b, c, d ) => mul3( &self.data, &[d, c, b] ),
                                    ( a, b, c, d ) => mul3( &self.data, &[d, c, b, a] ),
                                };
                            }
                        }
                        #[inline]
                        fn mul_assign( &mut self, other: u128 ) {
                            if let Some( other ) = BigDigit::from_u128( other ) {
                                scalar_mul( self, other );
                            } else {
                                let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                                *self = mul3( &self.data, &[lo, hi] );
                            }
                        }
                     );
                }
                impl CheckedMul for BigUint
                {
                    #[inline] fn checked_mul( &self, v:&BigUint ) -> Option<BigUint> {
                        Some( self.mul( v ) )
                    }
                }
                impl_product_iter_type!( BigUint );
            }
            pub mod subtraction
            {
                /*!
                */
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit}, UsizePromotion
                        },
                        traits::{ CheckedSub },
                    },
                    ops::{ Sub, SubAssign },
                    *,
                };
                
                use super::BigUint;
                /*
                */
                use ::arch::x86_64 as arch;
                
                cfg_64!( 
                    #[inline] fn sbb( borrow: u8, a: u64, b: u64, out:&mut u64 ) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u64( borrow, a, b, out ) }
                    }
                 );
                
                cfg_32!( 
                    #[inline] fn sbb( borrow: u8, a: u32, b: u32, out:&mut u32 ) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u32( borrow, a, b, out ) }
                    }
                 );
                
                pub( super ) fn sub2( a:&mut [BigDigit], b:&[BigDigit] ) {
                    let mut borrow = 0;

                    let len = Ord::min( a.len(), b.len() );
                    let ( a_lo, a_hi ) = a.split_at_mut( len );
                    let ( b_lo, b_hi ) = b.split_at( len );

                    for ( a, b ) in a_lo.iter_mut().zip( b_lo ) {
                        borrow = sbb( borrow, *a, *b, a );
                    }
                    if borrow != 0 {
                        for a in a_hi {
                            borrow = sbb( borrow, *a, 0, a );
                            if borrow == 0 {
                                break;
                            }
                        }
                    }
                   
                    assert!( 
                        borrow == 0 && b_hi.iter().all( |x| *x == 0 ),
                        "Cannot subtract b from a because b is larger than a."
                     );
                }
               
                #[inline] fn __sub2rev( a:&[BigDigit], b:&mut [BigDigit] ) -> u8 {
                    debug_assert!( b.len() == a.len() );

                    let mut borrow = 0;

                    for ( ai, bi ) in a.iter().zip( b ) {
                        borrow = sbb( borrow, *ai, *bi, bi );
                    }
                    borrow
                }
                fn sub2rev( a:&[BigDigit], b:&mut [BigDigit] ) {
                    debug_assert!( b.len() >= a.len() );

                    let len = Ord::min( a.len(), b.len() );
                    let ( a_lo, a_hi ) = a.split_at( len );
                    let ( b_lo, b_hi ) = b.split_at_mut( len );

                    let borrow = __sub2rev( a_lo, b_lo );

                    assert!( a_hi.is_empty() );

                   
                    assert!( 
                        borrow == 0 && b_hi.iter().all( |x| *x == 0 ),
                        "Cannot subtract b from a because b is larger than a."
                     );
                }
                forward_val_val_binop!( impl Sub for BigUint, sub );
                forward_ref_ref_binop_big!( impl Sub for BigUint, sub );
                forward_val_assign!( impl SubAssign for BigUint, sub_assign );

                impl Sub<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn sub( mut self, other:&BigUint ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<&BigUint> for BigUint
                {
                    fn sub_assign( &mut self, other:&BigUint ) {
                        sub2( &mut self.data[..], &other.data[..] );
                        self.normalize();
                    }
                }
                impl Sub<BigUint> for &BigUint
                {
                    type Output = BigUint;

                    fn sub( self, mut other: BigUint ) -> BigUint {
                        let other_len = other.data.len();
                        if other_len < self.data.len() {
                            let lo_borrow = __sub2rev( &self.data[..other_len], &mut other.data );
                            other.data.extend_from_slice( &self.data[other_len..] );
                            if lo_borrow != 0 {
                                sub2( &mut other.data[other_len..], &[1] )
                            }
                        } else {
                            sub2rev( &self.data[..], &mut other.data[..] );
                        }
                        other.normalized()
                    }
                }
                promote_unsigned_scalars!( impl Sub for BigUint, sub );
                promote_unsigned_scalars_assign!( impl SubAssign for BigUint, sub_assign );
                forward_all_scalar_binop_to_val_val!( impl Sub<u32> for BigUint, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u64> for BigUint, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u128> for BigUint, sub );

                impl Sub<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn sub( mut self, other: u32 ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<u32> for BigUint 
                {
                    fn sub_assign( &mut self, other: u32 ) {
                        sub2( &mut self.data[..], &[other as BigDigit] );
                        self.normalize();
                    }
                }
                impl Sub<BigUint> for u32 
                {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline]
                        fn sub( self, mut other: BigUint ) -> BigUint {
                            if other.data.len() == 0 {
                                other.data.push( self );
                            } else {
                                sub2rev( &[self], &mut other.data[..] );
                            }
                            other.normalized()
                        }
                        #[inline]
                        fn sub( self, mut other: BigUint ) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push( self as BigDigit );
                            } else {
                                sub2rev( &[self as BigDigit], &mut other.data[..] );
                            }
                            other.normalized()
                        }
                     );
                }
                impl Sub<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn sub( mut self, other: u64 ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<u64> for BigUint 
                {
                    cfg_digit!( 
                        #[inline]
                        fn sub_assign( &mut self, other: u64 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            sub2( &mut self.data[..], &[lo, hi] );
                            self.normalize();
                        }
                        #[inline]
                        fn sub_assign( &mut self, other: u64 ) {
                            sub2( &mut self.data[..], &[other as BigDigit] );
                            self.normalize();
                        }
                     );
                }
                impl Sub<BigUint> for u64 
                {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline]
                        fn sub( self, mut other: BigUint ) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push( 0 );
                            }
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( self );
                            sub2rev( &[lo, hi], &mut other.data[..] );
                            other.normalized()
                        }
                        #[inline]
                        fn sub( self, mut other: BigUint ) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push( self );
                            } else {
                                sub2rev( &[self], &mut other.data[..] );
                            }
                            other.normalized()
                        }
                     );
                }
                impl Sub<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn sub( mut self, other: u128 ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<u128> for BigUint 
                {
                    cfg_digit!( 
                        #[inline]
                        fn sub_assign( &mut self, other: u128 ) {
                            let ( a, b, c, d ) = super::u32_from_u128( other );
                            sub2( &mut self.data[..], &[d, c, b, a] );
                            self.normalize();
                        }
                        #[inline]
                        fn sub_assign( &mut self, other: u128 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            sub2( &mut self.data[..], &[lo, hi] );
                            self.normalize();
                        }
                     );
                }
                impl Sub<BigUint> for u128 
                {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline]
                        fn sub( self, mut other: BigUint ) -> BigUint {
                            while other.data.len() < 4 {
                                other.data.push( 0 );
                            }
                            let ( a, b, c, d ) = super::u32_from_u128( self );
                            sub2rev( &[d, c, b, a], &mut other.data[..] );
                            other.normalized()
                        }
                        #[inline]
                        fn sub( self, mut other: BigUint ) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push( 0 );
                            }
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( self );
                            sub2rev( &[lo, hi], &mut other.data[..] );
                            other.normalized()
                        }
                     );
                }
                impl CheckedSub for BigUint
                {
                    #[inline] fn checked_sub( &self, v:&BigUint ) -> Option<BigUint> {
                        match self.cmp( v ) {
                            Less => None,
                            Equal => Some( Self::ZERO ),
                            Greater => Some( self.sub( v ) ),
                        }
                    }
                }
            }
            pub mod bits
            {
                /*!
                */
                use ::
                {
                    ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign},
                    *,
                };
                use super::{BigUint, IntDigits};
                /*
                */
                forward_val_val_binop!( impl BitAnd for BigUint, bitand );
                forward_ref_val_binop_big!( impl BitAnd for BigUint, bitand );
               
                impl BitAnd<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn bitand( self, other:&BigUint ) -> BigUint {
                       
                        if self.data.len() <= other.data.len() {
                            self.clone() & other
                        } else {
                            other.clone() & self
                        }
                    }
                }
                forward_val_assign!( impl BitAndAssign for BigUint, bitand_assign );

                impl BitAnd<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn bitand( mut self, other:&BigUint ) -> BigUint {
                        self &= other;
                        self
                    }
                }
                impl BitAndAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitand_assign( &mut self, other:&BigUint ) {
                        for ( ai, &bi ) in self.data.iter_mut().zip( other.data.iter() ) {
                            *ai &= bi;
                        }
                        self.data.truncate( other.data.len() );
                        self.normalize();
                    }
                }
                forward_all_binop_to_val_ref_commutative!( impl BitOr for BigUint, bitor );
                forward_val_assign!( impl BitOrAssign for BigUint, bitor_assign );

                impl BitOr<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn bitor( mut self, other:&BigUint ) -> BigUint {
                        self |= other;
                        self
                    }
                }
                impl BitOrAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitor_assign( &mut self, other:&BigUint ) {
                        for ( ai, &bi ) in self.data.iter_mut().zip( other.data.iter() ) {
                            *ai |= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend( extra.iter().cloned() );
                        }
                    }
                }
                forward_all_binop_to_val_ref_commutative!( impl BitXor for BigUint, bitxor );
                forward_val_assign!( impl BitXorAssign for BigUint, bitxor_assign );

                impl BitXor<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn bitxor( mut self, other:&BigUint ) -> BigUint {
                        self ^= other;
                        self
                    }
                }
                impl BitXorAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitxor_assign( &mut self, other:&BigUint ) {
                        for ( ai, &bi ) in self.data.iter_mut().zip( other.data.iter() ) {
                            *ai ^= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend( extra.iter().cloned() );
                        }
                        self.normalize();
                    }
                }
            }
            pub mod convert
            {
                /*!
                */
                use ::
                {
                    vec::{ Vec },
                    cmp::Ordering::{ Equal, Greater, Less },
                    convert::{ TryFrom },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit},
                            ParseBigIntError, TryFromBigIntError,
                        },
                        integers::{ Integer, Roots },
                        traits::
                        {
                            float::{ Float, FloatCore }, FromPrimitive, Num, One, PrimInt, ToPrimitive, Zero,
                        },
                    },
                    str::{ FromStr },
                    *,
                };
                use super::{biguint_from_vec, BigUint, ToBigUint};
                use super::addition::add2;
                use super::division::{div_rem_digit, FAST_DIV_WIDE};
                use super::multiplication::mac_with_carry;
                /*
                */
                /// Find last set bit
                /// fls( 0 ) == 0, fls( u32::MAX ) == 32
                fn fls<T: PrimInt>( v: T ) -> u8 {
                    mem::size_of::<T>() as u8 * 8 - v.leading_zeros() as u8
                }
                fn ilog2<T: PrimInt>( v: T ) -> u8 {
                    fls( v ) - 1
                }
                impl FromStr for BigUint
                {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str( s:&str ) -> Result<BigUint, ParseBigIntError> {
                        BigUint::from_str_radix( s, 10 )
                    }
                }
                
                pub( super ) fn from_bitwise_digits_le( v:&[u8], bits: u8 ) -> BigUint {
                    debug_assert!( !v.is_empty() && bits <= 8 && ::num::big::digit::BITS % bits == 0 );
                    debug_assert!( v.iter().all( |&c| BigDigit::from( c ) < ( 1 << bits ) ) );

                    let digits_per_big_digit = ::num::big::digit::BITS / bits;

                    let data = v
                        .chunks( digits_per_big_digit.into() )
                        .map( |chunk| {
                            chunk
                                .iter()
                                .rev()
                                .fold( 0, |acc, &c| ( acc << bits ) | BigDigit::from( c ) )
                        } )
                        .collect();

                    biguint_from_vec( data )
                }
               
               
                fn from_inexact_bitwise_digits_le( v:&[u8], bits: u8 ) -> BigUint {
                    debug_assert!( !v.is_empty() && bits <= 8 && ::num::big::digit::BITS % bits != 0 );
                    debug_assert!( v.iter().all( |&c| BigDigit::from( c ) < ( 1 << bits ) ) );

                    let total_bits = ( v.len() as u64 ).saturating_mul( bits.into() );
                    let big_digits = Integer::div_ceil( &total_bits, &::num::big::digit::BITS.into() )
                        .to_usize()
                        .unwrap_or( usize::MAX );
                    let mut data = Vec::with_capacity( big_digits );

                    let mut d = 0;
                    let mut dbits = 0;

                   
                   
                    for &c in v {
                        d |= BigDigit::from( c ) << dbits;
                        dbits += bits;

                        if dbits >= ::num::big::digit::BITS {
                            data.push( d );
                            dbits -= ::num::big::digit::BITS;
                           
                           
                            d = BigDigit::from( c ) >> ( bits - dbits );
                        }
                    }
                    if dbits > 0 {
                        debug_assert!( dbits < ::num::big::digit::BITS );
                        data.push( d as BigDigit );
                    }
                    biguint_from_vec( data )
                }
               
                fn from_radix_digits_be( v:&[u8], radix: u32 ) -> BigUint {
                    debug_assert!( !v.is_empty() && !radix.is_power_of_two() );
                    debug_assert!( v.iter().all( |&c| u32::from( c ) < radix ) );

                   
                            let big_digits = {
                        let radix_log2 = f64::from( radix ).log2();
                        let bits = radix_log2 * v.len() as f64;
                        ( bits / ::num::big::digit::BITS as f64 ).ceil()
                    };
                    
                    let mut data = Vec::with_capacity( big_digits.to_usize().unwrap_or( 0 ) );

                    let ( base, power ) = get_radix_base( radix );
                    let radix = radix as BigDigit;

                    let r = v.len() % power;
                    let i = if r == 0 { power } else { r };
                    let ( head, tail ) = v.split_at( i );

                    let first = head
                        .iter()
                        .fold( 0, |acc, &d| acc * radix + BigDigit::from( d ) );
                    data.push( first );

                    debug_assert!( tail.len() % power == 0 );
                    for chunk in tail.chunks( power ) {
                        if data.last() != Some( &0 ) {
                            data.push( 0 );
                        }
                        let mut carry = 0;
                        for d in data.iter_mut() {
                            *d = mac_with_carry( 0, *d, base, &mut carry );
                        }
                        debug_assert!( carry == 0 );

                        let n = chunk
                            .iter()
                            .fold( 0, |acc, &d| acc * radix + BigDigit::from( d ) );
                        add2( &mut data, &[n] );
                    }
                    biguint_from_vec( data )
                }
                pub( super ) fn from_radix_be( buf:&[u8], radix: u32 ) -> Option<BigUint> {
                    assert!( 
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                     );

                    if buf.is_empty() {
                        return Some( BigUint::ZERO );
                    }
                    if radix != 256 && buf.iter().any( |&b| b >= radix as u8 ) {
                        return None;
                    }
                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2( radix );
                        let mut v = Vec::from( buf );
                        v.reverse();
                        if ::num::big::digit::BITS % bits == 0 {
                            from_bitwise_digits_le( &v, bits )
                        } else {
                            from_inexact_bitwise_digits_le( &v, bits )
                        }
                    } else {
                        from_radix_digits_be( buf, radix )
                    };

                    Some( res )
                }
                pub( super ) fn from_radix_le( buf:&[u8], radix: u32 ) -> Option<BigUint> {
                    assert!( 
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                     );

                    if buf.is_empty() {
                        return Some( BigUint::ZERO );
                    }
                    if radix != 256 && buf.iter().any( |&b| b >= radix as u8 ) {
                        return None;
                    }
                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2( radix );
                        if ::num::big::digit::BITS % bits == 0 {
                            from_bitwise_digits_le( buf, bits )
                        } else {
                            from_inexact_bitwise_digits_le( buf, bits )
                        }
                    } else {
                        let mut v = Vec::from( buf );
                        v.reverse();
                        from_radix_digits_be( &v, radix )
                    };

                    Some( res )
                }
                impl Num for BigUint
                {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a `BigUint`.
                    fn from_str_radix( s:&str, radix: u32 ) -> Result<BigUint, ParseBigIntError> {
                        assert!( 2 <= radix && radix <= 36, "The radix must be within 2...36" );
                        let mut s = s;
                        if let Some( tail ) = s.strip_prefix( '+' ) {
                            if !tail.starts_with( '+' ) {
                                s = tail
                            }
                        }
                        if s.is_empty() {
                            return Err( ParseBigIntError::empty() );
                        }
                        if s.starts_with( '_' ) {
                           
                            return Err( ParseBigIntError::invalid() );
                        }
                       
                        let mut v = Vec::with_capacity( s.len() );
                        for b in s.bytes() {
                            let d = match b {
                                b'0'..=b'9' => b - b'0',
                                b'a'..=b'z' => b - b'a' + 10,
                                b'A'..=b'Z' => b - b'A' + 10,
                                b'_' => continue,
                                _ => u8::MAX,
                            };
                            if d < radix as u8 {
                                v.push( d );
                            } else {
                                return Err( ParseBigIntError::invalid() );
                            }
                        }
                        let res = if radix.is_power_of_two() {
                           
                            let bits = ilog2( radix );
                            v.reverse();
                            if ::num::big::digit::BITS % bits == 0 {
                                from_bitwise_digits_le( &v, bits )
                            } else {
                                from_inexact_bitwise_digits_le( &v, bits )
                            }
                        } else {
                            from_radix_digits_be( &v, radix )
                        };
                        Ok( res )
                    }
                }
                fn high_bits_to_u64( v:&BigUint ) -> u64 {
                    match v.data.len() {
                        0 => 0,
                        1 => {
                           
                            #[allow( clippy::useless_conversion )]
                            let v0 = u64::from( v.data[0] );
                            v0
                        }
                        _ => {
                            let mut bits = v.bits();
                            let mut ret = 0u64;
                            let mut ret_bits = 0;

                            for d in v.data.iter().rev() {
                                let digit_bits = ( bits - 1 ) % u64::from( ::num::big::digit::BITS ) + 1;
                                let bits_want = Ord::min( 64 - ret_bits, digit_bits );

                                if bits_want != 0 {
                                    if bits_want != 64 {
                                        ret <<= bits_want;
                                    }
                                   
                                    #[allow( clippy::useless_conversion )]
                                    let d0 = u64::from( *d ) >> ( digit_bits - bits_want );
                                    ret |= d0;
                                }
                               
                               
                               
                                //
                               

                                if digit_bits - bits_want != 0 {
                                   
                                    #[allow( clippy::useless_conversion )]
                                    let masked = u64::from( *d ) << ( 64 - ( digit_bits - bits_want ) as u32 );
                                    ret |= ( masked != 0 ) as u64;
                                }
                                ret_bits += bits_want;
                                bits -= bits_want;
                            }
                            ret
                        }
                    }
                }
                impl ToPrimitive for BigUint
                {
                    #[inline] fn to_i64( &self ) -> Option<i64> {
                        self.to_u64().as_ref().and_then( u64::to_i64 )
                    }
                    #[inline] fn to_i128( &self ) -> Option<i128> {
                        self.to_u128().as_ref().and_then( u128::to_i128 )
                    }
                    #[allow( clippy::useless_conversion )]
                    #[inline] fn to_u64( &self ) -> Option<u64> {
                        let mut ret: u64 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 64 {
                                return None;
                            }
                           
                            ret += u64::from( *i ) << bits;
                            bits += ::num::big::digit::BITS;
                        }
                        Some( ret )
                    }
                    #[inline] fn to_u128( &self ) -> Option<u128> {
                        let mut ret: u128 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 128 {
                                return None;
                            }
                            ret |= u128::from( *i ) << bits;
                            bits += ::num::big::digit::BITS;
                        }
                        Some( ret )
                    }
                    #[inline] fn to_f32( &self ) -> Option<f32> {
                        let mantissa = high_bits_to_u64( self );
                        let exponent = self.bits() - u64::from( fls( mantissa ) );

                        if exponent > f32::MAX_EXP as u64 {
                            Some( f32::INFINITY )
                        } else {
                            Some( ( mantissa as f32 ) * 2.0f32.powi( exponent as i32 ) )
                        }
                    }
                    #[inline] fn to_f64( &self ) -> Option<f64> {
                        let mantissa = high_bits_to_u64( self );
                        let exponent = self.bits() - u64::from( fls( mantissa ) );

                        if exponent > f64::MAX_EXP as u64 {
                            Some( f64::INFINITY )
                        } else {
                            Some( ( mantissa as f64 ) * 2.0f64.powi( exponent as i32 ) )
                        }
                    }
                }
                macro_rules! impl_try_from_biguint {
                    ( $T:ty, $to_ty:path ) => {
                        impl TryFrom<&BigUint> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from( value:&BigUint ) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty( value ).ok_or( TryFromBigIntError::new( () ) )
                            }
                        }
                        impl TryFrom<BigUint> for $T {
                            type Error = TryFromBigIntError<BigUint>;

                            #[inline]
                            fn try_from( value: BigUint ) -> Result<$T, TryFromBigIntError<BigUint>> {
                                <$T>::try_from( &value ).map_err( |_| TryFromBigIntError::new( value ) )
                            }
                        }
                    };
                }
                impl_try_from_biguint!( u8, ToPrimitive::to_u8 );
                impl_try_from_biguint!( u16, ToPrimitive::to_u16 );
                impl_try_from_biguint!( u32, ToPrimitive::to_u32 );
                impl_try_from_biguint!( u64, ToPrimitive::to_u64 );
                impl_try_from_biguint!( usize, ToPrimitive::to_usize );
                impl_try_from_biguint!( u128, ToPrimitive::to_u128 );

                impl_try_from_biguint!( i8, ToPrimitive::to_i8 );
                impl_try_from_biguint!( i16, ToPrimitive::to_i16 );
                impl_try_from_biguint!( i32, ToPrimitive::to_i32 );
                impl_try_from_biguint!( i64, ToPrimitive::to_i64 );
                impl_try_from_biguint!( isize, ToPrimitive::to_isize );
                impl_try_from_biguint!( i128, ToPrimitive::to_i128 );

                impl FromPrimitive for BigUint
                {
                    #[inline] fn from_i64( n: i64 ) -> Option<BigUint> {
                        if n >= 0 {
                            Some( BigUint::from( n as u64 ) )
                        } else {
                            None
                        }
                    }
                    #[inline] fn from_i128( n: i128 ) -> Option<BigUint> {
                        if n >= 0 {
                            Some( BigUint::from( n as u128 ) )
                        } else {
                            None
                        }
                    }
                    #[inline] fn from_u64( n: u64 ) -> Option<BigUint> {
                        Some( BigUint::from( n ) )
                    }
                    #[inline] fn from_u128( n: u128 ) -> Option<BigUint> {
                        Some( BigUint::from( n ) )
                    }
                    #[inline] fn from_f64( mut n: f64 ) -> Option<BigUint> {
                       
                        if !n.is_finite() {
                            return None;
                        }
                       
                        n = n.trunc();

                       
                        if n.is_zero() {
                            return Some( Self::ZERO );
                        }
                        let ( mantissa, exponent, sign ) = Float::integer_decode( n  );

                        if sign == -1 {
                            return None;
                        }
                        let mut ret = BigUint::from( mantissa );
                        match exponent.cmp( &0 ) {
                            Greater => ret <<= exponent as usize,
                            Equal => {}
                            Less => ret >>= ( -exponent ) as usize,
                        }
                        Some( ret )
                    }
                }
                impl From<u64> for BigUint
                {
                    #[inline] fn from( mut n: u64 ) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push( n as BigDigit );
                           
                            n = ( n >> 1 ) >> ( ::num::big::digit::BITS - 1 );
                        }
                        ret
                    }
                }
                impl From<u128> for BigUint
                {
                    #[inline] fn from( mut n: u128 ) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push( n as BigDigit );
                            n >>= ::num::big::digit::BITS;
                        }
                        ret
                    }
                }
                macro_rules! impl_biguint_from_uint {
                    ( $T:ty ) => {
                        impl From<$T> for BigUint {
                            #[inline]
                            fn from( n: $T ) -> Self {
                                BigUint::from( n as u64 )
                            }
                        }
                    };
                }
                impl_biguint_from_uint!( u8 );
                impl_biguint_from_uint!( u16 );
                impl_biguint_from_uint!( u32 );
                impl_biguint_from_uint!( usize );

                macro_rules! impl_biguint_try_from_int {
                    ( $T:ty, $from_ty:path ) => {
                        impl TryFrom<$T> for BigUint {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from( value: $T ) -> Result<BigUint, TryFromBigIntError<()>> {
                                $from_ty( value ).ok_or( TryFromBigIntError::new( () ) )
                            }
                        }
                    };
                }
                impl_biguint_try_from_int!( i8, FromPrimitive::from_i8 );
                impl_biguint_try_from_int!( i16, FromPrimitive::from_i16 );
                impl_biguint_try_from_int!( i32, FromPrimitive::from_i32 );
                impl_biguint_try_from_int!( i64, FromPrimitive::from_i64 );
                impl_biguint_try_from_int!( isize, FromPrimitive::from_isize );
                impl_biguint_try_from_int!( i128, FromPrimitive::from_i128 );

                impl ToBigUint for BigUint
                {
                    #[inline] fn to_biguint( &self ) -> Option<BigUint> {
                        Some( self.clone() )
                    }
                }
                macro_rules! impl_to_biguint {
                    ( $T:ty, $from_ty:path ) => {
                        impl ToBigUint for $T {
                            #[inline]
                            fn to_biguint( &self ) -> Option<BigUint> {
                                $from_ty( *self )
                            }
                        }
                    };
                }
                impl_to_biguint!( isize, FromPrimitive::from_isize );
                impl_to_biguint!( i8, FromPrimitive::from_i8 );
                impl_to_biguint!( i16, FromPrimitive::from_i16 );
                impl_to_biguint!( i32, FromPrimitive::from_i32 );
                impl_to_biguint!( i64, FromPrimitive::from_i64 );
                impl_to_biguint!( i128, FromPrimitive::from_i128 );

                impl_to_biguint!( usize, FromPrimitive::from_usize );
                impl_to_biguint!( u8, FromPrimitive::from_u8 );
                impl_to_biguint!( u16, FromPrimitive::from_u16 );
                impl_to_biguint!( u32, FromPrimitive::from_u32 );
                impl_to_biguint!( u64, FromPrimitive::from_u64 );
                impl_to_biguint!( u128, FromPrimitive::from_u128 );

                impl_to_biguint!( f32, FromPrimitive::from_f32 );
                impl_to_biguint!( f64, FromPrimitive::from_f64 );

                impl From<bool> for BigUint {
                    fn from( x: bool ) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }
               
                pub( super ) fn to_bitwise_digits_le( u:&BigUint, bits: u8 ) -> Vec<u8> {
                    debug_assert!( !u.is_zero() && bits <= 8 && ::num::big::digit::BITS % bits == 0 );

                    let last_i = u.data.len() - 1;
                    let mask: BigDigit = ( 1 << bits ) - 1;
                    let digits_per_big_digit = ::num::big::digit::BITS / bits;
                    let digits = Integer::div_ceil( &u.bits(), &u64::from( bits ) )
                        .to_usize()
                        .unwrap_or( usize::MAX );
                    let mut res = Vec::with_capacity( digits );

                    for mut r in u.data[..last_i].iter().cloned() {
                        for _ in 0..digits_per_big_digit {
                            res.push( ( r & mask ) as u8 );
                            r >>= bits;
                        }
                    }
                    let mut r = u.data[last_i];
                    while r != 0 {
                        res.push( ( r & mask ) as u8 );
                        r >>= bits;
                    }
                    res
                }
               
                fn to_inexact_bitwise_digits_le( u:&BigUint, bits: u8 ) -> Vec<u8> {
                    debug_assert!( !u.is_zero() && bits <= 8 && ::num::big::digit::BITS % bits != 0 );

                    let mask: BigDigit = ( 1 << bits ) - 1;
                    let digits = Integer::div_ceil( &u.bits(), &u64::from( bits ) )
                        .to_usize()
                        .unwrap_or( usize::MAX );
                    let mut res = Vec::with_capacity( digits );

                    let mut r = 0;
                    let mut rbits = 0;

                    for c in &u.data {
                        r |= *c << rbits;
                        rbits += ::num::big::digit::BITS;

                        while rbits >= bits {
                            res.push( ( r & mask ) as u8 );
                            r >>= bits;

                           
                            if rbits > ::num::big::digit::BITS {
                                r = *c >> ( ::num::big::digit::BITS - ( rbits - bits ) );
                            }
                            rbits -= bits;
                        }
                    }
                    if rbits != 0 {
                        res.push( r as u8 );
                    }
                    while let Some( &0 ) = res.last() {
                        res.pop();
                    }
                    res
                }
               
                #[inline( always )]
                pub( super ) fn to_radix_digits_le( u:&BigUint, radix: u32 ) -> Vec<u8> {
                    debug_assert!( !u.is_zero() && !radix.is_power_of_two() );

                            let radix_digits = {
                        let radix_log2 = f64::from( radix ).log2();
                        ( ( u.bits() as f64 ) / radix_log2 ).ceil()
                    };
                    
                    let mut res = Vec::with_capacity( radix_digits.to_usize().unwrap_or( 0 ) );

                    let mut digits = u.clone();

                   
                   
                    let ( base, power ) = if FAST_DIV_WIDE {
                        get_radix_base( radix )
                    } else {
                        get_half_radix_base( radix )
                    };
                    let radix = radix as BigDigit;

                   
                   
                   
                   
                    if digits.data.len() >= 64 {
                        let mut big_base = BigUint::from( base );
                        let mut big_power = 1usize;

                       
                        let target_len = digits.data.len().sqrt();
                        while big_base.data.len() < target_len {
                            big_base = &big_base * &big_base;
                            big_power *= 2;
                        }
                       
                        while digits > big_base {
                           
                            let ( q, mut big_r ) = digits.div_rem( &big_base );
                            digits = q;

                           
                            for _ in 0..big_power {
                                let ( q, mut r ) = div_rem_digit( big_r, base );
                                big_r = q;
                                for _ in 0..power {
                                    res.push( ( r % radix ) as u8 );
                                    r /= radix;
                                }
                            }
                        }
                    }
                    while digits.data.len() > 1 {
                        let ( q, mut r ) = div_rem_digit( digits, base );
                        for _ in 0..power {
                            res.push( ( r % radix ) as u8 );
                            r /= radix;
                        }
                        digits = q;
                    }
                    let mut r = digits.data[0];
                    while r != 0 {
                        res.push( ( r % radix ) as u8 );
                        r /= radix;
                    }
                    res
                }
                pub( super ) fn to_radix_le( u:&BigUint, radix: u32 ) -> Vec<u8> {
                    if u.is_zero() {
                        vec![0]
                    } else if radix.is_power_of_two() {
                       
                        let bits = ilog2( radix );
                        if ::num::big::digit::BITS % bits == 0 {
                            to_bitwise_digits_le( u, bits )
                        } else {
                            to_inexact_bitwise_digits_le( u, bits )
                        }
                    } else if radix == 10 {
                       
                       
                        to_radix_digits_le( u, 10 )
                    } else {
                        to_radix_digits_le( u, radix )
                    }
                }
                pub fn to_str_radix_reversed( u:&BigUint, radix: u32 ) -> Vec<u8> {
                    assert!( 2 <= radix && radix <= 36, "The radix must be within 2...36" );

                    if u.is_zero() {
                        return vec![b'0'];
                    }
                    let mut res = to_radix_le( u, radix );

                   
                    for r in &mut res {
                        debug_assert!( u32::from( *r ) < radix );
                        if *r < 10 {
                            *r += b'0';
                        } else {
                            *r += b'a' - 10;
                        }
                    }
                    res
                }
                /// Returns the greatest power of the radix for the `BigDigit` bit size
                #[inline] fn get_radix_base( radix: u32 ) -> ( BigDigit, usize ) {
                    static BASES: [( BigDigit, usize ); 257] = generate_radix_bases( ::num::big::digit::MAX );
                    debug_assert!( !radix.is_power_of_two() );
                    debug_assert!( ( 3..256 ).contains( &radix ) );
                    BASES[radix as usize]
                }
                /// Returns the greatest power of the radix for half the `BigDigit` bit size
                #[inline] fn get_half_radix_base( radix: u32 ) -> ( BigDigit, usize ) {
                    static BASES: [( BigDigit, usize ); 257] = generate_radix_bases( ::num::big::digit::HALF );
                    debug_assert!( !radix.is_power_of_two() );
                    debug_assert!( ( 3..256 ).contains( &radix ) );
                    BASES[radix as usize]
                }
                /// Generate tables of the greatest power of each radix that is less that the given maximum. These
                /// are returned from `get_radix_base` to batch the multiplication/division of radix conversions on
                /// full `BigUint` values, operating on primitive integers as much as possible. Powers of two are not included, just zeroed, as they're implemented with shifts.
                const fn generate_radix_bases( max: BigDigit ) -> [( BigDigit, usize ); 257] {
                    let mut bases = [( 0, 0 ); 257];

                    let mut radix: BigDigit = 3;
                    while radix < 256 {
                        if !radix.is_power_of_two() {
                            let mut power = 1;
                            let mut base = radix;

                            while let Some( b ) = base.checked_mul( radix ) {
                                if b > max {
                                    break;
                                }
                                base = b;
                                power += 1;
                            }
                            bases[radix as usize] = ( base, power )
                        }
                        radix += 1;
                    }
                    bases
                }
            } pub use self::convert::to_str_radix_reversed;

            pub mod iter
            {
                /*!
                */
                use ::
                {
                    iter::{ FusedIterator },
                    *,
                };
                /*
                    use ::iter::FusedIterator;
                */
                cfg_digit!
                ( 
                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        it: ::slice::Iter<'a, u32>,
                    }
                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        data:&'a [u64],
                        next_is_lo: bool,
                        last_hi_is_zero: bool,
                    }
                 );

                cfg_digit!
                ( 
                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u32] ) -> Self {
                                Self { it: data.iter() }
                            }
                        }
                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next( &mut self ) -> Option<u32> {
                                self.it.next().cloned()
                            }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) {
                                self.it.size_hint()
                            }
                            #[inline]
                            fn nth( &mut self, n: usize ) -> Option<u32> {
                                self.it.nth( n ).cloned()
                            }
                            #[inline]
                            fn last( self ) -> Option<u32> {
                                self.it.last().cloned()
                            }
                            #[inline]
                            fn count( self ) -> usize {
                                self.it.count()
                            }
                        }
                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back( &mut self ) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }
                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len( &self ) -> usize {
                                self.it.len()
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u64] ) -> Self {
                                let last_hi_is_zero = data
                                    .last()
                                    .map( |&last| {
                                        let last_hi = ( last >> 32 ) as u32;
                                        last_hi == 0
                                    } )
                                    .unwrap_or( false );
                                U32Digits {
                                    data,
                                    next_is_lo: true,
                                    last_hi_is_zero,
                                }
                            }
                        }
                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next( &mut self ) -> Option<u32> {
                                match self.data.split_first() {
                                    Some( ( &first, data ) ) => {
                                        let next_is_lo = self.next_is_lo;
                                        self.next_is_lo = !next_is_lo;
                                        if next_is_lo {
                                            Some( first as u32 )
                                        } else {
                                            self.data = data;
                                            if data.is_empty() && self.last_hi_is_zero {
                                                self.last_hi_is_zero = false;
                                                None
                                            } else {
                                                Some( ( first >> 32 ) as u32 )
                                            }
                                        }
                                    }
                                    None => None,
                                }
                            }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) {
                                let len = self.len();
                                ( len, Some( len ) )
                            }
                            #[inline]
                            fn last( self ) -> Option<u32> {
                                self.data.last().map( |&last| {
                                    if self.last_hi_is_zero {
                                        last as u32
                                    } else {
                                        ( last >> 32 ) as u32
                                    }
                                } )
                            }
                            #[inline]
                            fn count( self ) -> usize {
                                self.len()
                            }
                        }
                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back( &mut self ) -> Option<Self::Item> {
                                match self.data.split_last() {
                                    Some( ( &last, data ) ) => {
                                        let last_is_lo = self.last_hi_is_zero;
                                        self.last_hi_is_zero = !last_is_lo;
                                        if last_is_lo {
                                            self.data = data;
                                            if data.is_empty() && !self.next_is_lo {
                                                self.next_is_lo = true;
                                                None
                                            } else {
                                                Some( last as u32 )
                                            }
                                        } else {
                                            Some( ( last >> 32 ) as u32 )
                                        }
                                    }
                                    None => None,
                                }
                            }
                        }
                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len( &self ) -> usize {
                                self.data.len() * 2
                                    - usize::from( self.last_hi_is_zero )
                                    - usize::from( !self.next_is_lo )
                            }
                        }
                    };
                 );

                impl FusedIterator for U32Digits<'_> {}
                cfg_digit!
                ( 
                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Chunks<'a, u32>,
                    }
                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Iter<'a, u64>,
                    }
                 );

                cfg_digit!
                ( 
                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u32] ) -> Self {
                                U64Digits { it: data.chunks( 2 ) }
                            }
                        }
                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next( &mut self ) -> Option<u64> {
                                self.it.next().map( super::u32_chunk_to_u64 )
                            }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) {
                                let len = self.len();
                                ( len, Some( len ) )
                            }
                            #[inline]
                            fn last( self ) -> Option<u64> {
                                self.it.last().map( super::u32_chunk_to_u64 )
                            }
                            #[inline]
                            fn count( self ) -> usize {
                                self.len()
                            }
                        }
                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back( &mut self ) -> Option<Self::Item> {
                                self.it.next_back().map( super::u32_chunk_to_u64 )
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u64] ) -> Self {
                                Self { it: data.iter() }
                            }
                        }
                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next( &mut self ) -> Option<u64> {
                                self.it.next().cloned()
                            }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) {
                                self.it.size_hint()
                            }
                            #[inline]
                            fn nth( &mut self, n: usize ) -> Option<u64> {
                                self.it.nth( n ).cloned()
                            }
                            #[inline]
                            fn last( self ) -> Option<u64> {
                                self.it.last().cloned()
                            }
                            #[inline]
                            fn count( self ) -> usize {
                                self.it.count()
                            }
                        }
                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back( &mut self ) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }
                    };
                 );

                impl ExactSizeIterator for U64Digits<'_>
                {
                    #[inline] fn len( &self ) -> usize {
                        self.it.len()
                    }
                }
                impl FusedIterator for U64Digits<'_> {}
            }
            pub mod monty
            {
                /*!
                */
                use ::
                {
                    vec::{ Vec },
                    ops::{ Shl },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit, DoubleBigDigit},
                            uint::BigUint,
                        },
                        traits::One,
                    },
                    *,
                };
                /*
                */
                struct MontyReducer {
                    n0inv: BigDigit,
                }
               
               
                fn inv_mod_alt( b: BigDigit ) -> BigDigit {
                    assert_ne!( b & 1, 0 );

                    let mut k0 = BigDigit::wrapping_sub( 2, b );
                    let mut t = b - 1;
                    let mut i = 1;
                    while i < ::num::big::digit::BITS {
                        t = t.wrapping_mul( t );
                        k0 = k0.wrapping_mul( t + 1 );

                        i <<= 1;
                    }
                    debug_assert_eq!( k0.wrapping_mul( b ), 1 );
                    k0.wrapping_neg()
                }
                impl MontyReducer {
                    fn new( n:&BigUint ) -> Self {
                        let n0inv = inv_mod_alt( n.data[0] );
                        MontyReducer { n0inv }
                    }
                }
                /// Computes z mod m = x * y * 2 ** ( -n*_W ) mod m
                /// assuming k = -1/m mod 2**_W
                /// See Gueron, "Efficient Software Implementations of Modular Exponentiation".
                #[allow( clippy::many_single_char_names )]
                fn montgomery( x:&BigUint, y:&BigUint, m:&BigUint, k: BigDigit, n: usize ) -> BigUint {
                   
                   
                   
                   
                    assert!( 
                        x.data.len() == n && y.data.len() == n && m.data.len() == n,
                        "{:?} {:?} {:?} {}",
                        x,
                        y,
                        m,
                        n
                     );

                    let mut z = BigUint::ZERO;
                    z.data.resize( n * 2, 0 );

                    let mut c: BigDigit = 0;
                    for i in 0..n {
                        let c2 = add_mul_vvw( &mut z.data[i..n + i], &x.data, y.data[i] );
                        let t = z.data[i].wrapping_mul( k );
                        let c3 = add_mul_vvw( &mut z.data[i..n + i], &m.data, t );
                        let cx = c.wrapping_add( c2 );
                        let cy = cx.wrapping_add( c3 );
                        z.data[n + i] = cy;
                        if cx < c2 || cy < c3 {
                            c = 1;
                        } else {
                            c = 0;
                        }
                    }
                    if c == 0 {
                        z.data = z.data[n..].to_vec();
                    } else {
                        {
                            let ( first, second ) = z.data.split_at_mut( n  );
                            sub_vv( first, second, &m.data );
                        }
                        z.data = z.data[..n].to_vec();
                    }
                    z
                }
                #[inline( always )] fn add_mul_vvw( z:&mut [BigDigit], x:&[BigDigit], y: BigDigit ) -> BigDigit {
                    let mut c = 0;
                    for ( zi, xi ) in z.iter_mut().zip( x.iter() ) {
                        let ( z1, z0 ) = mul_add_www( *xi, y, *zi );
                        let ( c_, zi_ ) = add_ww( z0, c, 0 );
                        *zi = zi_;
                        c = c_ + z1;
                    }
                    c
                }
                /// The resulting carry c is either 0 or 1.
                #[inline( always )] fn sub_vv( z:&mut [BigDigit], x:&[BigDigit], y:&[BigDigit] ) -> BigDigit {
                    let mut c = 0;
                    for ( i, ( xi, yi ) ) in x.iter().zip( y.iter() ).enumerate().take( z.len() ) {
                        let zi = xi.wrapping_sub( *yi ).wrapping_sub( c );
                        z[i] = zi;
                       
                        c = (( yi & !xi ) | ( ( yi | !xi ) & zi ) ) >> ( ::num::big::digit::BITS - 1 )
                    }
                    c
                }
                /// z1<<_W + z0 = x+y+c, with c == 0 or 1
                #[inline( always )] fn add_ww( x: BigDigit, y: BigDigit, c: BigDigit ) -> ( BigDigit, BigDigit ) {
                    let yc = y.wrapping_add( c );
                    let z0 = x.wrapping_add( yc );
                    let z1 = if z0 < x || yc < y { 1 } else { 0 };

                    ( z1, z0 )
                }
                /// z1 << _W + z0 = x * y + c
                #[inline( always )] fn mul_add_www( x: BigDigit, y: BigDigit, c: BigDigit ) -> ( BigDigit, BigDigit ) {
                    let z = x as DoubleBigDigit * y as DoubleBigDigit + c as DoubleBigDigit;
                    ( ( z >> ::num::big::digit::BITS ) as BigDigit, z as BigDigit )
                }
                /// Calculates x ** y mod m using a fixed, 4-bit window.
                #[allow( clippy::many_single_char_names )]
                pub( super ) fn monty_modpow( x:&BigUint, y:&BigUint, m:&BigUint ) -> BigUint {
                    assert!( m.data[0] & 1 == 1 );
                    let mr = MontyReducer::new( m );
                    let num_words = m.data.len();

                    let mut x = x.clone();

                   
                   
                    if x.data.len() > num_words {
                        x %= m;
                       
                    }
                    if x.data.len() < num_words {
                        x.data.resize( num_words, 0 );
                    }
                   
                    let mut rr = BigUint::one();
                    rr = ( rr.shl( 2 * num_words as u64 * u64::from( ::num::big::digit::BITS ) ) ) % m;
                    if rr.data.len() < num_words {
                        rr.data.resize( num_words, 0 );
                    }
                   
                    let mut one = BigUint::one();
                    one.data.resize( num_words, 0 );

                    let n = 4;
                   
                    let mut powers = Vec::with_capacity( 1 << n );
                    powers.push( montgomery( &one, &rr, m, mr.n0inv, num_words ) );
                    powers.push( montgomery( &x, &rr, m, mr.n0inv, num_words ) );
                    for i in 2..1 << n {
                        let r = montgomery( &powers[i - 1], &powers[1], m, mr.n0inv, num_words );
                        powers.push( r );
                    }
                   
                    let mut z = powers[0].clone();
                    z.data.resize( num_words, 0 );
                    let mut zz = BigUint::ZERO;
                    zz.data.resize( num_words, 0 );

                   
                    for i in ( 0..y.data.len() ).rev() {
                        let mut yi = y.data[i];
                        let mut j = 0;
                        while j < ::num::big::digit::BITS {
                            if i != y.data.len() - 1 || j != 0 {
                                zz = montgomery( &z, &z, m, mr.n0inv, num_words );
                                z = montgomery( &zz, &zz, m, mr.n0inv, num_words );
                                zz = montgomery( &z, &z, m, mr.n0inv, num_words );
                                z = montgomery( &zz, &zz, m, mr.n0inv, num_words );
                            }
                            zz = montgomery( 
                                &z,
                                &powers[( yi >> ( ::num::big::digit::BITS - n ) ) as usize],
                                m,
                                mr.n0inv,
                                num_words,
                             );
                            mem::swap( &mut z, &mut zz );
                            yi <<= n;
                            j += n;
                        }
                    }
                   
                    zz = montgomery( &z, &one, m, mr.n0inv, num_words );

                    zz.normalize();
                   
                   
                    if zz >= *m {
                       
                       
                       
                       
                       
                       
                       
                        zz -= m;
                        if zz >= *m {
                            zz %= m;
                        }
                    }
                    zz.normalize();
                    zz
                }
            } pub use self::iter::{U32Digits, U64Digits};

            pub mod power
            {
                /*!
                */
                use ::
                {
                    num::
                    {
                        big::digit::{self, BigDigit},
                        integers::Integer,
                        traits::{One, Pow, ToPrimitive, Zero},
                    },
                    *,
                };
                use super::monty::monty_modpow;
                use super::BigUint;
                /*
                */
                impl Pow<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp:&BigUint ) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            Self::ZERO
                        } else if let Some( exp ) = exp.to_u64() {
                            self.pow( exp )
                        } else if let Some( exp ) = exp.to_u128() {
                            self.pow( exp )
                        } else {
                           
                           
                            panic!( "memory overflow" )
                        }
                    }
                }
                impl Pow<BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp: BigUint ) -> BigUint {
                        Pow::pow( self, &exp )
                    }
                }
                impl Pow<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp:&BigUint ) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            BigUint::ZERO
                        } else {
                            self.clone().pow( exp )
                        }
                    }
                }
                impl Pow<BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp: BigUint ) -> BigUint {
                        Pow::pow( self, &exp )
                    }
                }
                macro_rules! pow_impl 
                {
                    ( $T:ty ) => {
                        impl Pow<$T> for BigUint {
                            type Output = BigUint;

                            fn pow( self, mut exp: $T ) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                let mut base = self;

                                while exp & 1 == 0 {
                                    base = &base * &base;
                                    exp >>= 1;
                                }
                                if exp == 1 {
                                    return base;
                                }
                                let mut acc = base.clone();
                                while exp > 1 {
                                    exp >>= 1;
                                    base = &base * &base;
                                    if exp & 1 == 1 {
                                        acc *= &base;
                                    }
                                }
                                acc
                            }
                        }
                        impl Pow<&$T> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow( self, exp:&$T ) -> BigUint {
                                Pow::pow( self, *exp )
                            }
                        }
                        impl Pow<$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow( self, exp: $T ) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                Pow::pow( self.clone(), exp )
                            }
                        }
                        impl Pow<&$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow( self, exp:&$T ) -> BigUint {
                                Pow::pow( self, *exp )
                            }
                        }
                    };
                }
                pow_impl!( u8 );
                pow_impl!( u16 );
                pow_impl!( u32 );
                pow_impl!( u64 );
                pow_impl!( usize );
                pow_impl!( u128 );

                pub fn modpow( x:&BigUint, exponent:&BigUint, modulus:&BigUint ) -> BigUint 
                {
                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );

                    if modulus.is_odd() {
                       
                        monty_modpow( x, exponent, modulus )
                    } else {
                       
                        plain_modpow( x, &exponent.data, modulus )
                    }
                }
                pub fn plain_modpow( base:&BigUint, exp_data:&[BigDigit], modulus:&BigUint ) -> BigUint 
                {
                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );

                    let i = match exp_data.iter().position( |&r| r != 0 ) {
                        None => return BigUint::one(),
                        Some( i ) => i,
                    };

                    let mut base = base % modulus;
                    for _ in 0..i {
                        for _ in 0..::num::big::digit::BITS {
                            base = &base * &base % modulus;
                        }
                    }
                    let mut r = exp_data[i];
                    let mut b = 0u8;
                    while r.is_even() {
                        base = &base * &base % modulus;
                        r >>= 1;
                        b += 1;
                    }
                    let mut exp_iter = exp_data[i + 1..].iter();
                    if exp_iter.len() == 0 && r.is_one() {
                        return base;
                    }
                    let mut acc = base.clone();
                    r >>= 1;
                    b += 1;

                    {
                        let mut unit = |exp_is_odd| {
                            base = &base * &base % modulus;
                            if exp_is_odd {
                                acc *= &base;
                                acc %= modulus;
                            }
                        };

                        if let Some( &last ) = exp_iter.next_back() {
                           
                            for _ in b..::num::big::digit::BITS {
                                unit( r.is_odd() );
                                r >>= 1;
                            }
                           
                            for &r in exp_iter {
                                let mut r = r;
                                for _ in 0..::num::big::digit::BITS {
                                    unit( r.is_odd() );
                                    r >>= 1;
                                }
                            }
                            r = last;
                        }
                        debug_assert_ne!( r, 0 );
                        while !r.is_zero() {
                            unit( r.is_odd() );
                            r >>= 1;
                        }
                    }
                    acc
                }
            }
            pub mod shift
            {
                /*!
                */
                use ::
                {
                    borrow::{ Cow },
                    num::
                    {
                        big::{ digit },
                        traits::{PrimInt, Zero},
                    },
                    ops::{Shl, ShlAssign, Shr, ShrAssign},
                    vec::{ Vec },
                    *,
                };

                use super::{biguint_from_vec, BigUint};
                /*
                */
                #[inline] fn biguint_shl<T: PrimInt>( n: Cow<'_, BigUint>, shift: T ) -> BigUint {
                    if shift < T::zero() {
                        panic!( "attempt to shift left with negative" );
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from( ::num::big::digit::BITS ).unwrap();
                    let digits = ( shift / bits ).to_usize().expect( "capacity overflow" );
                    let shift = ( shift % bits ).to_u8().unwrap();
                    biguint_shl2( n, digits, shift )
                }
                fn biguint_shl2( n: Cow<'_, BigUint>, digits: usize, shift: u8 ) -> BigUint {
                    let mut data = match digits {
                        0 => n.into_owned().data,
                        _ => {
                            let len = digits.saturating_add( n.data.len() + 1 );
                            let mut data = Vec::with_capacity( len );
                            data.resize( digits, 0 );
                            data.extend( n.data.iter() );
                            data
                        }
                    };

                    if shift > 0 {
                        let mut carry = 0;
                        let carry_shift = ::num::big::digit::BITS - shift;
                        for elem in data[digits..].iter_mut() {
                            let new_carry = *elem >> carry_shift;
                            *elem = ( *elem << shift ) | carry;
                            carry = new_carry;
                        }
                        if carry != 0 {
                            data.push( carry );
                        }
                    }
                    biguint_from_vec( data )
                }
                #[inline] fn biguint_shr<T: PrimInt>( n: Cow<'_, BigUint>, shift: T ) -> BigUint {
                    if shift < T::zero() {
                        panic!( "attempt to shift right with negative" );
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from( ::num::big::digit::BITS ).unwrap();
                    let digits = ( shift / bits ).to_usize().unwrap_or( usize::MAX );
                    let shift = ( shift % bits ).to_u8().unwrap();
                    biguint_shr2( n, digits, shift )
                }
                fn biguint_shr2( n: Cow<'_, BigUint>, digits: usize, shift: u8 ) -> BigUint {
                    if digits >= n.data.len() {
                        let mut n = n.into_owned();
                        n.set_zero();
                        return n;
                    }
                    let mut data = match n {
                        Cow::Borrowed( n ) => n.data[digits..].to_vec(),
                        Cow::Owned( mut n ) => {
                            n.data.drain( ..digits );
                            n.data
                        }
                    };

                    if shift > 0 {
                        let mut borrow = 0;
                        let borrow_shift = ::num::big::digit::BITS - shift;
                        for elem in data.iter_mut().rev() {
                            let new_borrow = *elem << borrow_shift;
                            *elem = ( *elem >> shift ) | borrow;
                            borrow = new_borrow;
                        }
                    }
                    biguint_from_vec( data )
                }
                macro_rules! impl_shift {
                    ( @ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty ) => {
                        impl $Shx<&$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigUint {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $Shx<&$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigUint {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigUint {
                            #[inline]
                            fn $shx_assign( &mut self, rhs:&$rhs ) {
                                $ShxAssign::$shx_assign( self, *rhs );
                            }
                        }
                    };
                    ( $( $rhs:ty ),+ ) => {$( 
                        impl Shl<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigUint {
                                biguint_shl( Cow::Owned( self ), rhs )
                            }
                        }
                        impl Shl<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigUint {
                                biguint_shl( Cow::Borrowed( self ), rhs )
                            }
                        }
                        impl ShlAssign<$rhs> for BigUint {
                            #[inline]
                            fn shl_assign( &mut self, rhs: $rhs ) {
                                let n = mem::replace( self, Self::ZERO );
                                *self = n << rhs;
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }
                        impl Shr<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigUint {
                                biguint_shr( Cow::Owned( self ), rhs )
                            }
                        }
                        impl Shr<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigUint {
                                biguint_shr( Cow::Borrowed( self ), rhs )
                            }
                        }
                        impl ShrAssign<$rhs> for BigUint {
                            #[inline]
                            fn shr_assign( &mut self, rhs: $rhs ) {
                                let n = mem::replace( self, Self::ZERO );
                                *self = n >> rhs;
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }
                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
            }
            /// A big unsigned integer type.
            pub struct BigUint
            {
                data: Vec<BigDigit>,
            }
            
            impl Clone for BigUint
            {
                #[inline] fn clone( &self ) -> Self {
                    BigUint {
                        data: self.data.clone(),
                    }
                }
                #[inline] fn clone_from( &mut self, other:&Self ) {
                    self.data.clone_from( &other.data );
                }
            }
            
            impl hash::Hash for BigUint
            {
                #[inline] fn hash<H: hash::Hasher>( &self, state:&mut H ) {
                    debug_assert!( self.data.last() != Some( &0 ) );
                    self.data.hash( state  );
                }
            }
            
            impl PartialEq for BigUint
            {
                #[inline] fn eq( &self, other:&BigUint ) -> bool {
                    debug_assert!( self.data.last() != Some( &0 ) );
                    debug_assert!( other.data.last() != Some( &0 ) );
                    self.data == other.data
                }
            }
            
            impl Eq for BigUint {}
            
            impl PartialOrd for BigUint
            {
                #[inline] fn partial_cmp( &self, other:&BigUint ) -> Option<Ordering> {
                    Some( self.cmp( other ) )
                }
            }
            
            impl Ord for BigUint
            {
                #[inline] fn cmp( &self, other:&BigUint ) -> Ordering {
                    cmp_slice( &self.data[..], &other.data[..] )
                }
            }
            #[inline] fn cmp_slice( a:&[BigDigit], b:&[BigDigit] ) -> Ordering
            {
                debug_assert!( a.last() != Some( &0 ) );
                debug_assert!( b.last() != Some( &0 ) );

                match Ord::cmp( &a.len(), &b.len() ) {
                    Ordering::Equal => Iterator::cmp( a.iter().rev(), b.iter().rev() ),
                    other => other,
                }
            }
            
            impl Default for BigUint
            {
                #[inline] fn default() -> BigUint {
                    Self::ZERO
                }
            }
            
            impl fmt::Debug for BigUint {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    fmt::Display::fmt( self, f )
                }
            }
            
            impl fmt::Display for BigUint {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "", &self.to_str_radix( 10 ) )
                }
            }
            
            impl fmt::LowerHex for BigUint {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "0x", &self.to_str_radix( 16 ) )
                }
            }
            
            impl fmt::UpperHex for BigUint {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    let mut s = self.to_str_radix( 16 );
                    s.make_ascii_uppercase();
                    f.pad_integral( true, "0x", &s )
                }
            }
            
            impl fmt::Binary for BigUint {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "0b", &self.to_str_radix( 2 ) )
                }
            }
            
            impl fmt::Octal for BigUint {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "0o", &self.to_str_radix( 8 ) )
                }
            }
            
            impl Zero for BigUint
            {
                #[inline] fn zero() -> BigUint {
                    Self::ZERO
                }
                #[inline] fn set_zero( &mut self ) {
                    self.data.clear();
                }
                #[inline] fn is_zero( &self ) -> bool {
                    self.data.is_empty()
                }
            }
            
            impl ConstZero for BigUint {
               
                const ZERO: Self = Self::ZERO;
            }
            
            impl One for BigUint
            {
                #[inline] fn one() -> BigUint {
                    BigUint { data: vec![1] }
                }
                #[inline] fn set_one( &mut self ) {
                    self.data.clear();
                    self.data.push( 1 );
                }
                #[inline] fn is_one( &self ) -> bool {
                    self.data[..] == [1]
                }
            }
            
            impl Unsigned for BigUint {}
            
            impl Integer for BigUint
            {
                #[inline] fn div_rem( &self, other:&BigUint ) -> ( BigUint, BigUint ) {
                    division::div_rem_ref( self, other )
                }
                #[inline] fn div_floor( &self, other:&BigUint ) -> BigUint {
                    let ( d, _ ) = division::div_rem_ref( self, other );
                    d
                }
                #[inline] fn mod_floor( &self, other:&BigUint ) -> BigUint {
                    let ( _, m ) = division::div_rem_ref( self, other );
                    m
                }
                #[inline] fn div_mod_floor( &self, other:&BigUint ) -> ( BigUint, BigUint ) {
                    division::div_rem_ref( self, other )
                }
                #[inline] fn div_ceil( &self, other:&BigUint ) -> BigUint {
                    let ( d, m ) = division::div_rem_ref( self, other );
                    if m.is_zero() {
                        d
                    } else {
                        d + 1u32
                    }
                }
                /// Calculates the Greatest Common Divisor ( GCD ) of the number and `other`.
                #[inline] fn gcd( &self, other:&Self ) -> Self
                {
                    #[inline] fn twos( x:&BigUint ) -> u64 {
                        x.trailing_zeros().unwrap_or( 0 )
                    }
                   
                    if self.is_zero() {
                        return other.clone();
                    }
                    if other.is_zero() {
                        return self.clone();
                    }
                    let mut m = self.clone();
                    let mut n = other.clone();

                   
                    let shift = cmp::min( twos( &n ), twos( &m ) );

                   
                   
                    n >>= twos( &n );

                    while !m.is_zero() {
                        m >>= twos( &m );
                        if n > m {
                            mem::swap( &mut n, &mut m )
                        }
                        m -= &n;
                    }
                    n << shift
                }
                /// Calculates the Lowest Common Multiple ( LCM ) of the number and `other`.
                #[inline] fn lcm( &self, other:&BigUint ) -> BigUint
                {
                    if self.is_zero() && other.is_zero() {
                        Self::ZERO
                    } else {
                        self / self.gcd( other ) * other
                    }
                }
                /// Calculates the Greatest Common Divisor ( GCD ) and Lowest Common Multiple ( LCM ) together.
                #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self )
                {
                    let gcd = self.gcd( other );
                    let lcm = if gcd.is_zero() {
                        Self::ZERO
                    } else {
                        self / &gcd * other
                    };
                    ( gcd, lcm )
                }
                /// Deprecated, use `is_multiple_of` instead.
                #[inline] fn divides( &self, other:&BigUint ) -> bool {
                    self.is_multiple_of( other )
                }
                /// Returns `true` if the number is a multiple of `other`.
                #[inline] fn is_multiple_of( &self, other:&BigUint ) -> bool {
                    if other.is_zero() {
                        return self.is_zero();
                    }
                    ( self % other ).is_zero()
                }
                /// Returns `true` if the number is divisible by `2`.
                #[inline] fn is_even( &self ) -> bool
                {                   
                    match self.data.first() {
                        Some( x ) => x.is_even(),
                        None => true,
                    }
                }
                /// Returns `true` if the number is not divisible by `2`.
                #[inline] fn is_odd( &self ) -> bool {
                    !self.is_even()
                }
                /// Rounds up to nearest multiple of argument.
                #[inline] fn next_multiple_of( &self, other:&Self ) -> Self {
                    let m = self.mod_floor( other );
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + ( other - m )
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self {
                    self - self.mod_floor( other )
                }
                fn dec( &mut self ) {
                    *self -= 1u32;
                }
                fn inc( &mut self ) {
                    *self += 1u32;
                }
            }
            #[inline] fn fixpoint<F>( mut x: BigUint, max_bits: u64, f: F ) -> BigUint where
                F: Fn( &BigUint ) -> BigUint,
            {
                let mut xn = f( &x );

               
               
                while x < xn {
                   
                   
                   
                    x = if xn.bits() > max_bits {
                        BigUint::one() << max_bits
                    } else {
                        xn
                    };
                    xn = f( &x );
                }
               
                while x > xn {
                    x = xn;
                    xn = f( &x );
                }
                x
            }
            
            impl Roots for BigUint
            {  
                fn nth_root( &self, n: u32 ) -> Self {
                    assert!( n > 0, "root degree n must be at least 1" );

                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                    match n {
                       
                        1 => return self.clone(),
                        2 => return self.sqrt(),
                        3 => return self.cbrt(),
                        _ => (),
                    }
                   
                    let bits = self.bits();
                    let n64 = u64::from( n  );
                    if bits <= n64 {
                        return BigUint::one();
                    }
                   
                    if let Some( x ) = self.to_u64() {
                        return x.nth_root( n ).into();
                    }
                    let max_bits = bits / n64 + 1;

                    #[cfg( feature = "std" )]
                    let guess = match self.to_f64() {
                        Some( f ) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                           
                            BigUint::from_f64( ( f.ln() / f64::from( n ) ).exp() ).unwrap()
                        }
                        _ => {
                           
                           
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = Integer::div_ceil( &extra_bits, &n64 );
                            let scale = root_scale * n64;
                            if scale < bits && bits - scale > n64 {
                                ( self >> scale ).nth_root( n ) << root_scale
                            } else {
                                BigUint::one() << max_bits
                            }
                        }
                    };

                    #[cfg( not( feature = "std" ) )]
                    let guess = BigUint::one() << max_bits;

                    let n_min_1 = n - 1;
                    fixpoint( guess, max_bits, move |s| {
                        let q = self / s.pow( n_min_1 );
                        let t = n_min_1 * s + q;
                        t / n
                    } )
                }
               
               
                fn sqrt( &self ) -> Self {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                   
                    if let Some( x ) = self.to_u64() {
                        return x.sqrt().into();
                    }
                    let bits = self.bits();
                    let max_bits = bits / 2 + 1;

                    #[cfg( feature = "std" )]
                    let guess = match self.to_f64() {
                        Some( f ) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                           
                            BigUint::from_f64( f.sqrt() ).unwrap()
                        }
                        _ => {
                           
                           
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = ( extra_bits + 1 ) / 2;
                            let scale = root_scale * 2;
                            ( self >> scale ).sqrt() << root_scale
                        }
                    };

                    #[cfg( not( feature = "std" ) )]
                    let guess = BigUint::one() << max_bits;

                    fixpoint( guess, max_bits, move |s| {
                        let q = self / s;
                        let t = s + q;
                        t >> 1
                    } )
                }
                fn cbrt( &self ) -> Self {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                   
                    if let Some( x ) = self.to_u64() {
                        return x.cbrt().into();
                    }
                    let bits = self.bits();
                    let max_bits = bits / 3 + 1;

                    #[cfg( feature = "std" )]
                    let guess = match self.to_f64() {
                        Some( f ) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                           
                            BigUint::from_f64( f.cbrt() ).unwrap()
                        }
                        _ => {
                           
                           
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = ( extra_bits + 2 ) / 3;
                            let scale = root_scale * 3;
                            ( self >> scale ).cbrt() << root_scale
                        }
                    };

                    #[cfg( not( feature = "std" ) )]
                    let guess = BigUint::one() << max_bits;

                    fixpoint( guess, max_bits, move |s| {
                        let q = self / ( s * s );
                        let t = ( s << 1 ) + q;
                        t / 3u32
                    } )
                }
            }
            /// A generic trait for converting a value to a [`BigUint`].
            pub trait ToBigUint
            {
                /// Converts the value of `self` to a [`BigUint`].
                fn to_biguint( &self ) -> Option<BigUint>;
            }
            /// Creates and initializes a [`BigUint`].
            #[inline] pub fn biguint_from_vec( digits: Vec<BigDigit> ) -> BigUint
            {
                BigUint { data: digits }.normalized()
            }
            
            impl BigUint
            {
                /// A constant `BigUint` with value 0, useful for static initialization.
                pub const ZERO: Self = BigUint { data: Vec::new() };
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn new( digits: Vec<u32> ) -> BigUint
                {
                    let mut big = Self::ZERO;

                    cfg_digit_expr!( 
                        {
                            big.data = digits;
                            big.normalize();
                        },
                        big.assign_from_slice( &digits )
                     );

                    big
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_slice( slice:&[u32] ) -> BigUint
                {
                    let mut big = Self::ZERO;
                    big.assign_from_slice( slice );
                    big
                }
                /// Assign a value to a [`BigUint`].
                #[inline] pub fn assign_from_slice( &mut self, slice:&[u32] )
                {
                    self.data.clear();

                    cfg_digit_expr!( 
                        self.data.extend_from_slice( slice ),
                        self.data.extend( slice.chunks( 2 ).map( u32_chunk_to_u64 ) )
                     );

                    self.normalize();
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_bytes_be( bytes:&[u8] ) -> BigUint
                {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        let mut v = bytes.to_vec();
                        v.reverse();
                        BigUint::from_bytes_le( &v )
                    }
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn from_bytes_le( bytes:&[u8] ) -> BigUint
                {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        convert::from_bitwise_digits_le( bytes, 8 )
                    }
                }
                /// Creates and initializes a [`BigUint`].
                #[inline] pub fn parse_bytes( buf:&[u8], radix: u32 ) -> Option<BigUint>
                {
                    let s = str::from_utf8( buf ).ok()?;
                    BigUint::from_str_radix( s, radix ).ok()
                }
                /// Creates and initializes a [`BigUint`].
                pub fn from_radix_be( buf:&[u8], radix: u32 ) -> Option<BigUint>
                {
                    convert::from_radix_be( buf, radix )
                }
                /// Creates and initializes a [`BigUint`].
                pub fn from_radix_le( buf:&[u8], radix: u32 ) -> Option<BigUint>
                {
                    convert::from_radix_le( buf, radix )
                }
                /// Returns the byte representation of the [`BigUint`] in big-endian byte order.
                #[inline] pub fn to_bytes_be( &self ) -> Vec<u8> {
                    let mut v = self.to_bytes_le();
                    v.reverse();
                    v
                }
                /// Returns the byte representation of the [`BigUint`] in little-endian byte order.
                #[inline] pub fn to_bytes_le( &self ) -> Vec<u8> {
                    if self.is_zero() {
                        vec![0]
                    } else {
                        convert::to_bitwise_digits_le( self, 8 )
                    }
                }
                /// Returns the `u32` digits representation of the [`BigUint`] ordered least significant digit first.
                #[inline] pub fn to_u32_digits( &self ) -> Vec<u32> {
                    self.iter_u32_digits().collect()
                }
                /// Returns the `u64` digits representation of the [`BigUint`] ordered least significant digit first.
                #[inline] pub fn to_u64_digits( &self ) -> Vec<u64> {
                    self.iter_u64_digits().collect()
                }
                /// Returns an iterator of `u32` digits representation of the 
                /// [`BigUint`] ordered least significant digit first.
                #[inline] pub fn iter_u32_digits( &self ) -> U32Digits<'_> {
                    U32Digits::new( self.data.as_slice() )
                }
                /// Returns an iterator of `u64` digits representation of the
                /// [`BigUint`] ordered least significant digit first.
                #[inline] pub fn iter_u64_digits( &self ) -> U64Digits<'_> {
                    U64Digits::new( self.data.as_slice() )
                }
                /// Returns the integer formatted as a string in the given radix.
                #[inline] pub fn to_str_radix( &self, radix: u32 ) -> String {
                    let mut v = to_str_radix_reversed( self, radix );
                    v.reverse();
                    unsafe { String::from_utf8_unchecked( v ) }
                }
                /// Returns the integer in the requested base in big-endian digit order.
                #[inline] pub fn to_radix_be( &self, radix: u32 ) -> Vec<u8> {
                    let mut v = convert::to_radix_le( self, radix );
                    v.reverse();
                    v
                }
                /// Returns the integer in the requested base in little-endian digit order.
                #[inline] pub fn to_radix_le( &self, radix: u32 ) -> Vec<u8> {
                    convert::to_radix_le( self, radix )
                }
                /// Determines the fewest bits necessary to express the [`BigUint`].
                #[inline] pub fn bits( &self ) -> u64 {
                    if self.is_zero() {
                        return 0;
                    }
                    let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
                    self.data.len() as u64 * u64::from( ::num::big::digit::BITS ) - zeros
                }
                /// Strips off trailing zero bigdigits.
                #[inline] fn normalize( &mut self ) {
                    if let Some( &0 ) = self.data.last() {
                        let len = self.data.iter().rposition( |&d| d != 0 ).map_or( 0, |i| i + 1 );
                        self.data.truncate( len );
                    }
                    if self.data.len() < self.data.capacity() / 4 {
                        self.data.shrink_to_fit();
                    }
                }
                /// Returns a normalized [`BigUint`].
                #[inline] fn normalized( mut self ) -> BigUint {
                    self.normalize();
                    self
                }
                /// Returns `self ^ exponent`.
                pub fn pow( &self, exponent: u32 ) -> Self {
                    Pow::pow( self, exponent )
                }
                /// Returns `( self ^ exponent ) % modulus`.
                pub fn modpow( &self, exponent:&Self, modulus:&Self ) -> Self {
                    power::modpow( self, exponent, modulus )
                }
                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                pub fn modinv( &self, modulus:&Self ) -> Option<Self> {
                   
                   
                   

                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );
                    if modulus.is_one() {
                        return Some( Self::zero() );
                    }
                    let mut r0;
                    let mut r1 = self % modulus;
                    let mut t0;
                    let mut t1;

                   
                    if r1.is_zero() {
                        return None;
                    } else if r1.is_one() {
                        return Some( r1 );
                    } else {
                        let ( q, r2 ) = modulus.div_rem( &r1 );
                        if r2.is_zero() {
                            return None;
                        }
                        r0 = r1;
                        r1 = r2;
                        t0 = Self::one();
                        t1 = modulus - q;
                    }
                    while !r1.is_zero() {
                        let ( q, r2 ) = r0.div_rem( &r1 );
                        r0 = r1;
                        r1 = r2;

                       
                        let qt1 = q * &t1 % modulus;
                        let t2 = if t0 < qt1 {
                            t0 + ( modulus - qt1 )
                        } else {
                            t0 - qt1
                        };
                        t0 = t1;
                        t1 = t2;
                    }
                    if r0.is_one() {
                        Some( t0 )
                    } else {
                        None
                    }
                }
                /// Returns the truncated principal square root of `self`
                pub fn sqrt( &self ) -> Self {
                    Roots::sqrt( self )
                }
                /// Returns the truncated principal cube root of `self`
                pub fn cbrt( &self ) -> Self {
                    Roots::cbrt( self )
                }
                /// Returns the truncated principal `n`th root of `self`
                pub fn nth_root( &self, n: u32 ) -> Self {
                    Roots::nth_root( self, n )
                }
                /// Returns the number of least-significant bits that are zero, 
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros( &self ) -> Option<u64> {
                    let i = self.data.iter().position( |&digit| digit != 0 )?;
                    let zeros: u64 = self.data[i].trailing_zeros().into();
                    Some( i as u64 * u64::from( ::num::big::digit::BITS ) + zeros )
                }
                /// Returns the number of least-significant bits that are ones.
                pub fn trailing_ones( &self ) -> u64 {
                    if let Some( i ) = self.data.iter().position( |&digit| !digit != 0 ) {
                        let ones: u64 = self.data[i].trailing_ones().into();
                        i as u64 * u64::from( ::num::big::digit::BITS ) + ones
                    } else {
                        self.data.len() as u64 * u64::from( ::num::big::digit::BITS )
                    }
                }
                /// Returns the number of one bits.
                pub fn count_ones( &self ) -> u64 {
                    self.data.iter().map( |&d| u64::from( d.count_ones() ) ).sum()
                }
                /// Returns whether the bit in the given position is set
                pub fn bit( &self, bit: u64 ) -> bool
                {
                    let bits_per_digit = u64::from( ::num::big::digit::BITS );
                    if let Some( digit_index ) = ( bit / bits_per_digit ).to_usize() {
                        if let Some( digit ) = self.data.get( digit_index ) {
                            let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                            return ( digit & bit_mask ) != 0;
                        }
                    }
                    false
                }
                /// Sets or clears the bit in the given position.
                pub fn set_bit( &mut self, bit: u64, value: bool )
                {
                    let bits_per_digit = u64::from( ::num::big::digit::BITS );
                    let digit_index = ( bit / bits_per_digit ).to_usize().unwrap_or( usize::MAX );
                    let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                    if value {
                        if digit_index >= self.data.len() {
                            let new_len = digit_index.saturating_add( 1 );
                            self.data.resize( new_len, 0 );
                        }
                        self.data[digit_index] |= bit_mask;
                    } else if digit_index < self.data.len() {
                        self.data[digit_index] &= !bit_mask;
                       
                        self.normalize();
                    }
                }
            }
            
            impl ::num::traits::FromBytes for BigUint {
                type Bytes = [u8];

                fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_bytes_be( bytes )
                }
                fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_bytes_le( bytes )
                }
            }
            
            impl ::num::traits::ToBytes for BigUint {
                type Bytes = Vec<u8>;

                fn to_be_bytes( &self ) -> Self::Bytes {
                    self.to_bytes_be()
                }
                fn to_le_bytes( &self ) -> Self::Bytes {
                    self.to_bytes_le()
                }
            }
            pub trait IntDigits {
                fn digits( &self ) -> &[BigDigit];
                fn digits_mut( &mut self ) -> &mut Vec<BigDigit>;
                fn normalize( &mut self );
                fn capacity( &self ) -> usize;
                fn len( &self ) -> usize;
            }
            
            impl IntDigits for BigUint
            {
                #[inline] fn digits( &self ) -> &[BigDigit] {
                    &self.data
                }
                #[inline] fn digits_mut( &mut self ) -> &mut Vec<BigDigit> {
                    &mut self.data
                }
                #[inline] fn normalize( &mut self ) {
                    self.normalize();
                }
                #[inline] fn capacity( &self ) -> usize {
                    self.data.capacity()
                }
                #[inline] fn len( &self ) -> usize {
                    self.data.len()
                }
            }
            /// Convert a `u32` chunk ( len is either 1 or 2 ) to a single `u64` digit
            #[inline] fn u32_chunk_to_u64( chunk:&[u32] ) -> u64 {
               
                let mut digit = chunk[0] as u64;
                if let Some( &hi ) = chunk.get( 1 ) {
                    digit |= ( hi as u64 ) << 32;
                }
                digit
            }
            cfg_32_or_test!( 
                /// Combine four `u32`s into a single `u128`.
                #[inline] fn u32_to_u128( a: u32, b: u32, c: u32, d: u32 ) -> u128 {
                    u128::from( d ) | ( u128::from( c ) << 32 ) | ( u128::from( b ) << 64 ) | ( u128::from( a ) << 96 )
                }
             );

            cfg_32_or_test!( 
                /// Split a single `u128` into four `u32`.
                #[inline] fn u32_from_u128( n: u128 ) -> ( u32, u32, u32, u32 ) {
                    ( 
                        ( n >> 96 ) as u32,
                        ( n >> 64 ) as u32,
                        ( n >> 32 ) as u32,
                        n as u32,
                    )
                }
             );
        }

        #[cfg( target_pointer_width = "32" )]
        type UsizePromotion = u32;
        #[cfg( target_pointer_width = "64" )]
        type UsizePromotion = u64;

        #[cfg( target_pointer_width = "32" )]
        type IsizePromotion = i32;
        #[cfg( target_pointer_width = "64" )]
        type IsizePromotion = i64;

        #[derive( Debug, Clone, PartialEq, Eq )]
        pub struct ParseBigIntError
        {
            kind: BigIntErrorKind,
        }

        #[derive( Debug, Clone, PartialEq, Eq )]
        enum BigIntErrorKind
        {
            Empty,
            InvalidDigit,
        }

        impl ParseBigIntError
        {
            fn __description( &self ) -> &str {
                use ::num::big::BigIntErrorKind::*;
                match self.kind {
                    Empty => "cannot parse integer from empty string",
                    InvalidDigit => "invalid digit found in string",
                }
            }
            fn empty() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::Empty,
                }
            }
            fn invalid() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::InvalidDigit,
                }
            }
        }

        impl fmt::Display for ParseBigIntError
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {self.__description().fmt( f )
            }
        }
        
        impl ::error::Error for ParseBigIntError
        {
            fn description( &self ) -> &str {
                self.__description()
            }
        }
        /// The error type returned when a checked conversion regarding big integer fails.
        #[derive( Debug, Copy, Clone, PartialEq, Eq )]
        pub struct TryFromBigIntError<T>
        {
            original: T,
        }

        impl<T> TryFromBigIntError<T>
        {
            fn new( original: T ) -> Self {
                TryFromBigIntError { original }
            }
            fn __description( &self ) -> &str {
                "out of range conversion regarding big integer attempted"
            }
            /// Extract the original value, if available. The value will be available
            /// if the type before conversion was either [`BigInt`] or [`BigUint`].
            pub fn into_original( self ) -> T {
                self.original
            }
        }
        
        impl<T> ::error::Error for TryFromBigIntError<T> where
        T: fmt::Debug,
        {
            fn description( &self ) -> &str {
                self.__description()
            }
        }

        impl<T> fmt::Display for TryFromBigIntError<T>
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { self.__description().fmt( f ) }
        }

        pub use self::uint::BigUint;
        pub use self::uint::ToBigUint;
        pub use self::uint::U32Digits;
        pub use self::uint::U64Digits;

        pub use self::int::BigInt;
        pub use self::int::Sign;
        pub use self::int::ToBigInt;
        
        pub use self::rand::{ RandBigInt, RandomBits, UniformBigInt, UniformBigUint };

        mod digit 
        {
           
            cfg_digit!
            ( 
                pub type BigDigit = u32;
                pub type BigDigit = u64;
             );
            
            cfg_digit!
            ( 
                pub type DoubleBigDigit = u64;
                pub type DoubleBigDigit = u128;
             );

            pub const BITS: u8 = BigDigit::BITS as u8;
            pub const HALF_BITS: u8 = BITS / 2;
            pub const HALF: BigDigit = ( 1 << HALF_BITS ) - 1;
            pub const MAX: BigDigit = BigDigit::MAX;
            const LO_MASK: DoubleBigDigit = MAX as DoubleBigDigit;

            #[inline] fn get_hi( n: DoubleBigDigit ) -> BigDigit 
            {
                ( n >> BITS ) as BigDigit
            }
            #[inline] fn get_lo( n: DoubleBigDigit ) -> BigDigit 
            {
                ( n & LO_MASK ) as BigDigit
            }
            /// Split one [`DoubleBigDigit`] into two [`BigDigit`]s.
            #[inline] pub fn from_doublebigdigit( n: DoubleBigDigit ) -> ( BigDigit, BigDigit ) 
            {
                ( get_hi( n ), get_lo( n ) )
            }
            /// Join two [`BigDigit`]s into one [`DoubleBigDigit`].
            #[inline] pub fn to_doublebigdigit( hi: BigDigit, lo: BigDigit ) -> DoubleBigDigit 
            {
                DoubleBigDigit::from( lo ) | ( DoubleBigDigit::from( hi ) << BITS )
            }
        }
    }
    /*
    */
    pub mod rational
    {
        //! Rational numbers
        use ::
        {
            error::{ Error },
            fmt::{ Binary, Display, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex },
            hash::{Hash, Hasher},
            num::
            {
                big::{ BigInt, BigUint, Sign, ToBigInt },
                integers::{ Integer },
                traits::
                {
                    float::FloatCore,
                    Bounded, CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, ConstOne, ConstZero, FromPrimitive, Inv,
                    Num, NumCast, One, Pow, Signed, ToPrimitive, Unsigned, Zero
                },
            },
            ops::{Add, Div, Mul, Neg, Rem, ShlAssign, Sub},
            str::{ FromStr },
            *,
        };
        /*
        */
        pub mod pow
        {
            use ::
            {
                num::
                {
                    integers::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Pow },
                },
                *,
            };
            /*
            */
            macro_rules! pow_unsigned_impl {
                ( @ $exp:ty ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: $exp ) -> Ratio<T> {
                        Ratio::new_raw( self.numer.pow( expon ), self.denom.pow( expon ) )
                    }
                };
                ( $exp:ty ) => {
                    impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_unsigned_impl!( @ $exp );
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        pow_unsigned_impl!( @ $exp );
                    }
                    impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow( self, expon:&'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon )
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow( self, expon:&'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon )
                        }
                    }
                };
            }
            pow_unsigned_impl!( u8 );
            pow_unsigned_impl!( u16 );
            pow_unsigned_impl!( u32 );
            pow_unsigned_impl!( u64 );
            pow_unsigned_impl!( u128 );
            pow_unsigned_impl!( usize );

            macro_rules! pow_signed_impl {
                ( @ &'b BigInt, BigUint ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon:&'b BigInt ) -> Ratio<T> {
                        match expon.sign() {
                            Sign::NoSign => One::one(),
                            Sign::Minus => {
                                Pow::pow( self, expon.magnitude() ).into_recip()
                            }
                            Sign::Plus => Pow::pow( self, expon.magnitude() ),
                        }
                    }
                };
                ( @ $exp:ty, $unsigned:ty ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: $exp ) -> Ratio<T> {
                        match expon.cmp( &0 ) {
                            cmp::Ordering::Equal => One::one(),
                            cmp::Ordering::Less => {
                                let expon = expon.wrapping_abs() as $unsigned;
                                Pow::pow( self, expon ).into_recip()
                            }
                            cmp::Ordering::Greater => Pow::pow( self, expon as $unsigned ),
                        }
                    }
                };
                ( $exp:ty, $unsigned:ty ) => {
                    impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_signed_impl!( @ $exp, $unsigned );
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        pow_signed_impl!( @ $exp, $unsigned );
                    }
                    impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow( self, expon:&'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon )
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow( self, expon:&'b $exp ) -> Ratio<T> {
                            Pow::pow( self, *expon )
                        }
                    }
                };
            }
            pow_signed_impl!( i8, u8 );
            pow_signed_impl!( i16, u16 );
            pow_signed_impl!( i32, u32 );
            pow_signed_impl!( i64, u64 );
            pow_signed_impl!( i128, u128 );
            pow_signed_impl!( isize, usize );

            #[cfg( feature = "num-bigint" )]
            mod bigint {
                use super::*;
                use num_bigint::{BigInt, BigUint, Sign};

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigUint ) -> Ratio<T> {
                        Pow::pow( self, &expon )
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigUint> for &'a Ratio<T> where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigUint ) -> Ratio<T> {
                        Pow::pow( self, &expon )
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T> {
                    pow_unsigned_impl!( @ &'b BigUint );
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigUint> for &'a Ratio<T> where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_unsigned_impl!( @ &'b BigUint );
                }
                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigInt ) -> Ratio<T> {
                        Pow::pow( self, &expon )
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigInt> for &'a Ratio<T> where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigInt ) -> Ratio<T> {
                        Pow::pow( self, &expon )
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T> {
                    pow_signed_impl!( @ &'b BigInt, BigUint );
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigInt> for &'a Ratio<T> where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_signed_impl!( @ &'b BigInt, BigUint );
                }
            }

        }
        /// Represents the ratio between two numbers.
        #[derive( Copy, Clone, Debug )]
        #[allow( missing_docs )]
        pub struct Ratio<T> {
            /// Numerator.
            numer: T,
            /// Denominator.
            denom: T,
        }
        /// Alias for a `Ratio` of machine-sized integers.
        #[deprecated( 
            since = "0.4.0",
            note = "it's better to use a specific size, like `Rational32` or `Rational64`"
        )]
        pub type Rational = Ratio<isize>;
        /// Alias for a `Ratio` of 32-bit-sized integers.
        pub type Rational32 = Ratio<i32>;
        /// Alias for a `Ratio` of 64-bit-sized integers.
        pub type Rational64 = Ratio<i64>;
        /// Alias for arbitrary precision rationals.
        pub type BigRational = Ratio<BigInt>;
        /// These method are `const`.
        impl<T> Ratio<T>
        {
            /// Creates a `Ratio` without checking for `denom == 0` or reducing.
            #[inline] pub const fn new_raw( numer: T, denom: T ) -> Ratio<T> {
                Ratio { numer, denom }
            }
            /// Deconstructs a `Ratio` into its numerator and denominator.
            #[inline] pub fn into_raw( self ) -> ( T, T ) {
                ( self.numer, self.denom )
            }
            /// Gets an immutable reference to the numerator.
            #[inline] pub const fn numer( &self ) -> &T {
                &self.numer
            }
            /// Gets an immutable reference to the denominator.
            #[inline] pub const fn denom( &self ) -> &T {
                &self.denom
            }
        }

        impl<T: Clone + Integer> Ratio<T>
        {
            /// Creates a new `Ratio`.
            #[inline] pub fn new( numer: T, denom: T ) -> Ratio<T> {
                let mut ret = Ratio::new_raw( numer, denom );
                ret.reduce();
                ret
            }
            /// Creates a `Ratio` representing the integer `t`.
            #[inline] pub fn from_integer( t: T ) -> Ratio<T> {
                Ratio::new_raw( t, One::one() )
            }
            /// Converts to an integer, rounding towards zero.
            #[inline] pub fn to_integer( &self ) -> T {
                self.trunc().numer
            }
            /// Returns true if the rational number is an integer ( denominator is 1 ).
            #[inline] pub fn is_integer( &self ) -> bool {
                self.denom.is_one()
            }
            /// Puts self into lowest terms, with `denom` > 0.
            fn reduce( &mut self ) {
                if self.denom.is_zero() {
                    panic!( "denominator == 0" );
                }
                if self.numer.is_zero() {
                    self.denom.set_one();
                    return;
                }
                if self.numer == self.denom {
                    self.set_one();
                    return;
                }
                let g: T = self.numer.gcd( &self.denom );

               
               

                #[inline] fn replace_with<T: Zero>( x:&mut T, f: impl FnOnce( T ) -> T ) {
                    let y = ::mem::replace( x, T::zero() );
                    *x = f( y );
                }
               
                replace_with( &mut self.numer, |x| x / g.clone() );

               
                replace_with( &mut self.denom, |x| x / g );

               
                if self.denom < T::zero() {
                    replace_with( &mut self.numer, |x| T::zero() - x );
                    replace_with( &mut self.denom, |x| T::zero() - x );
                }
            }
            /// Returns a reduced copy of self.
            pub fn reduced( &self ) -> Ratio<T> {
                let mut ret = self.clone();
                ret.reduce();
                ret
            }
            /// Returns the reciprocal.
            #[inline] pub fn recip( &self ) -> Ratio<T> {
                self.clone().into_recip()
            }
            #[inline] fn into_recip( self ) -> Ratio<T> {
                match self.numer.cmp( &T::zero() ) {
                    cmp::Ordering::Equal => panic!( "division by zero" ),
                    cmp::Ordering::Greater => Ratio::new_raw( self.denom, self.numer ),
                    cmp::Ordering::Less => Ratio::new_raw( T::zero() - self.denom, T::zero() - self.numer ),
                }
            }
            /// Rounds towards minus infinity.
            #[inline] pub fn floor( &self ) -> Ratio<T> {
                if *self < Zero::zero() {
                    let one: T = One::one();
                    Ratio::from_integer( 
                        ( self.numer.clone() - self.denom.clone() + one ) / self.denom.clone(),
                    )
                } else {
                    Ratio::from_integer( self.numer.clone() / self.denom.clone() )
                }
            }
            /// Rounds towards plus infinity.
            #[inline] pub fn ceil( &self ) -> Ratio<T> {
                if *self < Zero::zero() {
                    Ratio::from_integer( self.numer.clone() / self.denom.clone() )
                } else {
                    let one: T = One::one();
                    Ratio::from_integer( 
                        ( self.numer.clone() + self.denom.clone() - one ) / self.denom.clone(),
                    )
                }
            }
            /// Rounds to the nearest integer. Rounds half-way cases away from zero.
            #[inline] pub fn round( &self ) -> Ratio<T> {
                let zero: Ratio<T> = Zero::zero();
                let one: T = One::one();
                let two: T = one.clone() + one.clone();

               
                let mut fractional = self.fract();
                if fractional < zero {
                    fractional = zero - fractional
                };

               
               
               
                let half_or_larger = if fractional.denom.is_even() {
                    fractional.numer >= fractional.denom / two
                } else {
                    fractional.numer >= ( fractional.denom / two ) + one
                };

                if half_or_larger {
                    let one: Ratio<T> = One::one();
                    if *self >= Zero::zero() {
                        self.trunc() + one
                    } else {
                        self.trunc() - one
                    }
                } else {
                    self.trunc()
                }
            }
            /// Rounds towards zero.
            #[inline] pub fn trunc( &self ) -> Ratio<T> {
                Ratio::from_integer( self.numer.clone() / self.denom.clone() )
            }
            /// Returns the fractional part of a number, with division rounded towards zero.
            #[inline] pub fn fract( &self ) -> Ratio<T> {
                Ratio::new_raw( self.numer.clone() % self.denom.clone(), self.denom.clone() )
            }
            /// Raises the `Ratio` to the power of an exponent.
            #[inline] pub fn pow( &self, expon: i32 ) -> Ratio<T> where
                for<'a> &'a T: Pow<u32, Output = T>,
            {
                Pow::pow( self, expon )
            }
        }
        
        impl Ratio<BigInt>
        {
            /// Converts a float into a rational number.
            pub fn from_float<T: FloatCore>( f: T ) -> Option<BigRational> {
                if !f.is_finite() {
                    return None;
                }
                let ( mantissa, exponent, sign ) = f.integer_decode();
                let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };
                if exponent < 0 {
                    let one: BigInt = One::one();
                    let denom: BigInt = one << ( ( -exponent ) as usize );
                    let numer: BigUint = FromPrimitive::from_u64( mantissa ).unwrap();
                    Some( Ratio::new( BigInt::from_biguint( bigint_sign, numer ), denom ) )
                } else {
                    let mut numer: BigUint = FromPrimitive::from_u64( mantissa ).unwrap();
                    numer <<= exponent as usize;
                    Some( Ratio::from_integer( BigInt::from_biguint( 
                        bigint_sign,
                        numer,
                    ) ) )
                }
            }
        }

        impl<T: Clone + Integer> Default for Ratio<T>
        {
            /// Returns zero
            fn default() -> Self {
                Ratio::zero()
            }
        }
        
        impl<T> From<T> for Ratio<T> where
            T: Clone + Integer,
        {
            fn from( x: T ) -> Ratio<T> {
                Ratio::from_integer( x )
            }
        }
        
        impl<T> From<( T, T )> for Ratio<T> where
            T: Clone + Integer,
        {
            fn from( pair: ( T, T ) ) -> Ratio<T> {
                Ratio::new( pair.0, pair.1 )
            }
        }
        
        impl<T: Clone + Integer> Ord for Ratio<T> 
        {
            #[inline] fn cmp( &self, other:&Self ) -> cmp::Ordering {
               
                if self.denom == other.denom {
                    let ord = self.numer.cmp( &other.numer );
                    return if self.denom < T::zero() {
                        ord.reverse()
                    } else {
                        ord
                    };
                }
               
                if self.numer == other.numer {
                    if self.numer.is_zero() {
                        return cmp::Ordering::Equal;
                    }
                    let ord = self.denom.cmp( &other.denom );
                    return if self.numer < T::zero() {
                        ord
                    } else {
                        ord.reverse()
                    };
                }
               
               
               

               
                let ( self_int, self_rem ) = self.numer.div_mod_floor( &self.denom );
                let ( other_int, other_rem ) = other.numer.div_mod_floor( &other.denom );
                match self_int.cmp( &other_int ) {
                    cmp::Ordering::Greater => cmp::Ordering::Greater,
                    cmp::Ordering::Less => cmp::Ordering::Less,
                    cmp::Ordering::Equal => {
                        match ( self_rem.is_zero(), other_rem.is_zero() ) {
                            ( true, true ) => cmp::Ordering::Equal,
                            ( true, false ) => cmp::Ordering::Less,
                            ( false, true ) => cmp::Ordering::Greater,
                            ( false, false ) => {
                               
                                let self_recip = Ratio::new_raw( self.denom.clone(), self_rem );
                                let other_recip = Ratio::new_raw( other.denom.clone(), other_rem );
                                self_recip.cmp( &other_recip ).reverse()
                            }
                        }
                    }
                }
            }
        }

        impl<T: Clone + Integer> PartialOrd for Ratio<T>
        {
            #[inline] fn partial_cmp( &self, other:&Self ) -> Option<cmp::Ordering> {
                Some( self.cmp( other ) )
            }
        }

        impl<T: Clone + Integer> PartialEq for Ratio<T> 
        {
            #[inline] fn eq( &self, other:&Self ) -> bool {
                self.cmp( other ) == cmp::Ordering::Equal
            }
        }

        impl<T: Clone + Integer> Eq for Ratio<T> {}       
       
        impl<T: Clone + Integer + Hash> Hash for Ratio<T> 
        {
            fn hash<H: Hasher>( &self, state:&mut H ) {
                recurse( &self.numer, &self.denom, state );

                fn recurse<T: Integer + Hash, H: Hasher>( numer:&T, denom:&T, state:&mut H ) {
                    if !denom.is_zero() {
                        let ( int, rem ) = numer.div_mod_floor( denom );
                        int.hash( state  );
                        recurse( denom, &rem, state );
                    } else {
                        denom.hash( state  );
                    }
                }
            }
        }

        mod iter_sum_product
        {
            use ::
            {
                iter::{Product, Sum},
                num::
                {
                    integers::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Zero },
                },
                *,
            };

            impl<T: Integer + Clone> Sum for Ratio<T>
            {
                fn sum<I>( iter: I ) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold( Self::zero(), |sum, num| sum + num )
                }
            }
            
            impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T>
            {
                fn sum<I>( iter: I ) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold( Self::zero(), |sum, num| sum + num )
                }
            }
            
            impl<T: Integer + Clone> Product for Ratio<T>
            {
                fn product<I>( iter: I ) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold( Self::one(), |prod, num| prod * num )
                }
            }
            
            impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T>
            {
                fn product<I>( iter: I ) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold( Self::one(), |prod, num| prod * num )
                }
            }
        }

        mod opassign
        {
            use ::
            {
                ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign},
                num::
                {
                    integers::Integer,
                    rational::{ Ratio },
                    traits::NumAssign,
                },
                *,
            };

            impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T>
            {
                fn add_assign( &mut self, other: Ratio<T> ) {
                    if self.denom == other.denom {
                        self.numer += other.numer
                    } else {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer + rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T>
            {
                fn div_assign( &mut self, other: Ratio<T> ) {
                    let gcd_ac = self.numer.gcd( &other.numer );
                    let gcd_bd = self.denom.gcd( &other.denom );
                    self.numer /= gcd_ac.clone();
                    self.numer *= other.denom / gcd_bd.clone();
                    self.denom /= gcd_bd;
                    self.denom *= other.numer / gcd_ac;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T>
            {
                fn mul_assign( &mut self, other: Ratio<T> ) {
                    let gcd_ad = self.numer.gcd( &other.denom );
                    let gcd_bc = self.denom.gcd( &other.numer );
                    self.numer /= gcd_ad.clone();
                    self.numer *= other.numer / gcd_bc.clone();
                    self.denom /= gcd_bc;
                    self.denom *= other.denom / gcd_ad;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T>
            {
                fn rem_assign( &mut self, other: Ratio<T> ) {
                    if self.denom == other.denom {
                        self.numer %= other.numer
                    } else {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer % rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T>
            {
                fn sub_assign( &mut self, other: Ratio<T> ) {
                    if self.denom == other.denom {
                        self.numer -= other.numer
                    } else {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer - rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T>
            {
                fn add_assign( &mut self, other: T ) {
                    self.numer += self.denom.clone() * other;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T>
            {
                fn div_assign( &mut self, other: T ) {
                    let gcd = self.numer.gcd( &other );
                    self.numer /= gcd.clone();
                    self.denom *= other / gcd;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T>
            {
                fn mul_assign( &mut self, other: T ) {
                    let gcd = self.denom.gcd( &other );
                    self.denom /= gcd.clone();
                    self.numer *= other / gcd;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T>
            {
                fn rem_assign( &mut self, other: T ) {
                    self.numer %= self.denom.clone() * other;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T>
            {
                fn sub_assign( &mut self, other: T ) {
                    self.numer -= self.denom.clone() * other;
                    self.reduce();
                }
            }
            macro_rules! forward_op_assign {
                ( impl $imp:ident, $method:ident ) => {
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T> {
                        #[inline]
                        fn $method( &mut self, other:&Ratio<T> ) {
                            self.$method( other.clone() )
                        }
                    }
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T> {
                        #[inline]
                        fn $method( &mut self, other:&T ) {
                            self.$method( other.clone() )
                        }
                    }
                };
            }
            forward_op_assign!( impl AddAssign, add_assign );
            forward_op_assign!( impl DivAssign, div_assign );
            forward_op_assign!( impl MulAssign, mul_assign );
            forward_op_assign!( impl RemAssign, rem_assign );
            forward_op_assign!( impl SubAssign, sub_assign );
        }

        forward_all_binop!( impl Mul, mul );
       
        impl<T> Mul<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul( self, rhs: Ratio<T> ) -> Ratio<T> {
                let gcd_ad = self.numer.gcd( &rhs.denom );
                let gcd_bc = self.denom.gcd( &rhs.numer );
                Ratio::new( 
                    self.numer / gcd_ad.clone() * ( rhs.numer / gcd_bc.clone() ),
                    self.denom / gcd_bc * ( rhs.denom / gcd_ad ),
                )
            }
        }
       
        impl<T> Mul<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul( self, rhs: T ) -> Ratio<T> {
                let gcd = self.denom.gcd( &rhs );
                Ratio::new( self.numer * ( rhs / gcd.clone() ), self.denom / gcd )
            }
        }

        forward_all_binop!( impl Div, div );
       
        impl<T> Div<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div( self, rhs: Ratio<T> ) -> Ratio<T> {
                let gcd_ac = self.numer.gcd( &rhs.numer );
                let gcd_bd = self.denom.gcd( &rhs.denom );
                Ratio::new( 
                    self.numer / gcd_ac.clone() * ( rhs.denom / gcd_bd.clone() ),
                    self.denom / gcd_bd * ( rhs.numer / gcd_ac ),
                )
            }
        }
       
        impl<T> Div<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div( self, rhs: T ) -> Ratio<T> {
                let gcd = self.numer.gcd( &rhs );
                Ratio::new( self.numer / gcd.clone(), self.denom * ( rhs / gcd ) )
            }
        }

        macro_rules! arith_impl
        {
            ( impl $imp:ident, $method:ident ) => {
                forward_all_binop!( impl $imp, $method );
               
                impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, rhs: Ratio<T> ) -> Ratio<T> {
                        if self.denom == rhs.denom {
                            return Ratio::new( self.numer.$method( rhs.numer ), rhs.denom );
                        }
                        let lcm = self.denom.lcm( &rhs.denom );
                        let lhs_numer = self.numer * ( lcm.clone() / self.denom );
                        let rhs_numer = rhs.numer * ( lcm.clone() / rhs.denom );
                        Ratio::new( lhs_numer.$method( rhs_numer ), lcm )
                    }
                }
               
                impl<T: Clone + Integer> $imp<T> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, rhs: T ) -> Ratio<T> {
                        Ratio::new( self.numer.$method( self.denom.clone() * rhs ), self.denom )
                    }
                }
            };
        }

        arith_impl!( impl Add, add );
        arith_impl!( impl Sub, sub );
        arith_impl!( impl Rem, rem );
       
        impl<T> CheckedMul for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_mul( &self, rhs:&Ratio<T> ) -> Option<Ratio<T>> {
                let gcd_ad = self.numer.gcd( &rhs.denom );
                let gcd_bc = self.denom.gcd( &rhs.numer );
                Some( Ratio::new( 
                    ( self.numer.clone() / gcd_ad.clone() )
                        .checked_mul( &( rhs.numer.clone() / gcd_bc.clone() ) )?,
                    ( self.denom.clone() / gcd_bc ).checked_mul( &( rhs.denom.clone() / gcd_ad ) )?,
                ) )
            }
        }

       
        impl<T> CheckedDiv for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_div( &self, rhs:&Ratio<T> ) -> Option<Ratio<T>> {
                if rhs.is_zero() {
                    return None;
                }
                let ( numer, denom ) = if self.denom == rhs.denom {
                    ( self.numer.clone(), rhs.numer.clone() )
                } else if self.numer == rhs.numer {
                    ( rhs.denom.clone(), self.denom.clone() )
                } else {
                    let gcd_ac = self.numer.gcd( &rhs.numer );
                    let gcd_bd = self.denom.gcd( &rhs.denom );
                    ( 
                        ( self.numer.clone() / gcd_ac.clone() )
                            .checked_mul( &( rhs.denom.clone() / gcd_bd.clone() ) )?,
                        ( self.denom.clone() / gcd_bd ).checked_mul( &( rhs.numer.clone() / gcd_ac ) )?,
                    )
                };
               
                if denom.is_zero() {
                    None
                } else if numer.is_zero() {
                    Some( Self::zero() )
                } else if numer == denom {
                    Some( Self::one() )
                } else {
                    let g = numer.gcd( &denom );
                    let numer = numer / g.clone();
                    let denom = denom / g;
                    let raw = if denom < T::zero() {
                       
                       
                        let n1 = T::zero() - T::one();
                        Ratio::new_raw( numer.checked_mul( &n1 )?, denom.checked_mul( &n1 )? )
                    } else {
                        Ratio::new_raw( numer, denom )
                    };
                    Some( raw )
                }
            }
        }
        
        macro_rules! checked_arith_impl
        {
            ( impl $imp:ident, $method:ident ) => {
                impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T> {
                    #[inline] fn $method( &self, rhs:&Ratio<T> ) -> Option<Ratio<T>> {
                        let gcd = self.denom.clone().gcd( &rhs.denom );
                        let lcm = ( self.denom.clone() / gcd.clone() ).checked_mul( &rhs.denom )?;
                        let lhs_numer = ( lcm.clone() / self.denom.clone() ).checked_mul( &self.numer )?;
                        let rhs_numer = ( lcm.clone() / rhs.denom.clone() ).checked_mul( &rhs.numer )?;
                        Some( Ratio::new( lhs_numer.$method( &rhs_numer )?, lcm ) )
                    }
                }
            };
        }
        
        checked_arith_impl!( impl CheckedAdd, checked_add );
        checked_arith_impl!( impl CheckedSub, checked_sub );

        impl<T> Neg for Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg( self ) -> Ratio<T> {
                Ratio::new_raw( -self.numer, self.denom )
            }
        }

        impl<'a, T> Neg for &'a Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg( self ) -> Ratio<T> {
                -self.clone()
            }
        }

        impl<T> Inv for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv( self ) -> Ratio<T> {
                self.recip()
            }
        }

        impl<'a, T> Inv for &'a Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv( self ) -> Ratio<T> {
                self.recip()
            }
        }
        
        impl<T: ConstZero + ConstOne> Ratio<T>
        {
            /// A constant `Ratio` 0/1.
            pub const ZERO: Self = Self::new_raw( T::ZERO, T::ONE );
        }

        impl<T: Clone + Integer + ConstZero + ConstOne> ConstZero for Ratio<T>
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Integer> Zero for Ratio<T> 
        {
            #[inline] fn zero() -> Ratio<T> {
                Ratio::new_raw( Zero::zero(), One::one() )
            }
            #[inline] fn is_zero( &self ) -> bool {
                self.numer.is_zero()
            }
            #[inline] fn set_zero( &mut self ) {
                self.numer.set_zero();
                self.denom.set_one();
            }
        }

        impl<T: ConstOne> Ratio<T> 
        {
            /// A constant `Ratio` 1/1.
            pub const ONE: Self = Self::new_raw( T::ONE, T::ONE );
        }

        impl<T: Clone + Integer + ConstOne> ConstOne for Ratio<T> 
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Integer> One for Ratio<T>
        {
            #[inline] fn one() -> Ratio<T> {
                Ratio::new_raw( One::one(), One::one() )
            }
            #[inline] fn is_one( &self ) -> bool {
                self.numer == self.denom
            }
            #[inline] fn set_one( &mut self ) {
                self.numer.set_one();
                self.denom.set_one();
            }
        }

        impl<T: Clone + Integer> Num for Ratio<T>
        {
            type FromStrRadixErr = ParseRatioError;
            /// Parses `numer/denom` where the numbers are in base `radix`.
            fn from_str_radix( s:&str, radix: u32 ) -> Result<Ratio<T>, ParseRatioError> {
                if s.splitn( 2, '/' ).count() == 2 {
                    let mut parts = s.splitn( 2, '/' ).map( |ss| {
                        T::from_str_radix( ss, radix ).map_err( |_| ParseRatioError {
                            kind: RatioErrorKind::ParseError,
                        } )
                    } );
                    let numer: T = parts.next().unwrap()?;
                    let denom: T = parts.next().unwrap()?;
                    if denom.is_zero() {
                        Err( ParseRatioError {
                            kind: RatioErrorKind::ZeroDenominator,
                        } )
                    } else {
                        Ok( Ratio::new( numer, denom ) )
                    }
                } else {
                    Err( ParseRatioError {
                        kind: RatioErrorKind::ParseError,
                    } )
                }
            }
        }

        impl<T: Clone + Integer + Signed> Signed for Ratio<T>
        {
            #[inline] fn abs( &self ) -> Ratio<T> {
                if self.is_negative() {
                    -self.clone()
                } else {
                    self.clone()
                }
            }
            #[inline] fn abs_sub( &self, other:&Ratio<T> ) -> Ratio<T> {
                if *self <= *other {
                    Zero::zero()
                } else {
                    self - other
                }
            }
            #[inline] fn signum( &self ) -> Ratio<T> {
                if self.is_positive() {
                    Self::one()
                } else if self.is_zero() {
                    Self::zero()
                } else {
                    -Self::one()
                }
            }
            #[inline] fn is_positive( &self ) -> bool {
                ( self.numer.is_positive() && self.denom.is_positive() )
                    || ( self.numer.is_negative() && self.denom.is_negative() )
            }
            #[inline] fn is_negative( &self ) -> bool {
                ( self.numer.is_negative() && self.denom.is_positive() )
                    || ( self.numer.is_positive() && self.denom.is_negative() )
            }
        }
        
        macro_rules! impl_formatting
        {
            ( $fmt_trait:ident, $prefix:expr, $fmt_str:expr, $fmt_alt:expr ) => {
                impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T> {
                            fn fmt( &self, f:&mut Formatter<'_> ) -> fmt::Result
                {        let pre_pad = if self.denom.is_one() {
                            format!( $fmt_str, self.numer )
                        } else {
                            if f.alternate() {
                                format!( concat!( $fmt_str, "/", $fmt_alt ), self.numer, self.denom )
                            } else {
                                format!( concat!( $fmt_str, "/", $fmt_str ), self.numer, self.denom )
                            }
                        };
                        if let Some( pre_pad ) = pre_pad.strip_prefix( "-" ) {
                            f.pad_integral( false, $prefix, pre_pad )
                        } else {
                            f.pad_integral( true, $prefix, &pre_pad )
                        }
                    }
                }
            };
        }

        impl_formatting!( Display, "", "{}", "{:#}" );
        impl_formatting!( Octal, "0o", "{:o}", "{:#o}" );
        impl_formatting!( Binary, "0b", "{:b}", "{:#b}" );
        impl_formatting!( LowerHex, "0x", "{:x}", "{:#x}" );
        impl_formatting!( UpperHex, "0x", "{:X}", "{:#X}" );
        impl_formatting!( LowerExp, "", "{:e}", "{:#e}" );
        impl_formatting!( UpperExp, "", "{:E}", "{:#E}" );

        impl<T: FromStr + Clone + Integer> FromStr for Ratio<T>
        {
            type Err = ParseRatioError;
            /// Parses `numer/denom` or just `numer`.
            fn from_str( s:&str ) -> Result<Ratio<T>, ParseRatioError> {
                let mut split = s.splitn( 2, '/' );

                let n = split.next().ok_or( ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                } )?;
                let num = FromStr::from_str( n ).map_err( |_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                } )?;

                let d = split.next().unwrap_or( "1" );
                let den = FromStr::from_str( d ).map_err( |_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                } )?;

                if Zero::is_zero( &den ) {
                    Err( ParseRatioError {
                        kind: RatioErrorKind::ZeroDenominator,
                    } )
                } else {
                    Ok( Ratio::new( num, den ) )
                }
            }
        }

        impl<T> From<Ratio<T>> for ( T, T )
        {
            fn from( val: Ratio<T> ) -> Self {
                ( val.numer, val.denom )
            }
        }
                
        #[derive( Copy, Clone, Debug, PartialEq )]
        pub struct ParseRatioError
        {
            kind: RatioErrorKind,
        }

        #[derive( Copy, Clone, Debug, PartialEq )]
        enum RatioErrorKind
        {
            ParseError,
            ZeroDenominator,
        }

        impl fmt::Display for ParseRatioError
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {self.kind.description().fmt( f )
            }
        }
        
        impl Error for ParseRatioError
        {
            #[allow( deprecated )]
            fn description( &self ) -> &str {
                self.kind.description()
            }
        }

        impl RatioErrorKind
        {
            fn description( &self ) -> &'static str {
                match *self {
                    RatioErrorKind::ParseError => "failed to parse integer",
                    RatioErrorKind::ZeroDenominator => "zero value denominator",
                }
            }
        }
        
        impl FromPrimitive for Ratio<BigInt>
        {
            fn from_i64( n: i64 ) -> Option<Self> {
                Some( Ratio::from_integer( n.into() ) )
            }
            fn from_i128( n: i128 ) -> Option<Self> {
                Some( Ratio::from_integer( n.into() ) )
            }
            fn from_u64( n: u64 ) -> Option<Self> {
                Some( Ratio::from_integer( n.into() ) )
            }
            fn from_u128( n: u128 ) -> Option<Self> {
                Some( Ratio::from_integer( n.into() ) )
            }
            fn from_f32( n: f32 ) -> Option<Self> {
                Ratio::from_float( n )
            }
            fn from_f64( n: f64 ) -> Option<Self> {
                Ratio::from_float( n )
            }
        }

        macro_rules! from_primitive_integer
        {
            ( $typ:ty, $approx:ident ) => {
                impl FromPrimitive for Ratio<$typ> {
                    fn from_i64( n: i64 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i64( n ).map( Ratio::from_integer )
                    }
                    fn from_i128( n: i128 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i128( n ).map( Ratio::from_integer )
                    }
                    fn from_u64( n: u64 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u64( n ).map( Ratio::from_integer )
                    }
                    fn from_u128( n: u128 ) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u128( n ).map( Ratio::from_integer )
                    }
                    fn from_f32( n: f32 ) -> Option<Self> {
                        $approx( n, 10e-20, 30 )
                    }
                    fn from_f64( n: f64 ) -> Option<Self> {
                        $approx( n, 10e-20, 30 )
                    }
                }
            };
        }

        from_primitive_integer!( i8, approximate_float );
        from_primitive_integer!( i16, approximate_float );
        from_primitive_integer!( i32, approximate_float );
        from_primitive_integer!( i64, approximate_float );
        from_primitive_integer!( i128, approximate_float );
        from_primitive_integer!( isize, approximate_float );

        from_primitive_integer!( u8, approximate_float_unsigned );
        from_primitive_integer!( u16, approximate_float_unsigned );
        from_primitive_integer!( u32, approximate_float_unsigned );
        from_primitive_integer!( u64, approximate_float_unsigned );
        from_primitive_integer!( u128, approximate_float_unsigned );
        from_primitive_integer!( usize, approximate_float_unsigned );

        impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float<F: FloatCore + NumCast>( f: F ) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from( 10e-20 ).expect( "Can't convert 10e-20" );
                approximate_float( f, epsilon, 30 )
            }
        }

        impl<T: Integer + Unsigned + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float_unsigned<F: FloatCore + NumCast>( f: F ) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from( 10e-20 ).expect( "Can't convert 10e-20" );
                approximate_float_unsigned( f, epsilon, 30 )
            }
        }

        fn approximate_float<T, F>( val: F, max_error: F, max_iterations: usize ) -> Option<Ratio<T>> where
            T: Integer + Signed + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            let negative = val.is_sign_negative();
            let abs_val = val.abs();

            let r = approximate_float_unsigned( abs_val, max_error, max_iterations )?;

           
            Some( if negative { r.neg() } else { r } )
        }
        
        fn approximate_float_unsigned<T, F>( val: F, max_error: F, max_iterations: usize ) -> Option<Ratio<T>> where
            T: Integer + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
           
           

            if val < F::zero() || val.is_nan() {
                return None;
            }
            let mut q = val;
            let mut n0 = T::zero();
            let mut d0 = T::one();
            let mut n1 = T::one();
            let mut d1 = T::zero();

            let t_max = T::max_value();
            let t_max_f = <F as NumCast>::from( t_max.clone() )?;

           
            let epsilon = t_max_f.recip();

           
            if q > t_max_f {
                return None;
            }
            for _ in 0..max_iterations {
                let a = match <T as NumCast>::from( q ) {
                    None => break,
                    Some( a ) => a,
                };

                let a_f = match <F as NumCast>::from( a.clone() ) {
                    None => break,
                    Some( a_f ) => a_f,
                };
                let f = q - a_f;

               
                if !a.is_zero()
                    && ( n1 > t_max.clone() / a.clone()
                        || d1 > t_max.clone() / a.clone()
                        || a.clone() * n1.clone() > t_max.clone() - n0.clone()
                        || a.clone() * d1.clone() > t_max.clone() - d0.clone() )
                {
                    break;
                }
                let n = a.clone() * n1.clone() + n0.clone();
                let d = a.clone() * d1.clone() + d0.clone();

                n0 = n1;
                d0 = d1;
                n1 = n.clone();
                d1 = d.clone();

               
               
                let g = Integer::gcd( &n1, &d1 );
                if !g.is_zero() {
                    n1 = n1 / g.clone();
                    d1 = d1 / g.clone();
                }
               
                let ( n_f, d_f ) = match ( <F as NumCast>::from( n ), <F as NumCast>::from( d ) ) {
                    ( Some( n_f ), Some( d_f ) ) => ( n_f, d_f ),
                    _ => break,
                };
                if ( n_f / d_f - val ).abs() < max_error {
                    break;
                }
               
                if f < epsilon {
                    break;
                }
                q = f.recip();
            }
           
            if d1.is_zero() {
                return None;
            }
            Some( Ratio::new( n1, d1 ) )
        }
        
        impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T>
        {
            fn to_i64( &self ) -> Option<i64> {
                self.to_integer().to_i64()
            }
            fn to_i128( &self ) -> Option<i128> {
                self.to_integer().to_i128()
            }
            fn to_u64( &self ) -> Option<u64> {
                self.to_integer().to_u64()
            }
            fn to_u128( &self ) -> Option<u128> {
                self.to_integer().to_u128()
            }
            fn to_f64( &self ) -> Option<f64> {
                let float = match ( self.numer.to_i64(), self.denom.to_i64() ) {
                    ( Some( numer ), Some( denom ) ) => ratio_to_f64( 
                        <i128 as From<_>>::from( numer ),
                        <i128 as From<_>>::from( denom ),
                    ),
                    _ => {
                        let numer: BigInt = self.numer.to_bigint()?;
                        let denom: BigInt = self.denom.to_bigint()?;
                        ratio_to_f64( numer, denom )
                    }
                };
                if float.is_nan() {
                    None
                } else {
                    Some( float )
                }
            }
        }

        trait Bits
        {
            fn bits( &self ) -> u64;
        }
        
        impl Bits for BigInt
        {
            fn bits( &self ) -> u64 {
                self.bits()
            }
        }

        impl Bits for i128
        {
            fn bits( &self ) -> u64 {
                ( 128 - self.wrapping_abs().leading_zeros() ).into()
            }
        }
        /// Converts a ratio of `T` to an f64.
        fn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>( 
            numer: T,
            denom: T,
        ) -> f64 {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, MIN_EXP, RADIX};

            assert_eq!( 
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
             );

           
            const MAX_EXACT_INT: i64 = 1i64 << MANTISSA_DIGITS;
            const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;

            let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();
            if !flo_sign.is_normal() {
                return flo_sign;
            }
           
           
           
            if let ( Some( n ), Some( d ) ) = ( numer.to_i64(), denom.to_i64() ) {
                let exact = MIN_EXACT_INT..=MAX_EXACT_INT;
                if exact.contains( &n ) && exact.contains( &d ) {
                    return n.to_f64().unwrap() / d.to_f64().unwrap();
                }
            }
           
           
           
           
            let mut numer = numer.abs();
            let mut denom = denom.abs();
            let ( is_diff_positive, absolute_diff ) = match numer.bits().checked_sub( denom.bits() ) {
                Some( diff ) => ( true, diff ),
                None => ( false, denom.bits() - numer.bits() ),
            };

           
           
            if is_diff_positive && absolute_diff > MAX_EXP as u64 {
                return INFINITY * flo_sign;
            }
            if !is_diff_positive && absolute_diff > -MIN_EXP as u64 + MANTISSA_DIGITS as u64 + 1 {
                return 0.0 * flo_sign;
            }
            let diff = if is_diff_positive {
                absolute_diff.to_isize().unwrap()
            } else {
                -absolute_diff.to_isize().unwrap()
            };

           
           
            let shift: isize = diff.max( MIN_EXP as isize ) - MANTISSA_DIGITS as isize - 2;
            if shift >= 0 {
                denom <<= shift as usize
            } else {
                numer <<= -shift as usize
            };

            let ( quotient, remainder ) = numer.div_rem( &denom );

           
            let mut quotient = quotient.to_u64().unwrap();
            let n_rounding_bits = {
                let quotient_bits = 64 - quotient.leading_zeros() as isize;
                let subnormal_bits = MIN_EXP as isize - shift;
                quotient_bits.max( subnormal_bits ) - MANTISSA_DIGITS as isize
            } as usize;
            debug_assert!( n_rounding_bits == 2 || n_rounding_bits == 3 );
            let rounding_bit_mask = ( 1u64 << n_rounding_bits ) - 1;

           
           
            let ls_bit = quotient & ( 1u64 << n_rounding_bits ) != 0;
            let ms_rounding_bit = quotient & ( 1u64 << ( n_rounding_bits - 1 ) ) != 0;
            let ls_rounding_bits = quotient & ( rounding_bit_mask >> 1 ) != 0;
            if ms_rounding_bit && ( ls_bit || ls_rounding_bits || !remainder.is_zero() ) {
                quotient += 1u64 << n_rounding_bits;
            }
            quotient &= !rounding_bit_mask;

           
           
            let q_float = quotient as f64 * flo_sign;
            ldexp( q_float, shift as i32 )
        }
        /// Multiply `x` by 2 to the power of `exp`. Returns an accurate result even if `2^exp` is not representable.
        fn ldexp( x: f64, exp: i32 ) -> f64
        {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, RADIX};

            assert_eq!( 
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
             );

            const EXPONENT_MASK: u64 = 0x7ff << 52;
            const MAX_UNSIGNED_EXPONENT: i32 = 0x7fe;
            const MIN_SUBNORMAL_POWER: i32 = MANTISSA_DIGITS as i32;

            if x.is_zero() || x.is_infinite() || x.is_nan() {
                return x;
            }
           
            if exp > 3 * MAX_EXP {
                return INFINITY * x.signum();
            } else if exp < -3 * MAX_EXP {
                return 0.0 * x.signum();
            }
           
            let ( bits, curr_exp ) = if !x.is_normal() {
               
               
                let normal_x = x * 2f64.powi( MIN_SUBNORMAL_POWER );
                let bits = normal_x.to_bits();
               
                ( 
                    bits,
                    ( ( bits & EXPONENT_MASK ) >> 52 ) as i32 - MIN_SUBNORMAL_POWER,
                )
            } else {
                let bits = x.to_bits();
                let curr_exp = ( bits & EXPONENT_MASK ) >> 52;
               
                ( bits, curr_exp as i32 )
            };

           
           
            let new_exp = curr_exp + exp;

            if new_exp > MAX_UNSIGNED_EXPONENT {
                INFINITY * x.signum()
            } else if new_exp > 0 {
               
                let new_bits = ( bits & !EXPONENT_MASK ) | ( ( new_exp as u64 ) << 52 );
                f64::from_bits( new_bits )
            } else if new_exp >= -( MANTISSA_DIGITS as i32 ) {
               
               
               
               
                let new_exp = new_exp + MIN_SUBNORMAL_POWER;
                debug_assert!( new_exp >= 0 );
                let new_bits = ( bits & !EXPONENT_MASK ) | ( ( new_exp as u64 ) << 52 );
                f64::from_bits( new_bits ) * 2f64.powi( -MIN_SUBNORMAL_POWER )
            } else {
               
                return 0.0 * x.signum();
            }
        }
        
        pub fn frac_from_whole_and_dec( whole: BigInt, decimal: BigInt, dec_len: usize ) -> BigRational
        {
            let denom = ::num::traits::pow( BigInt::from_u8( 10 ).unwrap(), dec_len );
            BigRational::new( whole, 1.into() ) + BigRational::new( decimal, denom )
        }
    }
}

pub mod map
{
    /*!
    Mapping Functionality*/
    use ::
    {
        sync::{ LockResult, PoisonError, TryLockError, TryLockResult },
        system::
        {
            common::
            {
                terminal::{ Terminal, TerminalReadGuard },
            },
        },
        *,
    };
    /*
    use crate::screen::{Screen, ScreenReadGuard};
    use crate::terminal::{Terminal, TerminalReadGuard};
    use crate::util::char_width;
    */
    pub fn map_lock_result<F, T, U>( res: LockResult<T>, f: F ) -> LockResult<U> where 
    F:FnOnce( T ) -> U
    {
        match res 
        {
            Ok( t ) => Ok( f( t ) ),
            Err( e ) => Err( PoisonError::new( f( e.into_inner() ) ) ),
        }
    }

    pub fn map_try_lock_result<F, T, U>( res: TryLockResult<T>, f: F ) -> TryLockResult<U> where
    F: FnOnce( T ) -> U
    {
        match res
        {
            Ok( t ) => Ok( f( t ) ),
            Err( TryLockError::Poisoned( p ) ) => Err( TryLockError::Poisoned( PoisonError::new( f( p.into_inner() ) ) ) ),
            Err( TryLockError::WouldBlock ) => Err( TryLockError::WouldBlock ),
        }
    }

    pub fn map2_lock_result<F, T, U, R>( res: LockResult<T>, res2: LockResult<U>, f: F ) -> LockResult<R> where
    F: FnOnce( T, U ) -> R
    {
        match ( res, res2 )
        {
            ( Ok( a ), Ok( b ) ) => Ok( f( a, b ) ),
            ( Ok( a ), Err( b ) ) => Err( PoisonError::new( f( a, b.into_inner() ) ) ),
            ( Err( a ), Ok( b ) ) => Err( PoisonError::new( f( a.into_inner(), b ) ) ),
            ( Err( a ), Err( b ) ) => Err( PoisonError::new( f( a.into_inner(), b.into_inner() ) ) ),
        }
    }

    pub fn map2_try_lock_result<F,T,U,R>( res:TryLockResult<T>, res2:TryLockResult<U>, f:F ) -> TryLockResult<R> where
    F: FnOnce( T, U ) -> R
    {
        match ( res, res2 )
        {
            ( Ok( a ), Ok( b ) ) => Ok( f( a, b ) ),
            
            ( Err( TryLockError::WouldBlock ), _ ) => Err( TryLockError::WouldBlock ),
            
            ( _, Err( TryLockError::WouldBlock ) ) => Err( TryLockError::WouldBlock ),
            
            ( Ok( a ), Err( TryLockError::Poisoned( b ) ) ) => 
            Err( TryLockError::Poisoned( PoisonError::new( f( a, b.into_inner() ) ) ) ),
            
            ( Err( TryLockError::Poisoned( a ) ), Ok( b ) ) => 
            Err( TryLockError::Poisoned( PoisonError::new( f( a.into_inner(), b ) ) ) ),
            
            ( Err( TryLockError::Poisoned( a ) ), Err( TryLockError::Poisoned( b ) ) ) => 
            Err( TryLockError::Poisoned( PoisonError::new( f( a.into_inner(), b.into_inner() ) ) ) ),
        }
    }
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod now
{
    /*!
    */
    use ::
    {
        collections::{ HashMap },
        io::{ self, Read, Write },
        shell::{ self, Shell },
        types::{ * },
        *,
    };
    /*
    */
    /// Entry point for non-ttys ( e.g. Cmd-N on MacVim)
    pub fn run_procs_for_non_tty( sh: &mut Shell)
    {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();

        match handle.read_to_string( &mut buffer )
        {
            Ok(_ ) =>
            {
                /*log!( "run non tty command: {}", &buffer ); */
                run_command_line( sh, &buffer, false, false );
            }
            
            Err( e ) => { println!( ":: stdin.read_to_string() failed: {:?}", e ); }
        }
    }

    pub fn run_command_line( sh: &mut Shell, line: &str, tty: bool, capture: bool ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();

        for token in parsers::parser_line::line_to_cmds(line )
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }

            if sep == "&&" && status != 0 { break; }

            if sep == "||" && status == 0 { break; }

            let cmd = token.clone();
            let cr = run_proc( sh, &cmd, tty, capture );
            status = cr.status;
            sh.previous_status = status;
            cr_list.push( Cr );
        }

        cr_list
    }

    fn line_to_tokens( sh: &mut Shell, line: &str ) -> ( Tokens, HashMap<String, String> )
    {
        let linfo = parsers::parser_line::parse_line(line );
        let mut tokens = linfo.tokens;
        shell::do_expansion( sh, &mut tokens );
        let envs = drain_env_tokens( &mut tokens );
        ( tokens, envs )
    }

    fn set_shell_vars( sh: &mut Shell, envs: &HashMap<String, String>)
    {
        for ( name, value ) in envs.iter()
        {
            sh.set_env( name, value );
        }
    }
    /// Run simple command or pipeline without using `&&`, `||`, `;`.
    fn run_proc( sh: &mut Shell, line: &str, tty: bool, capture:bool ) -> CommandResult
    {
        let log_cmd = !sh.cmd.starts_with(' ');
        match CommandLine::from_line(line, sh )
        {
            Ok( cl ) =>
            {
                if cl.is_empty()
                {
                    if !cl.envs.is_empty() { set_shell_vars( sh, &cl.envs ); }

                    return CommandResult::new();
                }

                let ( term_given, cr ) = run_pipeline( sh, &cl, tty, capture, log_cmd );
                
                if term_given
                {
                    unsafe
                    {
                        let gid = system::api::getpgid( 0 );
                        ::system::terminal::give_to( gid );
                    }
                }

                cr
            }

            Err( e ) =>
            {
                println_stderr!( ":: {}", e );
                CommandResult::from_status(0, 1)
            }
        }
    }

    fn run_with_shell( sh: &mut Shell, line:&str ) -> CommandResult
    {
        let ( tokens, envs ) = line_to_tokens( sh, line );

        if tokens.is_empty()
        {
            set_shell_vars( sh, &envs );
            return CommandResult::new();
        }

        match CommandLine::from_line(line, sh )
        {
            Ok( c ) =>
            {
                let ( term_given, cr ) = run_pipeline( sh, &c, false, true, false );
                if term_given
                {
                    unsafe
                    {
                        let gid = system::api::getpgid( 0 );
                        system::terminal::give_to( gid );
                    }
                }

                cr
            }

            Err( e ) =>
            {
                println_stderr!( ":: {}", e );
                CommandResult::from_status(0, 1)
            }
        }
    }

    pub fn run(line:&str ) -> CommandResult
    {
        let mut sh = Shell::new();
        run_with_shell( &mut sh, line )
    }

    fn try_run_builtin_in_subprocess
    (
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<i32>
    {
        if let Some( cr ) = try_run_builtin( sh, cl, idx_cmd, capture ) { return Some( cr.status ); }

        None
    }

    fn try_run_builtin
    (
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<CommandResult>
    {
        let capture = capture && idx_cmd + 1 == cl.commands.len();

        if idx_cmd >= cl.commands.len()
        {
            println_stderr!( "unexpected error in try_run_builtin" );
            return None;
        }

        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();

        if cname == "alias"
        {
            let cr = ::api::run_alias( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "bg"
        {
            let cr = ::api::run_bg( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "cd"
        {
            let cr = ::api::run_cd( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "cinfo"
        {
            let cr = ::api::run_info( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "exec"
        {
            let cr = ::api::run_exec( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "exit"
        {
            let cr = ::api::run_exit( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "export"
        {
            let cr = ::api::run_export( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "fg"
        {
            let cr = ::api::run_fg( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "history"
        {
            let cr = ::api::run_history( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "jobs"
        {
            let cr = ::api::run_jobs( sh, cl, cmd, capture );
            return Some( cr );
        
        }
        
        else if cname == "minfd"
        {
            let cr = ::api::run_minfd( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "read"
        {
            let cr = ::api::run_read( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "set"
        {
            let cr = ::api::run_set( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "source"
        {
            let cr = ::api::run_source( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "ulimit"
        {
            let cr = ::api::run_ulimit( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "unalias"
        {
            let cr = ::api::run_unalias( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "unset"
        {
            let cr = ::api::run_unset( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "unpath"
        {
            let cr = ::api::run_unpath( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "vox"
        {
            let cr = ::api::run_vox( sh, cl, cmd, capture );
            return Some( cr );
        }

        None
    }
    /// Run a pipeline ( e.g. `echo hi | wc -l`).
    pub fn run_pipeline
    (
        sh: &mut shell::Shell,
        cl: &CommandLine,
        tty: bool,
        capture: bool,
        log_cmd: bool,
    ) -> ( bool, CommandResult )
    {
        let mut term_given = false;
        if cl.background && capture
        {
            println_stderr!( ":: cannot capture output of background cmd" );
            return ( term_given, CommandResult::error() );
        }
        /*
        if let Some( cr ) = try_run_calculator( &cl.line, capture ) {
            return ( term_given, cr );
        } */
        
        if let Some( cr ) = try_run_func( sh, cl, capture, log_cmd ) {
            return ( term_given, cr );
        }
        /*
        if log_cmd {
            log!( "run: {}", cl.line );
        } */

        let length = cl.commands.len();
        if length == 0 {
            println!( ":: invalid command: cmds with empty length" );
            return ( false, CommandResult::error() );
        }

        let mut pipes = Vec::new();
        let mut errored_pipes = false;
        for _ in 0..length - 1 {
            match pipe() {
                Ok( fds ) => pipes.push( fds ),
                Err( e ) => {
                    errored_pipes = true;
                    println_stderr!( ":: pipeline1: {}", e );
                    break;
                }
            }
        }

        if errored_pipes
        {
            for fds in pipes
            {
                ::process::close( fds.0);
                ::process::close( fds.1);
            }
            return ( false, CommandResult::error() );
        }

        if pipes.len() + 1 != length {
            println!( ":: invalid command: unmatched pipes count" );
            return ( false, CommandResult::error() );
        }

        let mut pgid: i32 = 0;
        let mut fg_pids: Vec<i32> = Vec::new();

        let isatty = if tty { unsafe { is::tty(1) == 1 } }
        else { false };

        let options = CommandOptions
        {
            isatty,
            capture_output: capture,
            background: cl.background,
            envs: cl.envs.clone(),
        };

        let mut fds_capture_stdout = None;
        let mut fds_capture_stderr = None;
        if capture
        {
            match ::process::pipe()
            {
                Ok( fds ) => fds_capture_stdout = Some( fds ),
                Err( e ) => {
                    println_stderr!( ":: pipeline2: {}", e );
                    return ( false, CommandResult::error() );
                }
            }

            match pipe()
            {
                Ok( fds ) => fds_capture_stderr = Some( fds ),
                Err( e ) =>
                {
                    if let Some( fds ) = fds_capture_stdout
                    {
                        process::close( fds.0);
                        process::close( fds.1);
                    }

                    println_stderr!( ":: pipeline3: {}", e );
                    return ( false, CommandResult::error() );
                }
            }
        }

        let mut cmd_result = CommandResult::new();
        for i in 0..length
        {
            let child_id: i32 = run_single_program(
                sh,
                cl,
                i,
                &options,
                &mut pgid,
                &mut term_given,
                &mut cmd_result,
                &pipes,
                &fds_capture_stdout,
                &fds_capture_stderr,
            );

            if child_id > 0 && !cl.background {
                fg_pids.push( Child_id );
            }
        }

        if cl.is_single_and_builtin() {
            return ( false, cmd_result );
        }

        if cl.background {
            if let Some(job) = sh.get_job_by_gid( pgid ) {
                println_stderr!( "[{}] {}", job.id, job.gid );
            }
        }

        if !fg_pids.is_empty()
        {
            let _cr = process::wait_fg_job( sh, pgid, &fg_pids );
            if !capture
            {
                cmd_result = _cr;
            }
        }
        
        ( term_given, cmd_result )
    }
    /// Run a single command.
    fn run_single_program
    (
        sh: &mut shell::Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        options: &CommandOptions,
        pgid: &mut i32,
        term_given: &mut bool,
        cmd_result: &mut CommandResult,
        pipes:&[(RawFd, RawFd )],
        fds_capture_stdout: &Option<(RawFd, RawFd )>,
        fds_capture_stderr: &Option<(RawFd, RawFd )>,
    ) -> i32
    {
        let capture = options.capture_output;
        if cl.is_single_and_builtin()
        {
            if let Some( cr ) = try_run_builtin( sh, cl, idx_cmd, capture )
            {
                *cmd_result = cr;
                return unsafe { getpid() };
            }
            /*
            println_stderr!( ":: error when run singler builtin" );
            log!( "error when run singler builtin: {:?}", cl); */
            return 1;
        }

        let pipes_count = pipes.len();
        let mut fds_stdin = None;
        let cmd = cl.commands.get(idx_cmd ).unwrap();

        if cmd.has_here_string()
        {
            match pipe()
            {
                Ok( fds ) => fds_stdin = Some( fds ),
                Err( e ) =>
                {
                    println_stderr!( ":: pipeline4: {}", e );
                    return 1;
                }
            }
        }

        match process::fork()
        {
            Ok(ForkResult::Child ) =>
            {
                unsafe
                {
                    signal( SIGTSTP, SIG_DFL);
                    signal( SIGQUIT, SIG_DFL);
                }
                
                if idx_cmd > 0
                {
                    for i in 0..idx_cmd - 1
                    {
                        let fds = pipes[i];
                        process::close( fds.0);
                        process::close( fds.1);
                    }
                }
                
                for i in idx_cmd + 1..pipes_count
                {
                    let fds = pipes[i];
                    process::close( fds.0);
                    process::close( fds.1);
                }
                
                if idx_cmd < pipes_count
                {
                    if let Some( fds ) = fds_capture_stdout
                    {
                        process::close( fds.0);
                        process::close( fds.1);
                    }

                    if let Some( fds ) = fds_capture_stderr
                    {
                        process::close( fds.0);
                        process::close( fds.1);
                    }
                }

                if idx_cmd == 0 
                {
                    unsafe {
                        let pid = getpid();
                        setpgid(0, pid );
                    }
                }
                
                else
                {
                    unsafe { setpgid(0, *pgid ); }
                }
                
                if idx_cmd > 0
                {
                    let fds_prev = pipes[idx_cmd - 1];
                    process::dup2( fds_prev.0, 0);
                    process::close( fds_prev.0);
                    process::close( fds_prev.1);
                }

                if idx_cmd < pipes_count
                {
                    let fds = pipes[idx_cmd];
                    process::dup2( fds.1, 1);
                    process::close( fds.1);
                    process::close( fds.0);
                }

                if cmd.has_redirect_from()
                {
                    if let Some( redirect_from) = &cmd.redirect_from
                    {
                        let fd = getg::fd_from_file( &redirect_from.clone().1);
                        if fd == -1 {
                            process::exit(1);
                        }

                        process::dup2( fd, 0);
                        process::close( fd );
                    }
                }

                if cmd.has_here_string()
                {
                    if let Some( fds ) = fds_stdin
                    {
                        process::close( fds.1);
                        process::dup2( fds.0, 0);
                        process::close( fds.0);
                    }
                }

                let mut stdout_redirected = false;
                let mut stderr_redirected = false;
                
                for item in &cmd.redirects_to
                {
                    let from_ = &item.0;
                    let op_ = &item.1;
                    let to_ = &item.2;
                    if to_ == "&1" && from_ == "2"
                    {
                        if idx_cmd < pipes_count
                        {
                            process::dup2(1, 2);
                        }
                        
                        else if !options.capture_output
                        {
                            let fd = process::dup(1);
                            if fd == -1 {
                                println_stderr!( ":: dup error" );
                                process::exit(1);
                            }
                            process::dup2( fd, 2);
                        }

                        else { }
                    }
                    
                    else if to_ == "&2" && from_ == "1"
                    {
                        if idx_cmd < pipes_count || !options.capture_output {
                            let fd = process::dup(2);
                            if fd == -1 {
                                println_stderr!( ":: dup error" );
                                process::exit(1);
                            }
                            process::dup2( fd, 1);
                        }
                        
                        else { }
                    }
                    
                    else
                    {
                        let append = op_ == ">>";
                        match fs::create_raw_fd_from_file( to_, append )
                        {
                            Ok( fd ) =>
                            {
                                if fd == -1
                                {
                                    println_stderr!( ":: fork: fd error" );
                                    process::exit(1);
                                }

                                if from_ == "1"
                                {
                                    process::dup2( fd, 1);
                                    stdout_redirected = true;
                                }
                                
                                else
                                {
                                    process::dup2( fd, 2);
                                    stderr_redirected = true;
                                }
                            }

                            Err( e ) =>
                            {
                                println_stderr!( ":: fork: {}", e );
                                process::exit(1);
                            }
                        }
                    }
                }
                
                if idx_cmd == pipes_count && options.capture_output {
                    if !stdout_redirected {
                        if let Some( fds ) = fds_capture_stdout {
                            libs::close( fds.0);
                            libs::dup2( fds.1, 1);
                            libs::close( fds.1);
                        }
                    }
                    if !stderr_redirected {
                        if let Some( fds ) = fds_capture_stderr {
                            libs::close( fds.0);
                            libs::dup2( fds.1, 2);
                            libs::close( fds.1);
                        }
                    }
                }

                if cmd.is_builtin() {
                    if let Some( status ) = try_run_builtin_in_subprocess( sh, cl, idx_cmd, capture ) {
                        process::exit( status );
                    }
                }

                // our strings do not have '\x00' bytes in them,
                // we can use CString::new().expect() safely.
                let mut c_envs: Vec<_> = env::vars()
                    .map(|(k, v)| {
                        CString::new( format!( "{}={}", k, v).as_str() ).expect( "CString error" )
                    })
                    .collect();
                for (key, value ) in cl.envs.iter() {
                    c_envs.push(
                        CString::new( format!( "{}={}", key, value ).as_str() ).expect( "CString error" ),
                    );
                }

                let program = &cmd.tokens[0].1;
                let path = if program.contains('/') {
                    program.clone()
                } else {
                    libs::path::find_file_in_path( program, true )
                };
                if path.is_empty() {
                    println_stderr!( ":: {}: command not found", program);
                    process::exit(127);
                }

                let c_program = CString::new( path.as_str() ).expect( "CString::new failed" );
                let c_args: Vec<_> = cmd
                    .tokens
                    .iter()
                    .map(|x| CString::new(x.1.as_str() ).expect( "CString error" ) )
                    .collect();

                let c_args: Vec<&CStr> = c_args.iter().map(|x| x.as_c_str() ).collect();
                let c_envs: Vec<&CStr> = c_envs.iter().map(|x| x.as_c_str() ).collect();
                match execve( &c_program, &c_args, &c_envs ) {
                    Ok(_ ) => {}
                    Err( e ) => match e {
                        nix::Error::ENOEXEC => {
                            println_stderr!( ":: {}: exec format error (ENOEXEC)", program);
                        }
                        nix::Error::ENOENT => {
                            println_stderr!( ":: {}: file does not exist", program);
                        }
                        nix::Error::EACCES => {
                            println_stderr!( ":: {}: Permission denied", program);
                        }
                        _ => {
                            println_stderr!( ":: {}: {:?}", program, e );
                        }
                    },
                }

                process::exit(1);
            }
            Ok(ForkResult::Parent { child, .. }) => {
                let pid: i32 = child.into();
                if idx_cmd == 0 {
                    *pgid = pid;
                    unsafe {
                        // we need to wait pgid of child set to itself,
                        // before give terminal to it ( for macos ).
                        // 1. this loop causes `bash`, `htop` etc to go `T` status
                        //    immediate after start on linux (ubuntu).
                        // 2. but on mac, we need this loop, otherwise commands
                        //    like `vim` will go to `T` status after start.
                        if cfg!( target_os = "macos" ) {
                            loop {
                                let _pgid = libc::getpgid( pid );
                                if _pgid == pid {
                                    break;
                                }
                            }
                        }

                        if sh.has_terminal && options.isatty && !cl.background {
                            *term_given = shell::give_terminal_to( pid );
                        }
                    }
                }

                if options.isatty && !options.capture_output {
                    let _cmd = parsers::parser_line::tokens_to_line( &cmd.tokens );
                    sh.insert_job(*pgid, pid, &_cmd, "Running", cl.background );
                }

                if let Some( redirect_from) = &cmd.redirect_from {
                    if redirect_from.0 == "<<<" {
                        if let Some( fds ) = fds_stdin {
                            unsafe {
                                libs::close( fds.0);

                                let mut f = File::from_raw_fd( fds.1);
                                match f.write_all( redirect_from.1.clone().as_bytes() ) {
                                    Ok(_ ) => {}
                                    Err( e ) => println_stderr!( ":: write_all: {}", e ),
                                }
                                match f.write_all( b"\n" ) {
                                    Ok(_ ) => {}
                                    Err( e ) => println_stderr!( ":: write_all: {}", e ),
                                }
                            }
                        }
                    }
                }

                // (in parent ) close unused pipe ends
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::close( fds.1);
                }
                if idx_cmd > 0 {
                    // close pipe end only after dupped in the child
                    let fds = pipes[idx_cmd - 1];
                    libs::close( fds.0);
                }

                if idx_cmd == pipes_count && options.capture_output {
                    let mut s_out = String::new();
                    let mut s_err = String::new();

                    unsafe {
                        if let Some( fds ) = fds_capture_stdout {
                            libs::close( fds.1);

                            let mut f = File::from_raw_fd( fds.0);
                            match f.read_to_string( &mut s_out ) {
                                Ok(_ ) => {}
                                Err( e ) => println_stderr!( ":: readstr: {}", e ),
                            }
                        }
                        if let Some( fds ) = fds_capture_stderr {
                            libs::close( fds.1);
                            let mut f_err = File::from_raw_fd( fds.0);
                            match f_err.read_to_string( &mut s_err ) {
                                Ok(_ ) => {}
                                Err( e ) => println_stderr!( ":: readstr: {}", e ),
                            }
                        }
                    }

                    *cmd_result = CommandResult {
                        gid: *pgid,
                        status: 0,
                        stdout: s_out.clone(),
                        stderr: s_err.clone(),
                    };
                }

                pid
            }

            Err(_ ) => {
                println_stderr!( "Fork failed" );
                *cmd_result = CommandResult::error();
                0
            }
        }
    }

    fn try_run_func
    (
        sh: &mut Shell,
        cl: &CommandLine,
        capture: bool,
        log_cmd: bool,
    ) -> Option<CommandResult>
    {
        if cl.is_empty() { return None; }

        let command = &cl.commands[0];

        if let Some( func_body) = sh.get_func( &command.tokens[0].1)
        {
            let mut args = vec!["cicada".to_string()];
            
            for token in &command.tokens
            {
                args.push( token.1.to_string() );
            }
            /*
            if log_cmd {
                log!( "run func: {:?}", &args );
            }*/

            let cr_list = scripts::run_lines( sh, &func_body, &args, capture );
            let mut stdout = String::new();
            let mut stderr = String::new();
            
            for cr in cr_list
            {
                stdout.push_str( cr.stdout.trim() );
                stdout.push(' ');
                stderr.push_str( cr.stderr.trim() );
                stderr.push(' ');
            }

            let mut cr = CommandResult::new();
            cr.stdout = stdout;
            cr.stderr = stderr;
            return Some( cr );
        }

        None
    }
}

pub mod objects
{
    /*!
    Object | A hashmap of keys to values, where values can be any type, including other objects. */
    use ::
    {
        arrays::{ Arr },
        collections::{ hash_map::{Iter, Keys, Values}, HashMap },
        error::{ OverError },
        fmt::{ Format },
        num::
        {
            big::{ BigInt },
            rational::{ BigRational },
            traits::{ Zero },
        },
        result::{ OverResult },
        str::{ FromStr },
        sync::{ Arc, atomic::{ AtomicUsize, Ordering } },
        tuples::{ Tup },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    */
    lazy_static! 
    {
        static ref CUR_ID: AtomicUsize = AtomicUsize::new( 0 );
    }

    fn get_id() -> usize 
    {
        CUR_ID.fetch_add( 1, Ordering::Relaxed )
    }

    #[derive( Clone, Debug )]
    struct ObjInner 
    {
        map: HashMap<String, Value>,
        parent: Option<Obj>,
        id: usize,
    }
    /// `Obj` struct.
    #[derive( Clone, Debug )]
    pub struct Obj 
    {
        inner: Arc<ObjInner>,
    }

    macro_rules! get_fn 
    {
        ( $doc:expr, $name:tt, $type:ty ) => {
            #[doc=$doc]
            pub fn $name( &self, field:&str ) -> OverResult<$type> {
                match self.get( field ) {
                    Some( value ) => {
                        match value.$name() {
                            Ok( result ) => Ok( result ),
                            e @ Err( _ ) => e,
                        }
                    }
                    None => Err( OverError::FieldNotFound( field.into() ) ),
                }
            }
        }
    }

    impl Obj 
    {
        /// Gets the `Value` associated with `field`.
        pub fn read( &self, field:&str ) -> Result<Value, ()> 
        {
            match self.inner.map.get( field )
            {
                Some( value ) => Ok( value.clone() ),
                None => match self.inner.parent
                {
                    Some( ref parent ) => Ok( parent.get( field ).unwrap_or( Value::Null ) ),
                    None => Err( () ),
                },
            }
        }
        /// Returns a new `Obj` created from the given `HashMap`.
        pub fn from_map( obj_map: HashMap<String, Value> ) -> OverResult<Obj> 
        {
            for field in obj_map.keys() {
                if !Self::is_valid_field( field ) {
                    return Err( OverError::InvalidFieldName( ( *field ).clone() ) );
                }
            }
            let id = get_id();

            Ok( Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: None,
                    id,
                } ),
            } )
        }
        /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
        pub fn from_map_with_parent( obj_map: HashMap<String, Value>, parent: Obj ) -> OverResult<Obj> 
        {
            for field in obj_map.keys() {
                if !Self::is_valid_field( field ) {
                    return Err( OverError::InvalidFieldName( field.clone() ) );
                }
            }
            let id = get_id();

            Ok( Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: Some( parent ),
                    id,
                } ),
            } )
        }
        /// Returns a new `Obj` created from the given `HashMap`.
        pub fn from_map_unchecked( obj_map: HashMap<String, Value> ) -> Obj 
        {
            let id = get_id();

            Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: None,
                    id,
                } ),
            }
        }
        /// Returns a new `Obj` created from the given `HashMap` with given `parent`.
        pub fn from_map_with_parent_unchecked( obj_map: HashMap<String, Value>, parent: Obj ) -> Obj 
        {
            let id = get_id();

            Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: Some( parent ),
                    id,
                } ),
            }
        }
        /// Returns the ID of this `Obj`.
        pub fn id( &self ) -> usize 
        {
            self.inner.id
        }
        /// Returns a reference to the inner map of this `Obj`.
        pub fn map_ref( &self ) -> &HashMap<String, Value> 
        {
            &self.inner.map
        }
        /// Returns a new `Obj` loaded from a file.
        pub fn from_file( path:&str ) -> OverResult<Obj> 
        {
            Ok( parses::load_from_file( path )? )
        }
        /// Writes this `Obj` to given file in `.over` representation.
        pub fn write_to_file( &self, path:&str ) -> OverResult<()>
        {
            str::write_file_from( path, &self.write_str() )?;
            Ok( () )
        }
        /// Writes this `Obj` to a `String`.
        pub fn write_str( &self ) -> String 
        {
            self.format( false, 0 )
        }
        /// Iterates over each `( String, Value )` pair in `self`, applying `f`.
        pub fn with_each<F>( &self, mut f: F ) where
        F: FnMut( &String, &Value ),
        {
            for ( field, value ) in &self.inner.map {
                f( field, value )
            }
        }
        /// Returns the number of fields for this `Obj` ( parent fields not included ).
        pub fn len( &self ) -> usize 
        {
            self.inner.map.len()
        }
        /// Returns whether this `Obj` is empty.
        pub fn is_empty( &self ) -> bool 
        {
            self.inner.map.is_empty()
        }
        /// Returns whether `self` and `other` point to the same data.
        pub fn ptr_eq( &self, other:&Self ) -> bool 
        {
            Arc::ptr_eq( &self.inner, &other.inner )
        }
        /// Returns true if this `Obj` contains `field`.
        pub fn contains( &self, field:&str ) -> bool 
        {
            self.inner.map.contains_key( field )
        }
        /// Gets the `Value` associated with `field`.
        pub fn get( &self, field:&str ) -> Option<Value> 
        {
            match self.inner.map.get( field ) {
                Some( value ) => Some( value.clone() ),
                None => match self.inner.parent {
                    Some( ref parent ) => parent.get( field ),
                    None => None,
                },
            }
        }
        /// Gets the `Value` associated with `field` and the `Obj` where it was found.
        pub fn get_with_source( &self, field:&str ) -> Option<( Value, Obj )> 
        {
            match self.inner.map.get( field ) {
                Some( value ) => Some( ( value.clone(), self.clone() ) ),
                None => match self.inner.parent {
                    Some( ref parent ) => parent.get_with_source( field ),
                    None => None,
                },
            }
        }

        get_fn!
        ( 
            "Returns the `bool` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Bool`.",
            get_bool,
            bool
         );

        get_fn!
        ( 
            "Returns the `BigInt` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Int`.",
            get_int,
            BigInt
         );

        get_fn!
        ( 
            "Returns the `BigRational` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Frac`.",
            get_frac,
            BigRational
         );

        get_fn!
        ( 
            "Returns the `char` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Char`.",
            get_char,
            char
         );

        get_fn!
        ( 
            "Returns the `String` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Str`.",
            get_str,
            String
         );

        get_fn!
        ( 
            "Returns the `Arr` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Arr`.",
            get_arr,
            Arr
         );

        get_fn!
        ( 
            "Returns the `Tup` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Tup`.",
            get_tup,
            Tup
         );

        get_fn!
        ( 
            "Returns the `Obj` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Obj`.",
            get_obj,
            Obj
         );
        /// Returns whether this `Obj` has a parent.
        pub fn has_parent( &self ) -> bool 
        {
            self.inner.parent.is_some()
        }
        /// Returns the parent for this `Obj`.
        pub fn get_parent( &self ) -> Option<Obj> 
        {
            match self.inner.parent {
                Some( ref parent ) => Some( parent.clone() ),
                None => None,
            }
        }
        /// Returns true if `field` is a valid field name for an `Obj`.
        pub fn is_valid_field( field:&str ) -> bool 
        {
            let mut first = true;

            for ch in field.chars() {
                if first {
                    if !Self::is_valid_field_char( ch, true ) {
                        return false;
                    }
                    first = false;
                } else if !Self::is_valid_field_char( ch, false ) {
                    return false;
                }
            }
            true
        }
        /// Returns true if the given char is valid for a field, depending on whether it is the first char or not.
        pub fn is_valid_field_char( ch:char, first: bool ) -> bool 
        {
            match ch 
            {
                ch if ch.is_alphabetic() => true,
                ch if is::digit( ch ) => !first,
                '_' => true,
                '^' => first,
                _ => false,
            }
        }
        /// An iterator visiting all fields ( keys ) in arbitrary order.
        pub fn keys( &self ) -> Keys<String, Value> 
        {
            self.map_ref().keys()
        }
        /// An iterator visiting all values in arbitrary order.
        pub fn values( &self ) -> Values<String, Value> 
        {
            self.map_ref().values()
        }
        /// An iterator visiting all field-value pairs in arbitrary order.
        pub fn iter( &self ) -> Iter<String, Value> 
        {
            self.map_ref().iter()
        }
    }

    impl Default for Obj 
    {
        fn default() -> Self {
            Self::from_map_unchecked( map! {} )
        }
    }

    impl fmt::Display for Obj 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl FromStr for Obj 
    {
        type Err = OverError;

        fn from_str( s:&str ) -> Result<Self, Self::Err> 
        {
            Ok( parses::load_from_str( s )? )
        }
    }
    /// For two Objs to be equal, the following two checks must pass:
    /// 1. If either Obj has a parent, then both must have parents and the parents must be equal.
    /// 2. The two Objs must have all the same fields pointing to the same values.
    impl PartialEq for Obj 
    {
        fn eq( &self, other:&Self ) -> bool {
            let inner = &self.inner;
            let other_inner = &other.inner;

           
            if inner.parent.is_some() && other_inner.parent.is_some() {
                let parent = self.get_parent().unwrap();
                let other_parent = other.get_parent().unwrap();
                if parent != other_parent {
                    return false;
                }
            } else if !( inner.parent.is_none() && other_inner.parent.is_none() ) {
                return false;
            }
           
            inner.map == other_inner.map
        }
    }
}

pub mod ops
{
    pub use std::ops::{ * };

    /// Implemented for built-in range types
    pub trait RangeArgument<T>
    {
        /// Returns the start of range, if present.
        fn start( &self ) -> Option<&T> { None }
        /// Returns the end of range, if present.
        fn end( &self ) -> Option<&T> { None }
    }

    impl<T> RangeArgument<T> for Range<T>
    {
        fn start( &self ) -> Option<&T> { Some( &self.start ) }
        fn end( &self ) -> Option<&T> { Some( &self.end ) }
    }

    impl<T> RangeArgument<T> for RangeFrom<T>
    {
        fn start( &self ) -> Option<&T> { Some( &self.start ) }
    }

    impl<T> RangeArgument<T> for RangeTo<T>
    {
        fn end( &self ) -> Option<&T> { Some( &self.end ) }
    }

    impl<T> RangeArgument<T> for RangeFull {}
}

pub mod os
{
    pub use std::os::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod panic
{
    pub use std::panic::{ * };
}

pub mod parses
{
    /*!
    */
    use ::
    {
        arrays::{ self, Arr },
        char::{ CharStream },
        collections::{ HashMap, HashSet, VecDeque },
        error::{ parse::{ ParseErrorKind::{ * }, ParseError, parse_err } },
        num::
        {
            big::BigInt,
            rational::{ BigRational, frac_from_whole_and_dec },
            traits::{ ToPrimitive, Zero },
        },
        objects::{ Obj },
        ops::{ Deref },
        path::{ Path },
        result::{ ParseResult },
        tuples::{ Tup },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    */
    type ObjMap = HashMap<String, Value>;
    type GlobalMap = HashMap<String, Value>;
    type IncludedMap = ( HashMap<String, Value>, HashSet<String> );

    lazy_static! 
    {
        static ref OBJ_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
        static ref STR_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
        static ref ARR_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
        static ref TUP_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
    }
    pub const MAX_DEPTH: usize = 64;
    /// Load an `Obj` from a file.
    pub fn load_from_file( path:&str ) -> ParseResult<Obj>
    {
        object_file( path )
    }
    /// Load an `Obj` from a &str.
    pub fn load_from_str( contents:&str ) -> ParseResult<Obj>
    {
        object_from_str( contents )
    }
    /// Parses given file as an `Obj`.
   
    pub fn object_file( path:&str ) -> ParseResult<Obj>
    {
        let stream = CharStream::from_file( path )?;
        parse_obj_stream( stream, &mut ( HashMap::new(), HashSet::new() ) )
    }
   
    fn parse_obj_file_includes( path:&str, included:&mut IncludedMap ) -> ParseResult<Obj> {
        let stream = CharStream::from_file( path )?;
        parse_obj_stream( stream, included )
    }
    /// Parses given &str as an `Obj`.
   
    pub fn object_from_str( contents:&str ) -> ParseResult<Obj>
    {
        let contents = String::from( contents );
        let stream = CharStream::from_string( contents )?;
        parse_obj_stream( stream, &mut ( HashMap::new(), HashSet::new() ) )
    }
    /// Parses an Obj given a character stream.
    #[inline] fn parse_obj_stream( mut stream: CharStream, mut included:&mut IncludedMap ) -> ParseResult<Obj> {
        let mut obj: ObjMap = HashMap::new();
       
        if !find_char( stream.clone() ) {
            return Ok( Obj::from_map_unchecked( obj ) );
        }

        let mut globals: GlobalMap = HashMap::new();
        let mut parent = None;

       
        while parse_field_value_pair( 
            &mut stream,
            &mut obj,
            &mut globals,
            &mut included,
            &mut parent,
            1,
            None,
        )? {}

        Ok( match parent {
            Some( parent ) => Obj::from_map_with_parent_unchecked( obj, parent ),
            None => Obj::from_map_unchecked( obj ),
        } )
    }
   
    fn parse_obj
    ( 
        mut stream:&mut CharStream,
        globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {
       
        if depth > MAX_DEPTH {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }

       
        let ch = stream.next().unwrap();
        assert_eq!( ch, '{' );
       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

        let mut obj: ObjMap = HashMap::new();
        let mut parent = None;

       
        while parse_field_value_pair
        ( 
            &mut stream,
            &mut obj,
            globals,
            &mut included,
            &mut parent,
            depth,
            Some( '}' ),
        )? {}

        let obj = match parent 
        {
            Some( parent ) => Obj::from_map_with_parent_unchecked( obj, parent ),
            None => Obj::from_map_unchecked( obj ),
        };
        Ok( obj.into() )
    }
    /// Parses a field/value pair.
    #[inline] pub fn parse_field_value_pair
    ( 
        mut stream:&mut CharStream,
        obj:&mut ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        parent:&mut Option<Obj>,
        depth: usize,
        cur_brace: Option<char>,
    ) -> ParseResult<bool> 
    {
       
        let peek = stream.peek().unwrap();
        
        if peek == '}' && cur_brace.is_some() 
        {
            let _ = stream.next();
            return Ok( false );
        }
        
        else if is::end_delimiter( peek ) 
        {
            return parse_err( 
                stream.file(),
                InvalidClosingBracket( cur_brace, peek, stream.line(), stream.col() ),
             );
        }

       
        let ( field_line, field_col ) = ( stream.line(), stream.col() );

       
        let ( field, is_global, is_parent ) = parse_field( stream.clone(), field_line, field_col )?;

        if !is_global && !is_parent && obj.contains_key( &field ) {
            return parse_err( stream.file(), DuplicateField( field, field_line, field_col ) );
        } else if is_parent && parent.is_some() {
            return parse_err( 
                stream.file(),
                DuplicateField( "^".into(), field_line, field_col ),
             );
        }

       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

       
        let ( value_line, value_col ) = ( stream.line(), stream.col() );
        let value = parse_value( 
            &mut stream,
            obj,
            &mut globals,
            &mut included,
            value_line,
            value_col,
            depth,
            cur_brace,
            true,
        )?;
       
        if is_global {
            if globals.contains_key( &field ) {
                return parse_err( stream.file(), DuplicateGlobal( field, field_line, field_col ) );
            }
            globals.insert( field, value );
        } else if is_parent {
            let par = value
                .get_obj()
                .map_err( | e |ParseError::from_over( &e, stream.file(), value_line, value_col ) )?;
            *parent = Some( par );
        } else {
            obj.insert( field, value );
        }

       
        if !find_char( stream.clone() ) {
            match cur_brace {
                Some( _ ) => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                None => return Ok( false ),
            }
        }

        Ok( true )
    }
   
    fn parse_arr_file( path:&str, mut included:&mut IncludedMap ) -> ParseResult<Arr> {
        let mut stream = CharStream::from_file( path )?;

        let obj: ObjMap = HashMap::new();
        let mut globals: GlobalMap = HashMap::new();

        let mut vec = Vec::new();
        let mut tcur = Type::Any;
        let mut has_any = true;

        loop {
           
            if !find_char( stream.clone() ) {
                break;
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value( 
                &mut stream,
                &obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                1,
                None,
                true,
            )?;

            let tnew = value.get_type();

            if has_any {
                match Type::most_specific( &tcur, &tnew ) {
                    Some( ( t, any ) ) => {
                        tcur = t;
                        has_any = any;
                    }
                    None => {
                        return parse_err( 
                            stream.file(),
                            ExpectedType( tcur, tnew, value_line, value_col ),
                         );
                    }
                }
            } else if tcur != tnew {
                return parse_err( 
                    stream.file(),
                    ExpectedType( tcur, tnew, value_line, value_col ),
                 );
            }
            vec.push( value );
        }

        let arr = Arr::from_vec_unchecked( vec, tcur );

        Ok( arr )
    }
   
    fn parse_arr
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {
       
        if depth > MAX_DEPTH 
        {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }

       
        let ch = stream.next().unwrap();
        assert_eq!( ch, '[' );

        let mut vec = Vec::new();
        let mut tcur = Type::Any;
        let mut has_any = true;

        loop 
        {
           
            if !find_char( stream.clone() ) 
            {
                return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
            }
            let peek = stream.peek().unwrap();
            if peek == ']' 
            {
                let _ = stream.next();
                break;
            } 
            
            else if is::end_delimiter( peek ) 
            {
                return parse_err( 
                    stream.file(),
                    InvalidClosingBracket( Some( ']' ), peek, stream.line(), stream.col() ),
                 );
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                depth,
                Some( ']' ),
                true,
            )?;

            let tnew = value.get_type();

            if has_any {
                match Type::most_specific( &tcur, &tnew ) {
                    Some( ( t, any ) ) => {
                        tcur = t;
                        has_any = any;
                    }
                    None => {
                        return parse_err( 
                            stream.file(),
                            ExpectedType( tcur, tnew, value_line, value_col ),
                         );
                    }
                }
            } else if tcur != tnew {
                return parse_err( 
                    stream.file(),
                    ExpectedType( tcur, tnew, value_line, value_col ),
                 );
            }
            vec.push( value );
        }

        let arr = Arr::from_vec_unchecked( vec, tcur );

        Ok( arr.into() )
    }
   
    fn parse_tup_file( path:&str, mut included:&mut IncludedMap ) -> ParseResult<Tup> {
        let mut stream = CharStream::from_file( path )?;

        let mut vec: Vec<Value> = Vec::new();
        let obj: ObjMap = HashMap::new();
        let mut globals: GlobalMap = HashMap::new();

        loop {
           
            if !find_char( stream.clone() ) {
                break;
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value( 
                &mut stream,
                &obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                1,
                None,
                true,
            )?;

            vec.push( value );
        }

        Ok( vec.into() )
    }
   
    fn parse_tup
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {        
        if depth > MAX_DEPTH 
        {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }
        
        let ch = stream.next().unwrap();
        assert_eq!( ch, '(' );

        let mut vec = Vec::new();

        loop 
        {
            if !find_char( stream.clone() ) 
            {
                return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
            }
            let peek = stream.peek().unwrap();
            
            if peek == ')' 
            {
                let _ = stream.next();
                break;
            } 
            
            else if is::end_delimiter( peek )
            {
                return parse_err( 
                    stream.file(),
                    InvalidClosingBracket( Some( ')' ), peek, stream.line(), stream.col() ),
                 );
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value
            ( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                depth,
                Some( ')' ),
                true,
            )?;

            vec.push( value );
        }

        let tup = Tup::from_vec( vec );

        Ok( tup.into() )
    }
   
    fn parse_field
    ( 
        mut stream: CharStream,
        line: usize,
        col: usize,
    ) -> ParseResult<( String, bool, bool )> 
    {
        let mut field = String::new();
        let mut first = true;
        let mut is_global = false;

        let ch = stream.peek().unwrap();
        
        if ch == '@' {
            let ch = stream.next().unwrap();
            is_global = true;
            field.push( ch );
        }

        while let Some( ch ) = stream.next() 
        {
            match ch {
                ':' if !first => {
                    break;
                }
                ch if Obj::is_valid_field_char( ch, first ) => field.push( ch ),
                ch => {
                    return parse_err( 
                        stream.file(),
                        InvalidFieldChar( ch, stream.line(), stream.col() - 1 ),
                     );
                }
            }
            first = false;
        }
       
        match field.as_str() 
        {
            _field_str if is::reserved( _field_str ) => 
            {
                parse_err( stream.file(), InvalidFieldName( field.clone(), line, col ) )
            }
            "^" => Ok( ( field.clone(), false, true ) ),
            bad if bad.starts_with( '^' ) => 
            {
                parse_err( stream.file(), InvalidFieldName( field.clone(), line, col ) )
            }
            _ => Ok( ( field.clone(), is_global, false ) ),
        }
    }
   
    fn parse_value
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        line: usize,
        col: usize,
        depth: usize,
        cur_brace: Option<char>,
        is_first: bool,
    ) -> ParseResult<Value> 
    {
       
        let res = match stream.peek().unwrap() 
        {
            '"' => parse_str( &mut stream )?,
            '\'' => parse_char( &mut stream )?,
            '{' => parse_obj( &mut stream, &mut globals, included, depth + 1 )?,
            '[' => parse_arr( &mut stream, obj, &mut globals, included, depth + 1 )?,
            '(' => parse_tup( &mut stream, obj, &mut globals, included, depth + 1 )?,
            '@' => parse_variable( 
                &mut stream,
                obj,
                globals,
                included,
                line,
                col,
                depth,
                cur_brace,
            )?,
            '<' => parse_include( &mut stream, obj, &mut globals, &mut included, depth + 1 )?,
            ch @ '+' | ch @ '-' => {
                parse_unary_op( &mut stream, obj, globals, included, depth, cur_brace, ch )?
            }
            ch if is::numeric_char( ch ) => parse_numeric( &mut stream, line, col )?,
            ch if Obj::is_valid_field_char( ch, true ) => parse_variable( 
                &mut stream,
                obj,
                globals,
                included,
                line,
                col,
                depth,
                cur_brace,
            )?,
            ch => {
                return parse_err( stream.file(), InvalidValueChar( ch, line, col ) );
            }
        };
       
        if is_first 
        {
            let mut val_deque: VecDeque<( Value, usize, usize )> = VecDeque::new();
            let mut op_deque: VecDeque<char> = VecDeque::new();
            val_deque.push_back( ( res, line, col ) );

            loop 
            {
                match stream.peek()
                {
                    Some( ch ) if is::operator( ch ) => 
                    {
                        let _ = stream.next();
                        if stream.peek().is_none() {
                            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
                        }
                        let ( line2, col2 ) = ( stream.line(), stream.col() );

                       
                        let val2 = parse_value( 
                            &mut stream,
                            obj,
                            &mut globals,
                            &mut included,
                            line2,
                            col2,
                            depth,
                            cur_brace,
                            false,
                        )?;

                        if is::priority_operator( ch ) 
                        {
                            let ( val1, line1, col1 ) = val_deque.pop_back().unwrap();
                            let res = binary_op_on_values( stream, val1, val2, ch, line2, col2 )?;
                            val_deque.push_back( ( res, line1, col1 ) );
                        }
                        
                        else
                        {
                            val_deque.push_back( ( val2, line2, col2 ) );
                            op_deque.push_back( ch );
                        }
                    }
                    _ => break,
                }
            }
           
            check_value_end( stream, cur_brace )?;

            let ( mut val1, _, _ ) = val_deque.pop_front().unwrap();
            while !op_deque.is_empty() {
                let ( val2, line2, col2 ) = val_deque.pop_front().unwrap();
                val1 = binary_op_on_values( 
                    stream,
                    val1,
                    val2,
                    op_deque.pop_front().unwrap(),
                    line2,
                    col2,
                )?;
            }
            Ok( val1 )
        } 

        else 
        {
            Ok( res )
        }
    }

    fn parse_unary_op
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
        cur_brace: Option<char>,
        ch:char,
    ) -> ParseResult<Value> 
    {
        let _ = stream.next();
        let line = stream.line();
        let col = stream.col();

        let res = match stream.peek() {
            Some( _ ) => parse_value( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                line,
                col,
                depth + 1,
                cur_brace,
                false,
            )?,
            None => return parse_err( stream.file(), UnexpectedEnd( line ) ),
        };
        unary_op_on_value( stream, res, ch, line, col )
    }
   
    fn parse_numeric( stream:&mut CharStream, line: usize, col: usize ) -> ParseResult<Value> 
    {
        let mut s1 = String::new();
        let mut s2 = String::new();
        let mut dec = false;
        let mut under = false;

        while let Some( ch ) = stream.peek() {
            match ch {
                ch if is::value_end_char( ch ) => break,
                ch if is::digit( ch ) => {
                    if !dec {
                        s1.push( ch );
                    } else {
                        s2.push( ch );
                    }
                }
                '.' | ',' => {
                    if !dec {
                        dec = true;
                    } else {
                        return parse_err( 
                            stream.file(),
                            InvalidValueChar( ch, stream.line(), stream.col() ),
                         );
                    }
                }
                '_' => {
                    if !under {
                        under = true;
                    } else {
                        return parse_err( 
                            stream.file(),
                            InvalidValueChar( ch, stream.line(), stream.col() ),
                         );
                    }
                }
                _ => {
                    return parse_err( 
                        stream.file(),
                        InvalidValueChar( ch, stream.line(), stream.col() ),
                     );
                }
            }
            if ch != '_' {
                under = false;
            }
            let _ = stream.next();
        }

        if dec {
           
            if s1.is_empty() && s2.is_empty() {
                return parse_err( stream.file(), InvalidNumeric( line, col ) );
            }
            let whole: BigInt = if s1.is_empty() {
                0u8.into()
            } else {
                s1.parse()?
            };

           
            let s2 = s2.trim_end_matches( '0' );

            let ( decimal, dec_len ): ( BigInt, usize ) = if s2.is_empty() {
                ( 0u8.into(), 1 )
            } else {
                ( s2.parse()?, s2.len() )
            };

            let f = frac_from_whole_and_dec( whole, decimal, dec_len );
            Ok( f.into() )
        } else {
           
            if s1.is_empty() {
                return parse_err( stream.file(), InvalidNumeric( line, col ) );
            }
            let i: BigInt = s1.parse()?;
            Ok( i.into() )
        }
    }
   
    fn parse_variable
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        line: usize,
        col: usize,
        depth: usize,
        cur_brace: Option<char>,
    ) -> ParseResult<Value> 
    {
        let mut var = String::new();
        let mut is_global = false;
        let mut dot = false;
        let mut dot_global = false;

        let ch = stream.peek().unwrap();
        
        if ch == '@' {
            let ch = stream.next().unwrap();
            is_global = true;
            var.push( ch );
        }

        while let Some( ch ) = stream.peek() 
        {
            match ch 
            {
                '.' => {
                    let _ = stream.next();
                    match stream.peek() {
                        Some( '@' ) => dot_global = true,
                        Some( ch ) if Obj::is_valid_field_char( ch, true ) || is::numeric_char( ch ) => (),
                        Some( ch ) => {
                            return parse_err( 
                                stream.file(),
                                InvalidValueChar( ch, stream.line(), stream.col() ),
                             );
                        }
                        None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                    }
                    dot = true;
                    break;
                }
                ch if is::value_end_char( ch ) => break,
                ch if Obj::is_valid_field_char( ch, false ) => {
                    let _ = stream.next();
                    var.push( ch );
                }
                ch => {
                    return parse_err( 
                        stream.file(),
                        InvalidValueChar( ch, stream.line(), stream.col() ),
                     );
                }
            }
        }

        let mut value = match var.as_str() 
        {
            "null" => Value::Null,
            "true" => Value::Bool( true ),
            "false" => Value::Bool( false ),

            "Obj" => Value::Obj( OBJ_SENTINEL.clone() ),
            "Str" => Value::Obj( STR_SENTINEL.clone() ),
            "Arr" => Value::Obj( ARR_SENTINEL.clone() ),
            "Tup" => Value::Obj( TUP_SENTINEL.clone() ),

            var @ "@" => return parse_err( stream.file(), InvalidValue( var.into(), line, col ) ),
            
            var if is_global => 
            {
               
                match globals.get( var ) {
                    Some( value ) => value.clone(),
                    None => {
                        let var = String::from( var );
                        return parse_err( stream.file(), GlobalNotFound( var, line, col ) );
                    }
                }
            }
            
            var => 
            {
               
                match obj.get( var ) {
                    Some( value ) => value.clone(),
                    None => {
                        let var = String::from( var );
                        return parse_err( stream.file(), VariableNotFound( var, line, col ) );
                    }
                }
            }
        };

        if dot 
        {
            value = match value 
            {
                Value::Arr( arr ) => {
                    let ( line, col ) = ( stream.line(), stream.col() );
                    let value = parse_value( 
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                        false,
                    )?;

                    match value {
                        Value::Int( int ) => match int.to_usize() {
                            Some( index ) => arr
                                .get( index )
                                .map_err( | e |ParseError::from_over( &e, stream.file(), line, col ) )?,
                            None => return parse_err( stream.file(), InvalidIndex( int, line, col ) ),
                        },
                        _ => {
                            return parse_err( 
                                stream.file(),
                                ExpectedType( Type::Int, value.get_type(), line, col ),
                             );
                        }
                    }
                }
                Value::Tup( tup ) => {
                    let ( line, col ) = ( stream.line(), stream.col() );
                    let value = parse_value( 
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                        false,
                    )?;

                    match value {
                        Value::Int( int ) => match int.to_usize() {
                            Some( index ) => tup
                                .get( index )
                                .map_err( | e |ParseError::from_over( &e, stream.file(), line, col ) )?,
                            None => return parse_err( stream.file(), InvalidIndex( int, line, col ) ),
                        },
                        _ => {
                            return parse_err( 
                                stream.file(),
                                ExpectedType( Type::Int, value.get_type(), line, col ),
                             );
                        }
                    }
                }
                Value::Obj( obj ) => {
                    let ( line, col ) = ( stream.line(), stream.col() );

                    if dot_global {
                        return parse_err( stream.file(), InvalidValueChar( '@', line, col ) );
                    }
                    parse_variable( 
                        &mut stream,
                        obj.map_ref(),
                        globals,
                        included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                    )?
                }
                _ => return parse_err( stream.file(), InvalidDot( value.get_type(), line, col ) ),
            }
        }

        Ok( value )
    }
   
    fn parse_char( stream:&mut CharStream ) -> ParseResult<Value> 
    {
        let ch = stream.next().unwrap();
        assert_eq!( ch, '\'' );

        let ( escape, mut ch ) = match stream.next() 
        {
            Some( '\\' ) => ( true, '\0' ),
            Some( ch ) if ch == '\n' || ch == '\r' || ch == '\t' => {
                return parse_err( 
                    stream.file(),
                    InvalidValueChar( ch, stream.line(), stream.col() - 1 ),
                 );
            }
            Some( ch ) => ( false, ch ),
            None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
        };

        if escape 
        {
            ch = match stream.next() 
            {
                Some( ch ) => match get::escaped_character( ch )
                {
                    Some( ch ) => ch,
                    None => {
                        return parse_err( 
                            stream.file(),
                            InvalidEscapeChar( ch, stream.line(), stream.col() - 1 ),
                         );
                    }
                },

                None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
            }
        }

        match stream.next() 
        {
            Some( '\'' ) => (),
            Some( ch ) => {
                return parse_err( 
                    stream.file(),
                    InvalidValueChar( ch, stream.line(), stream.col() - 1 ),
                 );
            }
            None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
        }

        Ok( ch.into() )
    }

    fn parse_str_file( path:&str ) -> ParseResult<String> 
    {
       
        let s = str::read_from_file( path )?.replace( "\r\n", "\n" );

        Ok( s )
    }
   
    fn parse_str( stream:&mut CharStream ) -> ParseResult<Value> 
    {
        let ch = stream.next().unwrap();
        assert_eq!( ch, '"' );

        let mut s = String::new();
        let mut escape = false;

        loop 
        {
            match stream.next() {
                Some( ch ) => {
                    if escape {
                        match get::escaped_character( ch ) {
                            Some( ch ) => s.push( ch ),
                            None => {
                                return parse_err( 
                                    stream.file(),
                                    InvalidEscapeChar( ch, stream.line(), stream.col() - 1 ),
                                 );
                            }
                        }
                        escape = false;
                    } else {
                        match ch {
                            '"' => break,
                            '\\' => escape = true,
                            _ => s.push( ch ),
                        }
                    }
                }
                None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
            }
        }

       
        let s = s.replace( "\r\n", "\n" );

        Ok( s.into() )
    }

    fn parse_include
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {
        enum IncludeType {
            Obj,
            Str,
            Arr,
            Tup,
        }

       
        if depth > MAX_DEPTH {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }

        let ch = stream.next().unwrap();
        assert_eq!( ch, '<' );
       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

        let ( mut line, mut col ) = ( stream.line(), stream.col() );
        let mut value = parse_value( 
            &mut stream,
            obj,
            &mut globals,
            &mut included,
            line,
            col,
            depth,
            Some( '>' ),
            true,
        )?;

        let mut include_type = IncludeType::Obj;
        let mut parse_again = true;
        match value {
            Value::Obj( ref obj ) if obj.ptr_eq( &OBJ_SENTINEL ) => include_type = IncludeType::Obj,
            Value::Obj( ref obj ) if obj.ptr_eq( &STR_SENTINEL ) => include_type = IncludeType::Str,
            Value::Obj( ref obj ) if obj.ptr_eq( &ARR_SENTINEL ) => include_type = IncludeType::Arr,
            Value::Obj( ref obj ) if obj.ptr_eq( &TUP_SENTINEL ) => include_type = IncludeType::Tup,
            Value::Str( _ ) => parse_again = false,
            _ => {
                return parse_err( 
                    stream.file(),
                    InvalidIncludeToken( value.get_type(), line, col ),
                 );
            }
        }

        if parse_again {
           
            if !find_char( stream.clone() ) {
                return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
            }
            line = stream.line();
            col = stream.col();
            value = parse_value( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                line,
                col,
                depth,
                Some( '>' ),
                true,
            )?;
        }

       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

        match stream.next().unwrap() {
            '>' => (),
            ch => {
                return parse_err( 
                    stream.file(),
                    InvalidClosingBracket( Some( '>' ), ch, stream.line(), stream.col() - 1 ),
                 );
            }
        }

       
        let include_file = match value {
            Value::Str( s ) => s,
            _ => {
                return parse_err( 
                    stream.file(),
                    ExpectedType( Type::Str, value.get_type(), line, col ),
                 );
            }
        };

        let pathbuf = match stream.file().as_ref() {
            Some( file ) => Path::new( file )
                .parent()
                .unwrap()
                .join( Path::new( &include_file ) ),
            None => Path::new( &include_file ).to_path_buf(),
        };
        let path = pathbuf.as_path();
        
        if !path.is_file() {
            return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) );
        }

       
        let path_str = match path.to_str() {
            Some( path ) => path,
            None => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
        };

       
        let path = match path.canonicalize() {
            Ok( path ) => path,
            Err( _ ) => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
        };
        let full_path_str = match path.to_str() {
            Some( path ) => path,
            None => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
        };

       
        let storing = if let Some( file ) = stream.file() {
            let full_file = String::from( Path::new( &file ).canonicalize().unwrap().to_str().unwrap() );
            included.1.insert( full_file.clone() );
            Some( full_file )
        } else {
            None
        };
        
        if included.1.contains( full_path_str ) {
            return parse_err( stream.file(), CyclicInclude( include_file, line, col ) );
        }

       
        let value = if included.0.contains_key( full_path_str ) {
            let value = &included.0[full_path_str];
            value.clone()
        } else {
            let value: Value = match include_type {
                IncludeType::Obj => parse_obj_file_includes( path_str, included )?.into(),
                IncludeType::Str => parse_str_file( path_str )?.into(),
                IncludeType::Arr => parse_arr_file( path_str, included )?.into(),
                IncludeType::Tup => parse_tup_file( path_str, included )?.into(),
            };
           
            included.0.insert( full_path_str.into(), value.clone() );
            value
        };
       
        if let Some( file ) = storing {
            included.1.remove( &file );
        }

        Ok( value )
    }
   
    fn unary_op_on_value
    ( 
        stream:&CharStream,
        val: Value,
        op:char,
        line: usize,
        col: usize,
    ) -> ParseResult<Value> 
    {
        use crate::types::Type::*;

        let t = val.get_type();

        Ok( match op {
            '+' => match t {
                Int | Frac => val,
                _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
            },
            '-' => match t {
                Int => ( -val.get_int().unwrap() ).into(),
                Frac => ( -val.get_frac().unwrap() ).into(),
                _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
            },
            _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
        } )
    }
   
    fn binary_op_on_values
    ( 
        stream:&CharStream,
        mut val1: Value,
        mut val2: Value,
        op:char,
        line: usize,
        col: usize,
    ) -> ParseResult<Value> 
    {
        use crate::types::Type::*;

        let ( mut type1, mut type2 ) = ( val1.get_type(), val2.get_type() );
       
        if type1 == Int && type2 == Frac {
            val1 = Value::Frac( BigRational::new( val1.get_int().unwrap(), 1.into() ) );
            type1 = Frac;
        } else if type1 == Frac && type2 == Int {
            val2 = Value::Frac( BigRational::new( val2.get_int().unwrap(), 1.into() ) );
            type2 = Frac;
        }

        Ok( match op {
            '+' => {
                match type1 {
                    Int if type2 == Int => ( val1.get_int().unwrap() + val2.get_int().unwrap() ).into(),
                    Frac if type2 == Frac => {
                        ( val1.get_frac().unwrap() + val2.get_frac().unwrap() ).into()
                    }
                    Char if type2 == Char => {
                        let mut s = String::with_capacity( 2 );
                        s.push( val1.get_char().unwrap() );
                        s.push( val2.get_char().unwrap() );
                        s.into()
                    }
                    Char if type2 == Str => {
                        let str2 = val2.get_str().unwrap();
                        let mut s = String::with_capacity( 1 + str2.len() );
                        s.push( val1.get_char().unwrap() );
                        s.push_str( &str2 );
                        s.into()
                    }
                    Str if type2 == Char => {
                        let str1 = val1.get_str().unwrap();
                        let mut s = String::with_capacity( str1.len() + 1 );
                        s.push_str( &str1 );
                        s.push( val2.get_char().unwrap() );
                        s.into()
                    }
                    Str if type2 == Str => {
                        let str1 = val1.get_str().unwrap();
                        let str2 = val2.get_str().unwrap();
                        let mut s = String::with_capacity( str1.len() + str2.len() );
                        s.push_str( &str1 );
                        s.push_str( &str2 );
                        s.into()
                    }
                    Arr( _ ) => {
                        match Type::most_specific( &type1, &type2 ) {
                            Some( ( t, _ ) ) => {
                                let ( arr1, arr2 ) = ( val1.get_arr().unwrap(), val2.get_arr().unwrap() );
                                let ( mut vec1, mut vec2 ) =
                                    ( arr1.vec_ref().clone(), arr2.vec_ref().clone() );

                                let mut vec = Vec::with_capacity( vec1.len() + vec2.len() );
                                vec.append( &mut vec1 );
                                vec.append( &mut vec2 );

                               
                                let arr = if let Arr( ref t ) = t {
                                   
                                    arrays::Arr::from_vec_unchecked( vec, t.deref().clone() )
                                } else {
                                    panic!( "Logic error" )
                                };

                                arr.into()
                            }
                            None => {
                                return parse_err( 
                                    stream.file(),
                                    BinaryOperatorError( type1, type2, op, line, col ),
                                 );
                            }
                        }
                    }
                    _ => {
                        return parse_err( 
                            stream.file(),
                            BinaryOperatorError( type1, type2, op, line, col ),
                         );
                    }
                }
            }
            '-' => match type1 {
                Int if type2 == Int => ( val1.get_int().unwrap() - val2.get_int().unwrap() ).into(),
                Frac if type2 == Frac => ( val1.get_frac().unwrap() - val2.get_frac().unwrap() ).into(),
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            '*' => match type1 {
                Int if type2 == Int => ( val1.get_int().unwrap() * val2.get_int().unwrap() ).into(),
                Frac if type2 == Frac => ( val1.get_frac().unwrap() * val2.get_frac().unwrap() ).into(),
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            '/' => match type1 {
                Int if type2 == Int => {
                    let ( int1, int2 ) = ( val1.get_int().unwrap(), val2.get_int().unwrap() );
                    if int2.is_zero() {
                        return parse_err( stream.file(), InvalidNumeric( line, col ) );
                    }
                    BigRational::new( int1, int2 ).into()
                }
                Frac if type2 == Frac => {
                    let ( frac1, frac2 ) = ( val1.get_frac().unwrap(), val2.get_frac().unwrap() );
                    if frac2.is_zero() {
                        return parse_err( stream.file(), InvalidNumeric( line, col ) );
                    }
                    ( frac1 / frac2 ).into()
                }
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            '%' => match type1 {
                Int if type2 == Int => {
                    let int2 = val2.get_int().unwrap();
                    if int2.is_zero() {
                        return parse_err( stream.file(), InvalidNumeric( line, col ) );
                    }
                    ( val1.get_int().unwrap() % int2 ).into()
                }
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            _ => {
                return parse_err( 
                    stream.file(),
                    BinaryOperatorError( type1, type2, op, line, col ),
                 );
            }
        } )
    }
   
    fn find_char( mut stream: CharStream ) -> bool 
    {
        while let Some( ch ) = stream.peek() {
            match ch {
                '#' => {
                   
                    loop {
                        let ch = stream.next();
                        if ch.is_none() {
                            return false;
                        }
                        if ch.unwrap() == '\n' {
                            break;
                        }
                    }
                }
                ch if ch.is_whitespace() => {
                    let _ = stream.next();
                }
                _ => return true,
            }
        }

        false
    }
   
    fn check_value_end( stream:&CharStream, cur_brace: Option<char> ) -> ParseResult<()> 
    {
        match stream.peek()
        {
            Some( ch ) => match ch
            {
                ch if is::value_end_char( ch ) =>
                {
                    if is::end_delimiter( ch ) && Some( ch ) != cur_brace
                    {
                        parse_err
                        ( 
                            stream.file(),
                            InvalidClosingBracket( cur_brace, ch, stream.line(), stream.col() ),
                        )
                    }
                    
                    else
                    {
                        Ok( () )
                    }
                }
                ch => parse_err
                ( 
                    stream.file(),
                    InvalidValueChar( ch, stream.line(), stream.col() ),
                ),
            },
            None => Ok( () ),
        }
    }
}

pub mod path
{
    pub use std::path::{ * };
    use ::
    {
        borrow::{ Cow },
        cmp::{ self, Ordering },
        error::{ Error },
        fs::{ self, DirEntry, read_dir },
        io::{ self, ErrorKind, Write },
        ops::{ Deref },
        os::unix::fs::PermissionsExt,
        regex::{ Regex },
        str::{ FromStr },
        *,
    };
    
    pub const ERROR_WILDCARDS: &str = "wildcards are either regular `*` or recursive `**`";
    pub const ERROR_RECURSIVE_WILDCARDS: &str = "recursive wildcards must form a single path component";
    pub const ERROR_INVALID_RANGE: &str = "invalid range pattern";
    /*
    */
    pub fn basename( path:&str ) -> Cow<'_, str>
    {
        let mut pieces = path.rsplit('/');
        
        match pieces.next()
        {
            Some( p) => p.into(),
            None => path.into(),
        }
    }
    // pub fn find_file_in_path( filename: &str, exec:bool ) -> String
    pub fn find_file( filename: &str, exec:bool ) -> String
    {
        let env_path = match env::var( "PATH" )
        {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( ":: error with env PATH: {:?}", e );
                return String::new();
            }
        };
        let vec_path = env::split_paths( &env_path );
        for p in vec_path {
            match read_dir( &p) {
                Ok(list ) => {
                    for entry in list.flatten() {
                        if let Ok( name ) = entry.file_name().into_string() {
                            if name != filename {
                                continue;
                            }

                            if exec {
                                let _mode = match entry.metadata() {
                                    Ok( x ) => x,
                                    Err( e ) => {
                                        println_stderr!( ":: metadata error: {:?}", e );
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                            }

                            return entry.path().to_string_lossy().to_string();
                        }
                    }
                }
                Err( e ) => {
                    if e.kind() == ErrorKind::NotFound {
                        continue;
                    }
                    log!( ":: fs read_dir error: {}: {}", p.display(), e );
                }
            }
        }
        String::new()
    }

    pub fn current_dir() -> String
    {
        let _current_dir = match env::current_dir()
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                // log!( ":: PROMPT: env current_dir error: {}", e );
                return String::new();
            }
        };

        let current_dir = match _current_dir.to_str()
        {
            Some( x ) => x,
            None =>
            {
                // log!( ":: PROMPT: to_str error" );
                return String::new();
            }
        };

        current_dir.to_string()
    }
    // Support for matching file paths against Unix shell style patterns.
    /// An iterator that yields `Path`s from the filesystem that match a particular pattern.
    #[derive( Debug )]
    pub struct Paths
    {
        dir_patterns: Vec<Pattern>,
        require_dir: bool,
        options: MatchOptions,
        todo: Vec<Result<( PathWrapper, usize ), GlobError>>,
        scope: Option<PathWrapper>,
    }
    /// Return an iterator for all the `Path`s that match the given pattern using default match options.
    pub fn glob( pattern:&str ) -> Result<Paths, PatternError> { glob_with( pattern, MatchOptions::new() ) }
    /// Return an iterator that produces all the `Path`s that match the given pattern using specified match options.
    pub fn glob_with( pattern:&str, options:MatchOptions ) -> Result<Paths, PatternError>
    {
        #[cfg( windows )]
        fn check_windows_verbatim( p:&Path ) -> bool
        {
            match p.components().next()
            {
                Some( Component::Prefix( ref p ) ) =>
                {
                    p.kind().is_verbatim() && if let std::path::Prefix::VerbatimDisk(_ ) = p.kind() { false }
                    else { true }
                }
                _ => false,
            }
        }

        #[cfg( not( windows  ) )]
        fn check_windows_verbatim( _:&Path ) -> bool { false }

        #[cfg( windows )]
        fn to_scope( p:&Path ) -> PathBuf { p.to_path_buf() }

        #[cfg( not( windows  ) )]
        fn to_scope( p:&Path ) -> PathBuf { p.to_path_buf() }
        
        let _ = Pattern::new( pattern )?;

        let mut components = Path::new( pattern ).components().peekable();

        loop
        {
            match components.peek()
            {
                Some( &Component::Prefix(..) ) | Some( &Component::RootDir ) => { components.next(); }
                _ => break,
            }
        }

        let rest = components.map( |s| s.as_os_str() ).collect::<PathBuf>();
        let normalized_pattern = Path::new( pattern ).iter().collect::<PathBuf>();
        let root_len = normalized_pattern.to_str().unwrap().len() - rest.to_str().unwrap().len();

        let root = if root_len > 0 { Some( Path::new( &pattern[..root_len] ) ) }
        else { None };

        if root_len > 0 && check_windows_verbatim( root.unwrap() )
        {
            return Ok
            (
                Paths
                {
                    dir_patterns: Vec::new(),
                    require_dir: false,
                    options,
                    todo: Vec::new(),
                    scope: None,
                }
            );
        }

        let scope = root.map_or_else( || PathBuf::from( "." ), to_scope );
        let scope = PathWrapper::from_path( scope );

        let mut dir_patterns = Vec::new();
        let components = pattern[cmp::min( root_len, pattern.len() )..].split_terminator( is_separator );

        for component in components
        {
            dir_patterns.push( Pattern::new( component )? );
        }

        if root_len == pattern.len()
        {
            dir_patterns.push
            (
                Pattern
                {
                    original: "".to_string(),
                    tokens: Vec::new(),
                    is_recursive: false,
                    has_metachars: false,
                }
            );
        }

        let last_is_separator = pattern.chars().next_back().map( is_separator );
        let require_dir = last_is_separator == Some( true );
        let todo = Vec::new();

        Ok
        (
            Paths
            {
                dir_patterns,
                require_dir,
                options,
                todo,
                scope: Some( scope ),
            }
        )
    }
    /// A glob iteration error.
    #[derive( Debug )]
    pub struct GlobError
    {
        path:PathBuf,
        error:io::Error,
    }

    impl GlobError
    {
        /// The Path that the error corresponds to.
        pub fn path( &self ) -> &Path { &self.path }
        /// The error in question.
        pub fn error( &self ) -> &io::Error { &self.error }
        /// Consumes self, returning the _raw_ underlying `io::Error`
        #[deprecated( note = "use `.into` instead" )]
        pub fn into_error( self ) -> io::Error { self.error }
    }

    impl From<GlobError> for io::Error
    {
        fn from( value:GlobError ) -> Self { value.error }
    }

    impl Error for GlobError
    {
        fn description( &self ) -> &str { self.error.description() }
        fn cause( &self ) -> Option<&Error> { Some( &self.error ) }
    }

    impl fmt::Display for GlobError
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            write!
            (
                f,
                "attempting to read `{}` resulted in an error: {}",
                self.path.display(),
                self.error
            )
        }
    }

    #[derive( Debug )]
    pub struct PathWrapper
    {
        path: PathBuf,
        is_directory: bool,
    }

    impl PathWrapper
    {
        fn from_dir_entry( path: PathBuf, e: DirEntry) -> Self
        {
            let is_directory = e
            .file_type()
            .ok()
            .and_then(|file_type|
            {
                if file_type.is_symlink() { None }                    
                else { Some( file_type.is_dir() ) }
            })
            .or_else(|| fs::metadata( &path ).map(|m| m.is_dir() ).ok() )
            .unwrap_or( false );

            Self { path, is_directory }
        }

        fn from_path( path: PathBuf) -> Self
        {
            let is_directory = fs::metadata( &path ).map(|m| m.is_dir() ).unwrap_or( false );
            Self { path, is_directory }
        }

        fn into_path( self ) -> PathBuf { self.path }
    }

    impl Deref for PathWrapper 
    {
        type Target = Path;

        fn deref( &self ) -> &Self::Target {
            self.path.deref()
        }
    }

    impl AsRef<Path> for PathWrapper 
    {
        fn as_ref( &self ) -> &Path {
            self.path.as_ref()
        }
    }
    
    /// An alias for a glob iteration result.
    pub type GlobResult = Result<PathBuf, GlobError>;

    impl Iterator for Paths
    {
        type Item = GlobResult;

        fn next( &mut self) -> Option<GlobResult>
        {
            if let Some( scope ) = self.scope.take()
            {
                if !self.dir_patterns.is_empty()
                {
                    assert!( self.dir_patterns.len() < usize::MAX);
                    fill_todo( &mut self.todo, &self.dir_patterns, 0, &scope, self.options );
                }
            }

            loop
            {
                if self.dir_patterns.is_empty() || self.todo.is_empty() { return None; }

                let ( path, mut idx) = match self.todo.pop().unwrap()
                {
                    Ok( pair ) => pair,
                    Err( e ) => return Some(Err( e  ) ),
                };
                
                if idx == usize::MAX
                {
                    if self.require_dir && !path.is_directory { continue; }

                    return Some(Ok( path.into_path() ) );
                }

                if self.dir_patterns[idx].is_recursive
                {
                    let mut next = idx;
                    
                    while ( next + 1) < self.dir_patterns.len() && self.dir_patterns[next + 1].is_recursive 
                    { next += 1; }

                    if path.is_directory
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            next,
                            &path,
                            self.options,
                        );

                        if next == self.dir_patterns.len() - 1 { return Some(Ok( path.into_path() ) ); }
                        else { idx = next + 1; }
                    }
                    
                    else if next == self.dir_patterns.len() - 1 { continue; }
                    else { idx = next + 1; }
                }
                
                if self.dir_patterns[idx].matches_with
                (
                    {
                        match path.file_name().and_then(|s| s.to_str() )
                        {
                            None => continue,
                            Some( x ) => x,
                        }
                    },
                    self.options,
                )
                {
                    if idx == self.dir_patterns.len() - 1
                    {
                        if !self.require_dir || path.is_directory { return Some(Ok( path.into_path() ) ); }
                    }

                    else
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            idx + 1,
                            &path,
                            self.options,
                        );
                    }
                }
            }
        }
    }
    /// A pattern parsing error.
    #[derive( Debug )]
    pub struct PatternError
    {
        /// The approximate character index of where the error occurred.
        pub pos: usize,
        /// A message describing the error.
        pub msg: &'static str,
    }

    impl Error for PatternError
    {
        fn description( &self ) -> &str { self.msg }
    }

    impl fmt::Display for PatternError
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            write!
            (
                f,
                "Pattern syntax error near position {}: {}",
                self.pos, self.msg
            )
        }
    }
    /// A compiled Unix shell style pattern.
    #[derive( Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub struct Pattern
    {
        original: String,
        tokens: Vec<PatternToken>,
        is_recursive: bool,
        has_metachars: bool,
    }
    /// Show the original glob pattern.
    impl fmt::Display for Pattern
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result { self.original.fmt( f) }
    }

    impl FromStr for Pattern
    {
        type Err = PatternError;
        fn from_str( s:&str ) -> Result<Self, PatternError> { Self::new( s ) }
    }

    #[derive( Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub enum PatternToken
    {
        Char( char ),
        AnyChar,
        AnySequence,
        AnyRecursiveSequence,
        AnyWithin( Vec<CharSpecifier> ),
        AnyExcept( Vec<CharSpecifier> ),
    } pub use self::PatternToken::{ AnyChar, AnyExcept, AnyRecursiveSequence, AnySequence, AnyWithin, Char };

    #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub enum CharSpecifier
    {
        SingleChar( char ),
        CharRange( char, char ),
    } pub use self::CharSpecifier::{CharRange, SingleChar};

    #[derive( Clone, Copy, PartialEq )]
    pub enum MatchResult
    {
        Match,
        SubPatternDoesntMatch,
        EntirePatternDoesntMatch,
    } pub use self::MatchResult::{ EntirePatternDoesntMatch, Match, SubPatternDoesntMatch };

    impl Pattern
    {
        /// This function compiles Unix shell style patterns.
        pub fn new( pattern:&str ) -> Result<Self, PatternError>
        {
            let chars = pattern.chars().collect::<Vec<_>>();
            let mut tokens = Vec::new();
            let mut is_recursive = false;
            let mut has_metachars = false;
            let mut i = 0;

            while i < chars.len()
            {
                match chars[i]
                {
                    '?' =>
                    {
                        has_metachars = true;
                        tokens.push(AnyChar );
                        i += 1;
                    }

                    '*' =>
                    {
                        has_metachars = true;

                        let old = i;

                        while i < chars.len() && chars[i] == '*' { i += 1; }

                        let count = i - old;

                        match count.cmp( &2)
                        {
                            Ordering::Greater =>
                            {
                                return Err( PatternError
                                {
                                    pos: old + 2,
                                    msg: ERROR_WILDCARDS,
                                })
                            }

                            Ordering::Equal =>
                            {
                                let is_valid = if i == 2 || path::is_separator( Chars[i - count - 1])
                                {
                                    if i < chars.len() && path::is_separator( Chars[i])
                                    {
                                        i += 1;
                                        true
                                    }
                                    else if i == chars.len() { true }
                                    else
                                    {
                                        return Err( PatternError
                                        {
                                            pos: i,
                                            msg: ERROR_RECURSIVE_WILDCARDS,
                                        });
                                    }
                                }
                                
                                else
                                {
                                    return Err( PatternError
                                    {
                                        pos: old - 1,
                                        msg: ERROR_RECURSIVE_WILDCARDS,
                                    });
                                };

                                if is_valid
                                {
                                    let tokens_len = tokens.len();

                                    if !( tokens_len > 1 && tokens[tokens_len - 1] == AnyRecursiveSequence )
                                    {
                                        is_recursive = true;
                                        tokens.push(AnyRecursiveSequence );
                                    }
                                }
                            }

                            Ordering::Less => tokens.push(AnySequence ),
                        }
                    }

                    '[' =>
                    {
                        has_metachars = true;

                        if i + 4 <= chars.len() && chars[i + 1] == '!'
                        {
                            match chars[i + 3..].iter().position(|x| *x == ']') 
                            {
                                None => (),
                                Some(j) => {
                                    let chars = &chars[i + 2..i + 3 + j];
                                    let cs = parse_char_specifiers( Chars );
                                    tokens.push(AnyExcept( Cs  ) );
                                    i += j + 4;
                                    continue;
                                }
                            }
                        }
                        
                        else if i + 3 <= chars.len() && chars[i + 1] != '!'
                        {
                            match chars[i + 2..].iter().position(|x| *x == ']')
                            {
                                None => (),
                                Some(j) => {
                                    let cs = parse_char_specifiers( &chars[i + 1..i + 2 + j]);
                                    tokens.push(AnyWithin( Cs  ) );
                                    i += j + 3;
                                    continue;
                                }
                            }
                        }
                        
                        return Err( PatternError {
                            pos: i,
                            msg: ERROR_INVALID_RANGE,
                        });
                    }

                    c =>
                    {
                        tokens.push( Char( c  ) );
                        i += 1;
                    }
                }
            }

            Ok(Self
            {
                tokens,
                original: pattern.to_string(),
                is_recursive,
                has_metachars,
            })
        }
        /// Escape metacharacters within the given string by surrounding them in brackets.
        pub fn escape( s:&str ) -> String
        {
            let mut escaped = String::new();
            for c in s.chars()
            {
                match c
                {
                    '?' | '*' | '[' | ']' => {
                        escaped.push('[');
                        escaped.push( c );
                        escaped.push(']');
                    }
                    c => {
                        escaped.push( c );
                    }
                }
            }
            escaped
        }
        /// Return if the given `str` matches this `Pattern` using the default match options.
        pub fn matches( &self, str:&str ) -> bool { self.matches_with( str, MatchOptions::new() ) }
        /// Return if the given `Path`, when converted to a `str`, matches this
        /// `Pattern` using the default match options (i.e. `MatchOptions::new()`).
        pub fn matches_path( &self, path:&Path ) -> bool { path.to_str().map_or( false, |s| self.matches( s ) ) }
        /// Return if the given `str` matches this `Pattern` using the specified match options.
        pub fn matches_with( &self, str: &str, options:MatchOptions ) -> bool
        { self.matches_from( true, str.chars(), 0, options ) == Match }
        /// Return if the given `Path` matches this `Pattern` using the specified match options.
        pub fn matches_path_with( &self, path: &Path, options: MatchOptions ) -> bool
        {
            path.to_str().map_or( false, |s| self.matches_with( s, options ) )
        }
        /// Access the original glob pattern.
        pub fn as_str( &self ) -> &str { &self.original }

        fn matches_from
        (
            &self,
            mut follows_separator: bool,
            mut file: ::str::Chars,
            i: usize,
            options: MatchOptions,
        ) -> MatchResult
        {
            for ( ti, token ) in self.tokens[i..].iter().enumerate()
            {
                match *token
                {
                    AnySequence | AnyRecursiveSequence =>
                    {
                        debug_assert!(match *token
                        {
                            AnyRecursiveSequence => follows_separator,
                            _ => true,
                        });
                        
                        match self.matches_from( follows_separator, file.clone(), i + ti + 1, options )
                        {
                            SubPatternDoesntMatch => (),
                            m => return m,
                        };

                        while let Some( c ) = file.next()
                        {
                            if follows_separator && options.require_literal_leading_dot && c == '.'
                            { return SubPatternDoesntMatch; }

                            follows_separator = path::is_separator( c );
                            
                            match *token
                            {
                                AnyRecursiveSequence if !follows_separator => continue,
                                AnySequence if options.require_literal_separator && follows_separator =>
                                { return SubPatternDoesntMatch }
                                _ => (),
                            }

                            match self.matches_from
                            (
                                follows_separator,
                                file.clone(),
                                i + ti + 1,
                                options,
                            )
                            {
                                SubPatternDoesntMatch => (),
                                m => return m,
                            }
                        }
                    }
                    
                    _ =>
                    {
                        let c = match file.next()
                        {
                            Some( c ) => c,
                            None => return EntirePatternDoesntMatch,
                        };

                        let is_sep = path::is_separator( c );

                        if !match *token
                        {
                            AnyChar       |
                            AnyWithin(..) |
                            AnyExcept(..) if (options.require_literal_separator && is_sep) ||
                            ( follows_separator && options.require_literal_leading_dot && c == '.' ) => { false }
                            AnyChar => true,
                            AnyWithin( ref specifiers ) => in_char_specifiers( specifiers, c, options ),
                            AnyExcept( ref specifiers ) => !in_char_specifiers( specifiers, c, options ),
                            Char( c2 ) => chars_eq( c, c2, options.case_sensitive ),
                            AnySequence | AnyRecursiveSequence => unreachable!(),
                        }
                        { return SubPatternDoesntMatch; }

                        follows_separator = is_sep;
                    }
                }
            }
            
            if file.next().is_none() { Match }
            else { SubPatternDoesntMatch }
        }
    }
    
    fn fill_todo
    (
        todo: &mut Vec<Result<( PathWrapper, usize ), GlobError>>,
        patterns:&[Pattern],
        idx: usize,
        path: &PathWrapper,
        options: MatchOptions,
    )
    {
        let add = | todo:&mut Vec<_>, next_path: PathWrapper |
        {
            if idx + 1 == patterns.len() { todo.push( Ok( ( next_path, usize::MAX ) ) ); }
            else { fill_todo( todo, patterns, idx + 1, &next_path, options ); }
        };

        let pattern = &patterns[idx];
        let is_dir = path.is_directory;
        let curdir = path.as_ref() == Path::new( "." );

        match ( pattern.has_metachars, is_dir )
        {
            ( false, _ ) =>
            {
                debug_assert!
                (
                    pattern
                    .tokens
                    .iter()
                    .all( | tok | matches!( tok, PatternToken::Char( _ ) ) ),
                    "broken invariant: pattern has metachars but shouldn't"
                );
                
                let s = pattern.as_str();                
                let special = "." == s || ".." == s;
                let next_path = if curdir { PathBuf::from( s ) }
                
                else { path.join( s ) };
                
                let next_path = PathWrapper::from_path( next_path );
                
                if  ( special && is_dir ) ||
                    (!special && ( fs::metadata( &next_path ).is_ok() || fs::symlink_metadata( &next_path ).is_ok() ) )
                    { add( todo, next_path ); }
            }

            ( true, true ) => 
            {
                let dirs = fs::read_dir( path ).and_then(|d| 
                {
                    d.map(| e |
                    {
                        e.map(| e |
                        {
                            let path = if curdir { PathBuf::from( e.path().file_name().unwrap() ) }
                            
                            else { e.path() };

                            PathWrapper::from_dir_entry( path, e )
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
                });

                match dirs
                {
                    Ok( mut children ) =>
                    {
                        if options.require_literal_leading_dot
                        {
                            children.retain(|x| !x.file_name().unwrap().to_str().unwrap().starts_with('.' ) );
                        }

                        children.sort_by(|p1, p2| p2.file_name().cmp( &p1.file_name() ) );
                        todo.extend( Children.into_iter().map(|x| Ok((x, idx ) )  ) );
                        
                        if !pattern.tokens.is_empty() && pattern.tokens[0] == Char('.')
                        {
                            for &special in &[".", ".."]
                            {
                                if pattern.matches_with( special, options )
                                {
                                    add( todo, PathWrapper::from_path( path.join( special ) ) );
                                }
                            }
                        }
                    }

                    Err( e ) =>
                    {
                        todo.push
                        (
                            Err
                            (
                                GlobError
                                {
                                    path: path.to_path_buf(),
                                    error: e
                                }
                            )
                        );
                    }
                }
            }

            ( true, false ) => {}
        }
    }

    fn parse_char_specifiers( s:&[char] ) -> Vec<CharSpecifier>
    {
        let mut cs = Vec::new();
        let mut i = 0;

        while i < s.len()
        {
            if i + 3 <= s.len() && s[i + 1] == '-' {
                cs.push( CharRange( s[i], s[i + 2] ) );
                i += 3;
            } else {
                cs.push(SingleChar( s[i] ) );
                i += 1;
            }
        }

        cs
    }

    fn in_char_specifiers( specifiers:&[CharSpecifier], c:char, options:MatchOptions ) -> bool
    {
        for &specifier in specifiers.iter()
        {
            match specifier
            {
                SingleChar( sc ) =>
                {
                    if chars_eq( c, sc, options.case_sensitive ) { return true; }
                }
                
                CharRange( start, end ) =>
                {
                    if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii()
                    {
                        let start = start.to_ascii_lowercase();
                        let end = end.to_ascii_lowercase();

                        let start_up = start.to_uppercase().next().unwrap();
                        let end_up = end.to_uppercase().next().unwrap();
                        
                        if start != start_up && end != end_up
                        {
                            let c = c.to_ascii_lowercase();
                            if c >= start && c <= end { return true; }
                        }
                    }

                    if c >= start && c <= end { return true; }
                }
            }
        }

        false
    }
    /// A helper function to determine if two chars are ( possibly case-insensitively) equal.
    fn chars_eq( a:char, b:char, case_sensitive:bool ) -> bool 
    {
        if cfg!( windows ) && path::is_separator( a ) && path::is_separator( b ) { true }
        
        else if !case_sensitive && a.is_ascii() && b.is_ascii() { a.eq_ignore_ascii_case( &b ) }

        else { a == b }
    }
    /// Configuration options to modify the behaviour of `Pattern::matches_with(..)`.
    #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub struct MatchOptions
    {
        /// Whether or not patterns should be matched in a case-sensitive manner.
        pub case_sensitive: bool,
        /// Whether path-component separator characters must be matched by a literal `/`
        /// rather than by `*` or `?` or `[...]`.
        pub require_literal_separator: bool,
        /// Whether path-components that start with a `.` will require that `.` appears literally in the pattern;
        /// `*`, `?`, `**`, or `[...]` will not match.
        pub require_literal_leading_dot: bool,
    }

    impl MatchOptions 
    {
        /// Constructs a new `MatchOptions` with default field values.
        pub fn new() -> Self
        {
            Self
            {
                case_sensitive: true,
                require_literal_separator: false,
                require_literal_leading_dot: false,
            }
        }
    }
}

pub mod primitive
{
    pub use std::primitive::{ * };
}

pub mod process
{
    pub use std::process::{ * };

    use ::
    {
        error::no::{ Errno },
        os::fd::{ RawFd },
        system::
        {
            api::
            {
                Result, ForkResult, Pid, c_int
            },
        },
        *,
    };
    /*
    */
    /// Create a new child process duplicating the parent process.
    #[inline] pub unsafe fn fork() -> Result<ForkResult>
    {
        use self::ForkResult::*;
        let res = unsafe { ::system::api::fork() };

        Errno::result( res ).map(|res| match res
        {
            0 => Child,
            res => Parent { child: Pid( res ) },
        })
    }
    
    pub fn pipe() -> Result<(RawFd, RawFd )>
    {
        let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
        let res = unsafe { system::api::pipe( fds.as_mut_ptr() as *mut c_int ) };
        Errno::result( res )?;
        unsafe { Ok(( fds.assume_init()[0], fds.assume_init()[1] ) ) }
    }
}

pub mod prompts
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    use crate::libs;
    use crate::shell;
    */
    pub mod main
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        use std::env;

        use crate::execute;
        use crate::libs;
        use crate::shell;

        const DEFAULT_PROMPT: &str = "${COLOR_STATUS}$USER${RESET}\
            @${COLOR_STATUS}$HOSTNAME${RESET}: \
            ${COLOR_STATUS}$CWD${RESET}$ ";
        use super::preset::apply_preset_item;
        use super::preset::apply_pyenv;
        */
        // pub fn get_prompt_string() -> String
        pub fn read_string() -> String
        {
            if let Ok( x ) = env::var( "PROMPT" ) { return x; }
            DEFAULT_PROMPT.to_string()
        }
        // pub fn apply_prompt_item( sh: &shell::Shell, result: &mut String, token:&str )
        pub fn apply_item( sh: &shell::Shell, result: &mut String, token:&str )
        {
            if let Some( x ) = sh.get_env( token )
            {
                result.push_str( &x);
                return;
            }

            apply_preset_item( sh, result, token );
        }

        pub fn apply_command( result: &mut String, token: &str, prefix: &str, suffix:&str )
        {
            let cr = now::run( token );
            let output = cr.stdout.trim();
            if !output.is_empty()
            {
                result.push_str( prefix);
                result.push_str(output );
                result.push_str( suffix);
            }
        }
        // pub fn render_prompt( sh: &shell::Shell, ps:&str ) -> String
        pub fn render( sh: &shell::Shell, ps:&str ) -> String
        {
            let mut prompt = String::new();
            apply_pyenv( &mut prompt );

            let mut met_dollar = false;
            let mut met_brace = false;
            let mut met_paren = false;
            let mut token = String::new();
            let mut prefix = String::new();
            let mut suffix = String::new();
            for c in ps.chars() {
                if met_dollar {
                    if c == '(' && !met_brace && !met_paren {
                        met_paren = true;
                        continue;
                    }
                    if c == ')' && met_paren {
                        apply_command( &mut prompt, &token, &prefix, &suffix);
                        token.clear();
                        prefix.clear();
                        suffix.clear();
                        met_dollar = false;
                        met_paren = false;
                        continue;
                    }
                    if c == '{' && !met_brace && !met_paren {
                        met_brace = true;
                        continue;
                    } else if c == '}' && met_brace {
                        apply_item( sh, &mut prompt, &token );
                        token.clear();
                        met_dollar = false;
                        met_brace = false;
                        continue;
                    } else if c == '$' {
                        if token.is_empty() {
                            // to make single $ as a plain $
                            prompt.push('$');
                            met_dollar = true;
                            continue;
                        } else {
                            apply_item( sh, &mut prompt, &token );
                            token.clear();
                            // met_dollar is still true
                            continue;
                        }
                    } else if met_paren {
                        if is::prefix_char( c ) {
                            prefix.push( c );
                        } else if is::suffix_char( c ) {
                            suffix.push( c );
                        } else {
                            token.push( c );
                        }
                        continue;
                    } else if is::prompt_item_char( c, &token ) {
                        token.push( c );
                        continue;
                    } else if token.is_empty() {
                        prompt.push('$');
                        prompt.push( c );
                        met_dollar = false;
                        continue;
                    }
                }

                if c == '$' {
                    met_dollar = true;
                    continue;
                }

                if !token.is_empty() {
                    apply_item( sh, &mut prompt, &token );
                    token.clear();
                }
                prompt.push( c );
                met_dollar = false;
            }

            if !token.is_empty() {
                apply_item( sh, &mut prompt, &token );
                met_dollar = false;
            }

            if met_dollar {
                // for cases like PROMPT='$$'
                prompt.push('$');
            }
            /*
            if prompt.trim().is_empty() {
                return format!( "cicada-{} >> ", env!( "CARGO_PKG_VERSION" ) );
            } */
            prompt
        }
    } pub use self::main::{ read_string, render };

    pub mod multilines
    {
        /*!
        */
        use ::
        {
            system::
            {
                function::{ Function },
                prompter::{ Prompter },
                terminal::{ Terminal },
            },
            *,
        };
        /*
        use std::io;
        use crate::parsers::parser_line;
        */
        pub struct EnterFunction;

        impl<T: Terminal> Function<T> for EnterFunction
        {
            fn execute( &self, prompter: &mut Prompter<T>, count: i32, _ch:char ) -> io::Result<()>
            {
                let buf = prompter.buffer();
                let linfo = parser_line::parse_line( buf);
                if linfo.is_complete {
                    prompter.accept_input()
                } else if count > 0 {
                    match prompter.insert( Count as usize, '\n') {
                        Ok(_ ) => {}
                        Err( e ) => {
                            println!( "sub-prompt error: {}", e );
                        }
                    }
                    prompter.insert_str( ">> " )
                } else {
                    Ok(() )
                }
            }
        }
    } pub use self::multilines::{ EnterFunction };

    pub mod preset
    {
        /*!
        */
        use ::
        {
            fs::{ File },
            io::{ Read, Write },
            path::{ Path },
            *,
        };
        /*
        */
        fn apply_seq( prompt: &mut String) {
            prompt.push_str(libs::colored::SEQ);
        }

        fn apply_end_seq( prompt: &mut String) {
            prompt.push_str(libs::colored::END_SEQ);
        }

        fn apply_esc( prompt: &mut String) {
            prompt.push_str(libs::colored::ESC);
        }

        fn apply_underlined( prompt: &mut String) {
            prompt.push_str(libs::colored::UNDERLINED);
        }

        fn apply_user( prompt: &mut String) {
            let username = tools::get_user_name();
            prompt.push_str( &username );
        }

        fn apply_black( prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK);
        }

        fn apply_black_b( prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_B);
        }

        fn apply_black_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_BG);
        }

        fn apply_blue( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE);
        }

        fn apply_blue_b( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_B);
        }

        fn apply_blue_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_BG);
        }

        fn apply_bold( prompt: &mut String) {
            prompt.push_str(libs::colored::BOLD);
        }

        fn apply_green( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN);
        }

        fn apply_green_b( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_B);
        }

        fn apply_green_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_BG);
        }

        fn apply_red( prompt: &mut String) {
            prompt.push_str(libs::colored::RED);
        }

        fn apply_red_b( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_B);
        }

        fn apply_red_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_BG);
        }

        fn apply_white( prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE);
        }

        fn apply_white_b( prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_B);
        }

        fn apply_white_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_BG);
        }

        fn apply_hidden( prompt: &mut String) {
            prompt.push_str(libs::colored::HIDDEN);
        }

        fn apply_reset( prompt: &mut String) {
            prompt.push_str(libs::colored::RESEt );
        }

        fn apply_reverse( prompt: &mut String) {
            prompt.push_str(libs::colored::REVERSE);
        }

        fn apply_dim( prompt: &mut String) {
            prompt.push_str(libs::colored::DIM);
        }

        fn apply_blink( prompt: &mut String) {
            prompt.push_str(libs::colored::BLINK);
        }

        fn apply_reset_underlined( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_UNDERLINED);
        }

        fn apply_reset_dim( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_DIM);
        }

        fn apply_reset_reverse( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_REVERSE);
        }

        fn apply_reset_hidden( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_HIDDEN);
        }

        fn apply_reset_blink( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BLINK);
        }

        fn apply_reset_bold( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BOLD);
        }

        fn apply_default( prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULt );
        }

        fn apply_default_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT_BG);
        }

        fn apply_cyan( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN);
        }

        fn apply_cyan_l( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L);
        }

        fn apply_cyan_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_BG);
        }

        fn apply_cyan_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L_BG);
        }

        fn apply_red_l( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L);
        }

        fn apply_red_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L_BG);
        }

        fn apply_green_l( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L);
        }

        fn apply_green_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L_BG);
        }

        fn apply_gray_l( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L);
        }

        fn apply_gray_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L_BG);
        }

        fn apply_gray_d( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D);
        }

        fn apply_gray_d_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D_BG);
        }

        fn apply_magenta( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA);
        }

        fn apply_magenta_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_BG);
        }

        fn apply_magenta_l( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L);
        }

        fn apply_magenta_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L_BG);
        }

        fn apply_yellow( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW);
        }

        fn apply_yellow_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_BG);
        }

        fn apply_yellow_l( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L);
        }

        fn apply_yellow_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L_BG);
        }

        fn apply_blue_l( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L);
        }

        fn apply_blue_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L_BG);
        }

        fn apply_color_status( sh: &shell::Shell, prompt: &mut String) {
            if sh.previous_status == 0 {
                prompt.push_str(libs::colored::GREEN_B);
            } else {
                prompt.push_str(libs::colored::RED_B);
            }
        }

        fn _find_git_root() -> String {
            let current_dir = libs::path::current_dir();
            let dir_git = format!( "{}/.git", current_dir );
            if Path::new( &dir_git ).exists() {
                return current_dir;
            }

            let mut _dir = current_dir.clone();
            while Path::new( &_dir ).parent().is_some() {
                match Path::new( &_dir ).parent() {
                    Some( p) => {
                        _dir = p.to_string_lossy().to_string();
                        let dir_git = format!( "{}/.git", _dir );
                        if Path::new( &dir_git ).exists() {
                            return _dir;
                        }
                    }
                    None => {
                        break;
                    }
                }
            }

            String::new()
        }

        fn apply_gitbr( prompt: &mut String) {
            let git_root = _find_git_root();
            if git_root.is_empty() {
                return;
            }

            let file_head = format!( "{}/.git/HEAD", git_root );
            if !Path::new( &file_head ).exists() {
                return;
            }

            let mut file;
            match File::open( &file_head ) {
                Ok( x ) => file = x,
                Err( e ) => {
                    println!( ":: .git/HEAD err: {:?}", e );
                    return;
                }
            }
            let mut text = String::new();
            match file.read_to_string( &mut text ) {
                Ok(_ ) => {}
                Err( e ) => {
                    println!( ":: read_to_string error: {:?}", e );
                    return;
                }
            }

            if let Some( branch ) = regex::find_first_group( r"^[a-z]+: ?[a-z]+/[a-z]+/(.+)$", text.trim() )
            {
                apply_blue_b( prompt );
                if let Ok( x ) = env::var( "CICADA_GITBR_PREFIX" ) {
                    prompt.push_str( &x);
                }

                let _len_default: i32 = 32;
                let mut len_max = if let Ok( x ) = env::var( "CICADA_GITBR_MAX_LEN" ) {
                    match x.parse::<i32>() {
                        Ok( n ) => n,
                        Err(_ ) => _len_default,
                    }
                } else {
                    _len_default
                };
                if len_max <= 0 {
                    len_max = _len_default;
                }

                if branch.len() as i32 <= len_max {
                    prompt.push_str( &branch );
                } else {
                    let len = branch.len() as i32;
                    let offset = (len - len_max + 2) as usize;
                    let branch_short = format!( "..{}", &branch[offset..]);
                    prompt.push_str( &branch_short );
                }
                if let Ok( x ) = env::var( "CICADA_GITBR_SUFFIX" ) {
                    prompt.push_str( &x);
                }
                apply_reset( prompt );
            }
        }

        pub fn apply_cwd( prompt: &mut String)
        {
            let _current_dir = match env::current_dir()
            {
                Ok( x ) => x,
                Err( e ) =>
                {
                    println_stderr!( ":: PROMPT: env current_dir error: {}", e );
                    return;
                }
            };

            let current_dir = match _current_dir.to_str()
            {
                Some( x ) => x,
                None =>
                {
                    println_stderr!( ":: PROMPT: to_str error" );
                    return;
                }
            };
            
            let _tokens: Vec<&str> = current_dir.split('/').collect();

            let last = match _tokens.last()
            {
                Some( x ) => x,
                None =>
                {
                    //log!( ":: PROMPT: token last error" );
                    return;
                }
            };

            let home = get::user_home();
            let pwd = if last.is_empty() { "/" }
            else if current_dir == home { "~" }

            else { last };

            prompt.push_str( pwd );
        }

        pub fn apply_hostname( prompt: &mut String)
        {
            let hostname = tools::get_hostname();
            prompt.push_str( &hostname );
        }

        pub fn apply_newline( prompt: &mut String) { prompt.push('\n'); }

        pub fn apply_pyenv( prompt: &mut String)
        {
            if let Ok( x ) = env::var( "VIRTUAL_ENV" )
            {
                if !x.is_empty()
                {
                    let _tokens: Vec<&str> = x.split('/').collect();
                    let env_name = match _tokens.last()
                    {
                        Some( x ) => x,
                        None =>
                        {
                            //log!( "prompt token last error" );
                            return;
                        }
                    };

                    apply_blue_b( prompt );
                    prompt.push('(');
                    prompt.push_str(env_name );
                    prompt.push(')');
                    apply_reset( prompt );
                }
            }
        }

        pub fn apply_preset_item( sh: &shell::Shell, prompt: &mut String, token:&str )
        {
            match token.to_ascii_lowercase().as_ref()
            {
                "black" => apply_black( prompt ),
                "black_b" => apply_black_b( prompt ),
                "black_bg" => apply_black_bg( prompt ),
                "blink" => apply_blink( prompt ),
                "blue" => apply_blue( prompt ),
                "blue_b" => apply_blue_b( prompt ),
                "blue_bg" => apply_blue_bg( prompt ),
                "blue_l" => apply_blue_l( prompt ),
                "blue_l_bg" => apply_blue_l_bg( prompt ),
                "bold" => apply_bold( prompt ),
                "color_status" => apply_color_status( sh, prompt ),
                "cwd" => apply_cwd( prompt ),
                "cyan" => apply_cyan( prompt ),
                "cyan_bg" => apply_cyan_bg( prompt ),
                "cyan_l" => apply_cyan_l( prompt ),
                "cyan_l_bg" => apply_cyan_l_bg( prompt ),
                "default" => apply_default( prompt ),
                "default_bg" => apply_default_bg( prompt ),
                "dim" => apply_dim( prompt ),
                "end_seq" => apply_end_seq( prompt ),
                "esc" => apply_esc( prompt ),
                "gitbr" => apply_gitbr( prompt ),
                "gray_d" => apply_gray_d( prompt ),
                "gray_d_bg" => apply_gray_d_bg( prompt ),
                "gray_l" => apply_gray_l( prompt ),
                "gray_l_bg" => apply_gray_l_bg( prompt ),
                "green" => apply_green( prompt ),
                "green_b" => apply_green_b( prompt ),
                "green_bg" => apply_green_bg( prompt ),
                "green_l" => apply_green_l( prompt ),
                "green_l_bg" => apply_green_l_bg( prompt ),
                "hidden" => apply_hidden( prompt ),
                "hostname" => apply_hostname( prompt ),
                "magenta" => apply_magenta( prompt ),
                "magenta_bg" => apply_magenta_bg( prompt ),
                "magenta_l" => apply_magenta_l( prompt ),
                "magenta_l_bg" => apply_magenta_l_bg( prompt ),
                "newline" => apply_newline( prompt ),
                "red" => apply_red( prompt ),
                "red_b" => apply_red_b( prompt ),
                "red_bg" => apply_red_bg( prompt ),
                "red_l" => apply_red_l( prompt ),
                "red_l_bg" => apply_red_l_bg( prompt ),
                "reset" => apply_reset( prompt ),
                "reset_blink" => apply_reset_blink( prompt ),
                "reset_bold" => apply_reset_bold( prompt ),
                "reset_dim" => apply_reset_dim( prompt ),
                "reset_hidden" => apply_reset_hidden( prompt ),
                "reset_reverse" => apply_reset_reverse( prompt ),
                "reset_underlined" => apply_reset_underlined( prompt ),
                "reverse" => apply_reverse( prompt ),
                "seq" => apply_seq( prompt ),
                "underlined" => apply_underlined( prompt ),
                "user" => apply_user( prompt ),
                "white" => apply_white( prompt ),
                "white_b" => apply_white_b( prompt ),
                "white_bg" => apply_white_bg( prompt ),
                "yellow" => apply_yellow( prompt ),
                "yellow_bg" => apply_yellow_bg( prompt ),
                "yellow_l" => apply_yellow_l( prompt ),
                "yellow_l_bg" => apply_yellow_l_bg( prompt ),
                _ => (),
            }
        }
    }
    // pub fn get_prompt( sh: &shell::Shell) -> String
    pub fn read( sh: &shell::Shell) -> String
    {
        let ps = read_string();
        let mut prompt = render( sh, &ps );
        if let Some((w, _h ) ) = libs::term_size::dimensions() {
            if get::prompt_len( &prompt ) > (w / 2) as i32
                && !regex::contains( &ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str( "\n$ " );
            }
        } else {
            log!( "ERROR: Failed to get term size" );
        }
        prompt
    }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod rc
{
    pub use std::rc::{ * };

    pub mod file
    {
        /*!
        */
        use ::
        {
            path::{ Path },
            *,
        };
        /*
        */
        pub fn read() -> String
        {
            let dir_config = tools::get_config_dir();
            let rc_file = format!( "{}/cicadarc", dir_config);
            if Path::new( &rc_file ).exists() {
                return rc_file;
            }

            // fail back to $HOME/.cicadarc
            let home = tools::get_user_home();
            let rc_file_home = format!( "{}/{}", home, ".cicadarc" );
            if Path::new( &rc_file_home ).exists() {
                return rc_file_home;
            }

            // use std path if both absent
            rc_file
        }
        // pub fn load_rc_files( sh: &mut shell::Shell)
        pub fn run( sh: &mut shell::Shell)
        {
            let rc_file = get_rc_file();
            if !Path::new( &rc_file ).exists() {
                return;
            }

            let args = vec!["source".to_string(), rc_file];
            scripting::run_script( sh, &args );
        }
    }
}

pub mod regex
{
    /*!
    Provides routines for searching strings for matches of a [regular expression] (aka "regex"). */
    pub use re::{ * };
    use ::
    {
        *,
    };
    /*
    #![no_std]
    #![deny(missing_docs)]
    #![cfg_attr(feature = "pattern", feature(pattern))]
    // This adds Cargo feature annotations to items in the rustdoc output. Which is
    // sadly hugely beneficial for this crate due to the number of features.
    #![cfg_attr(docsrs_regex, feature(doc_cfg))]
    #![warn(missing_debug_implementations)]

    #[cfg(doctest)]
    doc_comment::doctest!("../README.md");

    extern crate alloc;
    #[cfg(any(test, feature = "std"))]
    extern crate std;

    pub use crate::error::Error;

    pub use crate::{builders::string::*, regex::string::*, regexset::string::*};

    mod builders;
    pub mod bytes;
    mod error;
    mod find_byte;
    #[cfg(feature = "pattern")]
    mod pattern;
    mod regex;
    mod regexset;
    
    pub mod __
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
    }
    */
    pub mod syntax
    {
        /*!
        This crate provides a robust regular expression parser. */
        use ::
        {
            *,
        };
        /*
        #![no_std]
        #![forbid(unsafe_code)]
        #![deny(missing_docs, rustdoc::broken_intra_doc_links)]
        #![warn(missing_debug_implementations)]
        // This adds Cargo feature annotations to items in the rustdoc output. Which is
        // sadly hugely beneficial for this crate due to the number of features.
        #![cfg_attr(docsrs_regex, feature(doc_cfg))]

        #[cfg(any(test, feature = "std"))]
        extern crate std;

        extern crate alloc;

        pub use crate::{
            error::Error,
            parser::{parse, Parser, ParserBuilder},
            unicode::UnicodeWordError,
        };

        use alloc::string::String;

        pub mod ast;
        mod debug;
        mod either;
        mod error;
        pub mod hir;
        mod parser;
        mod rank;
        mod unicode;
        mod unicode_tables;
        pub mod utf8;
        */
        pub mod unicode
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use alloc::
            {
                string::{String, ToString},
                vec::Vec,
            };

            use crate::hir;
            */
            pub mod tables
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub mod age
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                    pub const BY_NAME: &'static [(&'static str, &'static [(char, char)])] = 
                    &[
                        ("V10_0",V10_0),("V11_0",V11_0),("V12_0",V12_0),("V12_1",V12_1),("V13_0",V13_0),("V14_0",V14_0),("V15_0",V15_0),("V15_1",V15_1),
                        ("V16_0",V16_0),("V1_1",V1_1),("V2_0",V2_0),("V2_1",V2_1),("V3_0",V3_0),("V3_1",V3_1),("V3_2",V3_2),("V4_0",V4_0),("V4_1",V4_1),
                        ("V5_0",V5_0),("V5_1",V5_1),("V5_2",V5_2),("V6_0",V6_0),("V6_1",V6_1),("V6_2",V6_2),("V6_3",V6_3),("V7_0",V7_0),("V8_0",V8_0),
                        ("V9_0",V9_0),
                    ];

                    pub const V10_0: &'static [(char, char)] =  
                    &[
                        ('',''),('',''),('\u{afa}','\u{aff}'),('\u{d00}','\u{d00}'),('\u{d3b}','\u{d3c}'),('',''),('\u{1df6}','\u{1df9}'),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('','\u{11a47}'),('',''),('',''),('',''),('',''),('',''),
                        ('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d47}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),
                    ];
                    
                    pub const V11_0: &'static [(char, char)] = 
                    &[
                        ('',''),('',''),('',''),('\u{7fd}',''),('\u{8d3}','\u{8d3}'),('\u{9fe}','\u{9fe}'),('',''),('\u{c04}','\u{c04}'),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{a8ff}'),
                        ('',''),('',''),('','\u{10d27}'),('',''),('',''),('',''),('\u{110cd}','\u{110cd}'),('',''),('\u{1133b}','\u{1133b}'),
                        ('\u{1145e}','\u{1145e}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                    ];
                    
                    pub const V12_0: &'static [(char, char)] = 
                    &[
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{eba}','\u{eba}'),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{119d7}'),('\u{119da}',''),
                        ('',''),('',''),('',''),('\u{13430}','\u{13438}'),('',''),('\u{16f4f}','\u{16f4f}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('\u{1e130}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),
                    ];
                    
                    pub const V12_1: &'static [(char, char)] = &[('','')];
                    
                    pub const V13_0: &'static [(char, char)] = 
                    &[
                        ('',''),('\u{b55}','\u{b55}'),('',''),('\u{d81}','\u{d81}'),('\u{1abf}','\u{1ac0}'),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('\u{a82c}','\u{a82c}'),('',''),('',''),('',''),('\u{10eab}',''),('',''),('',''),
                        ('',''),('','\u{111cf}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}',''),
                        ('',''),('',''),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                    ];
                    
                    pub const V14_0: &'static [(char, char)] = 
                    &[
                        ('',''),('',''),('\u{890}','\u{891}'),('\u{898}','\u{89f}'),('',''),('','\u{8d2}'),('\u{c3c}','\u{c3c}'),('',''),
                        ('',''),('',''),('\u{1715}','\u{1715}'),('',''),('\u{180f}','\u{180f}'),('\u{1ac1}','\u{1ace}'),('',''),('',''),
                        ('\u{1dfa}','\u{1dfa}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('\u{11070}',''),('\u{110c2}','\u{110c2}'),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('',''),('',''),
                        ('',''),('','\u{1e2ae}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                    ];
                    
                    pub const V15_0: &'static [(char, char)] = 
                    &[
                        ('',''),('\u{ece}','\u{ece}'),('\u{10efd}','\u{10eff}'),('','\u{11241}'),('',''),('\u{11f00}',''),('','\u{11f3a}'),('',''),('',''),('\u{13439}','\u{13455}'),('',''),
                        ('',''),('',''),('',''),('',''),('\u{1e08f}','\u{1e08f}'),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),
                    ];

                    pub const V15_1: &'static [(char, char)] = &[('',''),('',''),('','')];

                    pub const V16_0: &'static [(char, char)] = 
                    &[
                        ('\u{897}','\u{897}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('\u{10d69}',''),('',''),('',''),('\u{10efc}','\u{10efc}'),('',''),
                        ('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),
                        ('\u{113c7}',''),('',''),('',''),('\u{113e1}','\u{113e2}'),('',''),('',''),('',''),
                        ('\u{11f5a}','\u{11f5a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),
                    ];
                    
                    pub const V1_1: &'static [(char, char)] = 
                    &[
                        ('\0',''),('',''),('',''),('',''),('',''),('\u{300}','\u{345}'),('\u{360}','\u{361}'),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{486}'),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('\u{5b0}','\u{5b9}'),('\u{5bb}',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('','\u{652}'),('',''),('\u{670}',''),('',''),('',''),
                        ('','\u{6ed}'),('',''),('\u{901}',''),('',''),('\u{93c}','\u{94d}'),('','\u{954}'),
                        ('',''),('\u{981}',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9c4}'),('',''),('','\u{9cd}'),('\u{9d7}','\u{9d7}'),
                        ('',''),('','\u{9e3}'),('',''),('\u{a02}','\u{a02}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),
                        ('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('',''),('',''),('',''),('\u{a81}',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{abc}','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('',''),('',''),('',''),
                        ('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{b3c}','\u{b43}'),('',''),('','\u{b4d}'),('\u{b56}','\u{b57}'),('',''),('',''),
                        ('',''),('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),
                        ('','\u{bcd}'),('\u{bd7}','\u{bd7}'),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('\u{c3e}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),
                        ('\u{c55}','\u{c56}'),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),
                        ('\u{cd5}','\u{cd6}'),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('\u{d3e}','\u{d43}'),('',''),('','\u{d4d}'),
                        ('\u{d57}','\u{d57}'),('',''),('',''),('','\u{e3a}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('','\u{eb9}'),('\u{ebb}',''),('',''),('',''),('\u{ec8}','\u{ecd}'),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('\u{2000}','\u{202e}'),('',''),
                        ('\u{206a}',''),('',''),('',''),('\u{20d0}','\u{20e1}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{3000}',''),('',''),('',''),
                        ('\u{3099}',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{e000}',''),('',''),('',''),('\u{fb1e}',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{fe20}','\u{fe23}'),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('\u{feff}','\u{feff}'),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('','\u{ffff}'),
                    ];
                    
                    pub const V2_0: &'static [(char, char)] = 
                    &[
                        ('\u{591}','\u{5a1}'),('\u{5a3}','\u{5af}'),('\u{5c4}','\u{5c4}'),('',''),('',''),
                        ('\u{f71}',''),('\u{f90}','\u{f95}'),('\u{f97}','\u{f97}'),('\u{f99}','\u{fad}'),
                        ('\u{fb1}','\u{fb7}'),('\u{fb9}','\u{fb9}'),('',''),('',''),('',''),
                        ('\u{1fffe}','\u{1ffff}'),('\u{2fffe}','\u{2ffff}'),('\u{3fffe}','\u{3ffff}'),
                        ('\u{4fffe}','\u{4ffff}'),('\u{5fffe}','\u{5ffff}'),('\u{6fffe}','\u{6ffff}'),
                        ('\u{7fffe}','\u{7ffff}'),('\u{8fffe}','\u{8ffff}'),('\u{9fffe}','\u{9ffff}'),
                        ('\u{afffe}','\u{affff}'),('\u{bfffe}','\u{bffff}'),('\u{cfffe}','\u{cffff}'),
                        ('\u{dfffe}','\u{dffff}'),('\u{efffe}','\u{10ffff}'),
                    ];

                    pub const V2_1: &'static [(char, char)] = &[('',''),('','')];

                    pub const V3_0: &'static [(char, char)] = &
                    [
                        ('',''),('',''),('',''),('',''),('',''),('',''),('\u{346}','\u{34e}'),
                        ('\u{362}','\u{362}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('\u{488}','\u{489}'),('',''),('',''),('',''),('\u{653}','\u{655}'),
                        ('',''),('',''),('',''),('',''),('',''),('\u{70f}',''),('\u{730}','\u{74a}'),
                        ('','\u{7b0}'),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),
                        ('',''),('\u{f96}','\u{f96}'),('\u{fae}','\u{fb0}'),('\u{fb8}','\u{fb8}'),('\u{fba}','\u{fbc}'),
                        ('',''),('',''),('',''),('',''),('',''),('','\u{1032}'),('\u{1036}','\u{1039}'),
                        ('','\u{1059}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('\u{1680}',''),('',''),('',''),('',''),
                        ('','\u{180e}'),('',''),('',''),('','\u{18a9}'),('\u{202f}','\u{202f}'),('',''),('',''),
                        ('\u{20e2}','\u{20e3}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('\u{fff9}','\u{fffb}'),
                    ];

                    pub const V3_1: &'static [(char, char)] = &
                    [
                        ('',''),('\u{fdd0}','\u{fdef}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{e0001}','\u{e0001}'),('\u{e0020}','\u{e007f}'),
                    ];

                    pub const V3_2: &'static [(char, char)] = &
                    [
                        ('',''),('\u{34f}','\u{34f}'),('\u{363}','\u{36f}'),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1714}'),('',''),('','\u{1753}'),
                        ('',''),('',''),('\u{1772}','\u{1773}'),('',''),('',''),('',''),('\u{205f}','\u{2063}'),
                        ('',''),('',''),('\u{20e4}','\u{20ea}'),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{fe00}','\u{fe0f}'),('',''),('',''),('',''),
                    ];

                    pub const V4_0: &'static [(char, char)] = &
                    [
                        ('',''),('',''),('',''),('',''),('\u{350}','\u{357}'),('\u{35d}','\u{35f}'),('',''),('\u{600}','\u{603}'),
                        ('','\u{615}'),('\u{656}','\u{658}'),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{a01}','\u{a01}'),('',''),('',''),('','\u{ae3}'),('',''),('',''),('',''),('',''),
                        ('\u{cbc}',''),('\u{17dd}','\u{17dd}'),('',''),('',''),('\u{1920}',''),('','\u{193b}'),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0100}','\u{e01ef}'),
                    ];

                    pub const V4_1: &'static [(char, char)] = &
                    [
                        ('',''),('\u{358}','\u{35c}'),('',''),('',''),('\u{5a2}','\u{5a2}'),('\u{5c5}','\u{5c7}'),('',''),('',''),
                        ('\u{659}','\u{65e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{135f}',''),('',''),
                        ('',''),('',''),('',''),('',''),('','\u{1a1b}'),('',''),('','\u{1dc3}'),('',''),('',''),('',''),
                        ('',''),('\u{20eb}','\u{20eb}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10a03}'),('\u{10a05}','\u{10a06}'),
                        ('\u{10a0c}',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}',''),('',''),('',''),('',''),
                    ];

                    pub const V5_0: &'static [(char, char)] = &
                    [
                        ('',''),('',''),('',''),('',''),('',''),('\u{5ba}','\u{5ba}'),('',''),('',''),('',''),('\u{ce2}','\u{ce3}'),
                        ('',''),('\u{1b00}',''),('',''),('\u{1dc4}','\u{1dca}'),('\u{1dfe}','\u{1dff}'),('\u{20ec}','\u{20ef}'),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),
                    ];

                    pub const V5_1: &'static [(char, char)] = &
                    [
                        ('',''),('',''),('',''),('\u{487}','\u{487}'),('',''),('',''),('\u{616}','\u{61a}'),('',''),
                        ('',''),('',''),('\u{a51}','\u{a51}'),('\u{a75}','\u{a75}'),('\u{b44}','\u{b44}'),('\u{b62}','\u{b63}'),
                        ('',''),('',''),('',''),('\u{c62}','\u{c63}'),('',''),('',''),('\u{d44}','\u{d44}'),
                        ('\u{d62}','\u{d63}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{1033}','\u{1035}'),('\u{103a}',''),('',''),('',''),('',''),('\u{1b80}','\u{1baa}'),('',''),
                        ('','\u{1c37}'),('',''),('',''),('\u{1dcb}','\u{1de6}'),('',''),('',''),('\u{2064}','\u{2064}'),
                        ('\u{20f0}','\u{20f0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{2de0}','\u{2dff}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('\u{a67c}',''),('',''),('',''),('',''),
                        ('','\u{a8c4}'),('',''),('','\u{a953}'),('',''),('','\u{aa36}'),('',''),('',''),('',''),
                        ('\u{fe24}','\u{fe26}'),('',''),('','\u{101fd}'),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),
                    ];

                    pub const V5_2: &'static [(char, char)] = &
                    [
                        ('',''),('','\u{82d}'),('',''),('\u{900}','\u{900}'),('',''),('\u{955}','\u{955}'),('',''),('',''),('',''),
                        ('','\u{109d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1a5e}'),
                        ('\u{1a60}','\u{1a7c}'),('\u{1a7f}',''),('',''),('',''),('\u{1cd0}',''),('\u{1dfd}','\u{1dfd}'),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('','\u{2cf1}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a8e0}',''),('',''),
                        ('\u{a980}',''),('',''),('',''),('',''),('',''),('',''),('','\u{abed}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{11080}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                    ];

                    pub const V6_0: &'static [(char, char)] = &
                    [
                        ('',''),('',''),('\u{65f}','\u{65f}'),('','\u{85b}'),('',''),('\u{93a}',''),('',''),('\u{956}','\u{957}'),('',''),
                        ('',''),('',''),('',''),('',''),('','\u{f8f}'),('',''),('\u{135d}','\u{135e}'),('','\u{1bf3}'),('',''),
                        ('\u{1dfc}','\u{1dfc}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2d7f}','\u{2d7f}'),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),
                    ];

                    pub const V6_1: &'static [(char, char)] = &
                    [
                        ('',''),('\u{604}','\u{604}'),('',''),('',''),('\u{8e4}','\u{8fe}'),('',''),('',''),('',''),('',''),('',''),
                        ('\u{1bab}','\u{1bad}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('\u{a674}','\u{a67b}'),('\u{a69f}','\u{a69f}'),('',''),('',''),('',''),('','\u{aaf6}'),('',''),('',''),
                        ('',''),('',''),('',''),('\u{11100}','\u{11134}'),('',''),('\u{11180}',''),('',''),('','\u{116b7}'),('',''),('',''),
                        ('',''),('\u{16f8f}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),
                    ];

                    pub const V6_2: &'static [(char, char)] = &[('','')];

                    pub const V6_3: &'static [(char, char)] = &[('\u{61c}','\u{61c}'),('\u{2066}','\u{2069}')];

                    pub const V7_0: &'static [(char, char)] = &
                    [
                        ('',''),('',''),('',''),('\u{605}','\u{605}'),('',''),('',''),('\u{8ff}','\u{8ff}'),('',''),('',''),
                        ('\u{c00}','\u{c00}'),('',''),('\u{c81}','\u{c81}'),('\u{d01}','\u{d01}'),('',''),('',''),('',''),('\u{1ab0}','\u{1abe}'),
                        ('\u{1cf8}','\u{1cf9}'),('\u{1de7}','\u{1df5}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{aa7c}',''),('',''),('',''),
                        ('\u{fe27}','\u{fe2d}'),('',''),('',''),('\u{102e0}',''),('',''),('','\u{1037a}'),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('','\u{10ae6}'),('',''),('',''),('',''),('',''),('\u{1107f}','\u{1107f}'),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('','\u{112ea}'),('',''),('\u{11301}',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('\u{1133c}',''),('',''),('','\u{1134d}'),('\u{11357}','\u{11357}'),('',''),
                        ('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('',''),('',''),('','\u{115b5}'),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16af0}',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1bca3}'),('',''),('','\u{1e8d6}'),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                    ];

                    pub const V8_0: &'static [(char, char)] = &
                    [
                        ('',''),('\u{8e3}','\u{8e3}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                        ('\u{a69e}','\u{a69e}'),('',''),('',''),('',''),('',''),('',''),('\u{fe2e}','\u{fe2f}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('\u{111c9}','\u{111cc}'),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('\u{11300}','\u{11300}'),('',''),('','\u{115dd}'),('',''),('\u{1171d}','\u{1172b}'),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                    ];

                    pub const V9_0: &'static [(char, char)] = &
                    [
                        ('',''),('\u{8d4}','\u{8e2}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1dfb}','\u{1dfb}'),
                        ('',''),('',''),('',''),('\u{a8c5}','\u{a8c5}'),('',''),('',''),('',''),('\u{1123e}','\u{1123e}'),('',''),('',''),
                        ('',''),('',''),('',''),('','\u{11c36}'),('\u{11c38}',''),('',''),('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),
                        ('',''),('',''),('',''),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),
                        ('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('','\u{1e94a}'),('',''),('',''),('',''),('',''),('',''),
                        ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),
                    ];
                }
            }
            /// An inclusive range of codepoints from a generated file (hence the static lifetime).
            type Range = &'static [(char, char)];
            /// An error that occurs when dealing with Unicode.
            #[derive(Debug)]
            pub enum Error
            {
                PropertyNotFound,
                PropertyValueNotFound,
                PerlClassNotFound,
            }
            /// An error that occurs when Unicode-aware simple case folding fails.
            #[derive(Debug)]
            pub struct CaseFoldError(());
            
            impl ::error::Error for CaseFoldError {}

            impl ::fmt::Display for CaseFoldError
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    write!
                    (
                        f,
                        "Unicode-aware case folding is not available \
                        (probably because the unicode-case feature is not enabled)"
                    )
                }
            }
            /// An error that occurs when the Unicode-aware `\w` class is unavailable.
            #[derive(Debug)]
            pub struct UnicodeWordError(());
            
            impl ::error::Error for UnicodeWordError {}

            impl ::fmt::Display for UnicodeWordError
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    write!
                    (
                        f,
                        "Unicode-aware \\w class is not available \
                        (probably because the unicode-perl feature is not enabled)"
                    )
                }
            }
            /// A state oriented traverser of the simple case folding table.
            #[derive(Debug)]
            pub struct SimpleCaseFolder
            {
                /// The simple case fold table.
                table: &'static [(char, &'static [char])],
                /// The last codepoint that was used for a lookup.
                last: Option<char>,
                /// The index to the entry in `table` corresponding to the smallest key `k`
                /// such that `k > k0`, where `k0` is the most recent key lookup.
                next: usize,
            }

            impl SimpleCaseFolder
            {
                /// Create a new simple case folder.
                pub fn new() -> Result<SimpleCaseFolder, CaseFoldError>
                {
                    Ok(SimpleCaseFolder
                    {
                        table: tables::case_folding_simple::CASE_FOLDING_SIMPLE,
                        last: None,
                        next: 0,
                    })
                }
                /// Return the equivalence class of case folded codepoints for the given codepoint.
                pub fn mapping(&mut self, c: char) -> &'static [char]
                {
                    if let Some(last) = self.last {
                        assert!(
                            last < c,
                            "got codepoint U+{:X} which occurs before \
                            last codepoint U+{:X}",
                            u32::from(c),
                            u32::from(last),
                        );
                    }
                    self.last = Some(c);
                    if self.next >= self.table.len() {
                        return &[];
                    }
                    let (k, v) = self.table[self.next];
                    if k == c {
                        self.next += 1;
                        return v;
                    }
                    match self.get(c) {
                        Err(i) => {
                            self.next = i;
                            &[]
                        }
                        Ok(i) =>
                        {
                            assert!(i > self.next);
                            self.next = i + 1;
                            self.table[i].1
                        }
                    }
                }
                /// Returns true if and only if the given range overlaps with any region
                /// of the underlying case folding table.
                pub fn overlaps(&self, start: char, end: char) -> bool
                {
                    use ::cmp::Ordering;

                    assert!(start <= end);
                    self.table
                        .binary_search_by(|&(c, _)| {
                            if start <= c && c <= end {
                                Ordering::Equal
                            } else if c > end {
                                Ordering::Greater
                            } else {
                                Ordering::Less
                            }
                        })
                        .is_ok()
                }
                /// Returns the index at which `c` occurs in the simple case fold table.
                fn get(&self, c: char) -> Result<usize, usize> { self.table.binary_search_by_key(&c, |&(c1, _)| c1) }
            }
            /// A query for finding a character class defined by Unicode.
            #[derive(Debug)]
            pub enum ClassQuery<'a>
            {
                /// Return a class corresponding to a Unicode binary property, named by a single letter.
                OneLetter(char),
                /// Return a class corresponding to a Unicode binary property.
                Binary(&'a str),
                /// Return a class to all codepoints whose property_name corresponds to the given property_value.
                ByValue
                {
                    /// A property name.
                    property_name: &'a str,
                    /// A property value.
                    property_value: &'a str,
                },
            }

            impl<'a> ClassQuery<'a> 
            {
                fn canonicalize(&self) -> Result<CanonicalClassQuery, Error> 
                {
                    match *self 
                    {
                        ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),
                        ClassQuery::Binary(name) => self.canonical_binary(name),
                        ClassQuery::ByValue { property_name, property_value } => {
                            let property_name = symbolic_name_normalize(property_name);
                            let property_value = symbolic_name_normalize(property_value);

                            let canon_name = match canonical_prop(&property_name)? {
                                None => return Err(Error::PropertyNotFound),
                                Some(canon_name) => canon_name,
                            };
                            Ok(match canon_name {
                                "General_Category" => {
                                    let canon = match canonical_gencat(&property_value)? {
                                        None => return Err(Error::PropertyValueNotFound),
                                        Some(canon) => canon,
                                    };
                                    CanonicalClassQuery::GeneralCategory(canon)
                                }
                                "Script" => {
                                    let canon = match canonical_script(&property_value)? {
                                        None => return Err(Error::PropertyValueNotFound),
                                        Some(canon) => canon,
                                    };
                                    CanonicalClassQuery::Script(canon)
                                }
                                _ => {
                                    let vals = match property_values(canon_name)? {
                                        None => return Err(Error::PropertyValueNotFound),
                                        Some(vals) => vals,
                                    };
                                    let canon_val =
                                        match canonical_value(vals, &property_value) {
                                            None => {
                                                return Err(Error::PropertyValueNotFound)
                                            }
                                            Some(canon_val) => canon_val,
                                        };
                                    CanonicalClassQuery::ByValue {
                                        property_name: canon_name,
                                        property_value: canon_val,
                                    }
                                }
                            })
                        }
                    }
                }

                fn canonical_binary
                (
                    &self,
                    name: &str,
                ) -> Result<CanonicalClassQuery, Error>
                {
                    let norm = symbolic_name_normalize(name);
                    
                    if norm != "cf" && norm != "sc" && norm != "lc" {
                        if let Some(canon) = canonical_prop(&norm)? {
                            return Ok(CanonicalClassQuery::Binary(canon));
                        }
                    }
                    if let Some(canon) = canonical_gencat(&norm)? {
                        return Ok(CanonicalClassQuery::GeneralCategory(canon));
                    }
                    if let Some(canon) = canonical_script(&norm)? {
                        return Ok(CanonicalClassQuery::Script(canon));
                    }
                    Err(Error::PropertyNotFound)
                }
            }
            /// Like ClassQuery, but its parameters have been canonicalized.
            #[derive(Debug, Eq, PartialEq)]
            enum CanonicalClassQuery 
            {
                /// The canonical binary property name.
                Binary(&'static str),
                /// The canonical general category name.
                GeneralCategory(&'static str),
                /// The canonical script name.
                Script(&'static str),
                /// An arbitrary association between canonicalized properties and values.
                ByValue
                {
                    /// The canonical property name.
                    property_name: &'static str,
                    /// The canonical property value.
                    property_value: &'static str,
                },
            }
            /// Looks up a Unicode class given a query. If one doesn't exist, then `None` is returned.
            pub fn class(query: ClassQuery<'_>) -> Result<hir::ClassUnicode, Error>
            {
                use self::CanonicalClassQuery::*;

                match query.canonicalize()? {
                    Binary(name) => bool_property(name),
                    GeneralCategory(name) => gencat(name),
                    Script(name) => script(name),
                    ByValue { property_name: "Age", property_value } => {
                        let mut class = hir::ClassUnicode::empty();
                        for set in ages(property_value)? {
                            class.union(&hir_class(set));
                        }
                        Ok(class)
                    }
                    ByValue { property_name: "Script_Extensions", property_value } => {
                        script_extension(property_value)
                    }
                    ByValue {
                        property_name: "Grapheme_Cluster_Break",
                        property_value,
                    } => gcb(property_value),
                    ByValue { property_name: "Sentence_Break", property_value } => {
                        sb(property_value)
                    }
                    ByValue { property_name: "Word_Break", property_value } => {
                        wb(property_value)
                    }
                    _ => {
                        // What else should we support?
                        Err(Error::PropertyNotFound)
                    }
                }
            }
            /// Returns a Unicode aware class for \w.
            pub fn perl_word() -> Result<hir::ClassUnicode, Error> 
            {
                use tables::perl_word::PERL_WORD;
                Ok(hir_class(PERL_WORD))
            }
            /// Returns a Unicode aware class for \s.
            pub fn perl_space() -> Result<hir::ClassUnicode, Error> 
            {
                use tables::property_bool::WHITE_SPACE;
                Ok(hir_class(WHITE_SPACE))
            }
            /// Returns a Unicode aware class for \d.
            pub fn perl_digit() -> Result<hir::ClassUnicode, Error> 
            {
                use tables::general_category::DECIMAL_NUMBER;
                Ok(hir_class(DECIMAL_NUMBER))
            }
            /// Build a Unicode HIR class from a sequence of Unicode scalar value ranges.
            pub fn hir_class(ranges: &[(char, char)]) -> hir::ClassUnicode 
            {
                let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges
                    .iter()
                    .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))
                    .collect();
                hir::ClassUnicode::new(hir_ranges)
            }
            /// Returns true only if the given codepoint is in the `\w` character class.
            pub fn is_word_character(c: char) -> Result<bool, UnicodeWordError>
            {

                if u8::try_from(c).map_or(false, is::word_byte) { return Ok(true); }

                Ok(PERL_WORD
                .binary_search_by(|&(start, end)| 
                {
                    use cmp::Ordering;

                    if start <= c && c <= end {
                        Ordering::Equal
                    } else if start > c {
                        Ordering::Greater
                    } else {
                        Ordering::Less
                    }
                })
                .is_ok())
            }
            /// A mapping of property values for a specific property.
            type PropertyValues = &'static [(&'static str, &'static str)];

            fn canonical_gencat( normalized_value: &str ) -> Result<Option<&'static str>, Error>
            {
                Ok(match normalized_value 
                {
                    "any" => Some("Any"),
                    "assigned" => Some("Assigned"),
                    "ascii" => Some("ASCII"),
                    _ => {
                        let gencats = property_values("General_Category")?.unwrap();
                        canonical_value(gencats, normalized_value)
                    }
                })
            }

            fn canonical_script( normalized_value: &str ) -> Result<Option<&'static str>, Error> 
            {
                let scripts = property_values("Script")?.unwrap();
                Ok(canonical_value(scripts, normalized_value))
            }
            /// Find the canonical property name for the given normalized property name.
            fn canonical_prop( normalized_name: &str ) -> Result<Option<&'static str>, Error>
            {
                use tables::property_names::PROPERTY_NAMES;
                Ok
                (
                    PROPERTY_NAMES
                    .binary_search_by_key(&normalized_name, |&(n, _)| n)
                    .ok()
                    .map(|i| PROPERTY_NAMES[i].1)
                )
            }
            /// Find the canonical property value for the given normalized property value.
            fn canonical_value( vals: PropertyValues, normalized_value: &str ) -> Option<&'static str>
            {
                vals.binary_search_by_key(&normalized_value, |&(n, _)| n)
                .ok()
                .map(|i| vals[i].1)
            }
            /// Return the table of property values for the given property name.
            fn property_values( canonical_property_name: &'static str ) -> Result<Option<PropertyValues>, Error>
            {
                use tables::property_values::PROPERTY_VALUES;
                Ok
                (
                    PROPERTY_VALUES
                    .binary_search_by_key(&canonical_property_name, |&(n, _)| n)
                    .ok()
                    .map(|i| PROPERTY_VALUES[i].1)
                )
            }
            
            fn property_set( name_map: &'static [(&'static str, Range)], canonical: &'static str ) -> Option<Range>
            {
                name_map
                .binary_search_by_key(&canonical, |x| x.0)
                .ok()
                .map(|i| name_map[i].1)
            }
            /// Returns an iterator over Unicode Age sets.
            fn ages(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error>
            {   
                use tables::age;

                const AGES: &[(&str, Range)] = 
                &[
                    ("V1_1", age::V1_1),
                    ("V2_0", age::V2_0),
                    ("V2_1", age::V2_1),
                    ("V3_0", age::V3_0),
                    ("V3_1", age::V3_1),
                    ("V3_2", age::V3_2),
                    ("V4_0", age::V4_0),
                    ("V4_1", age::V4_1),
                    ("V5_0", age::V5_0),
                    ("V5_1", age::V5_1),
                    ("V5_2", age::V5_2),
                    ("V6_0", age::V6_0),
                    ("V6_1", age::V6_1),
                    ("V6_2", age::V6_2),
                    ("V6_3", age::V6_3),
                    ("V7_0", age::V7_0),
                    ("V8_0", age::V8_0),
                    ("V9_0", age::V9_0),
                    ("V10_0", age::V10_0),
                    ("V11_0", age::V11_0),
                    ("V12_0", age::V12_0),
                    ("V12_1", age::V12_1),
                    ("V13_0", age::V13_0),
                    ("V14_0", age::V14_0),
                    ("V15_0", age::V15_0),
                    ("V15_1", age::V15_1),
                    ("V16_0", age::V16_0),
                ];
                assert_eq!(AGES.len(), age::BY_NAME.len(), "ages are out of sync");

                let pos = AGES.iter().position(|&(age, _)| canonical_age == age);
                match pos {
                    None => Err(Error::PropertyValueNotFound),
                    Some(i) => Ok(AGES[..=i].iter().map(|&(_, classes)| classes)),
                }   
            }
            /// Returns the Unicode HIR class corresponding to the given general category.
            fn gencat(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                match canonical_name 
                {
                    "Decimal_Number" => perl_digit(),
                    name => 
                    {
                        use tables::general_category::BY_NAME;
                        match name {
                            "ASCII" => Ok(hir_class(&[('\0','\x7F')])),
                            "Any" => Ok(hir_class(&[('\0','\u{10FFFF}')])),
                            "Assigned" => {
                                let mut cls = gencat("Unassigned")?;
                                cls.negate();
                                Ok(cls)
                            }
                            name => property_set(BY_NAME, name)
                            .map(hir_class)
                            .ok_or(Error::PropertyValueNotFound),
                        }
                    }
                }
            }
            /// Returns the Unicode HIR class corresponding to the given script.
            fn script(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                use tables::script::BY_NAME;
                property_set(BY_NAME, canonical_name)
                .map(hir_class)
                .ok_or(Error::PropertyValueNotFound)   
            }
            /// Returns the Unicode HIR class corresponding to the given script extension.
            fn script_extension( canonical_name: &'static str ) -> Result<hir::ClassUnicode, Error>
            {
                use crate::unicode_tables::script_extension::BY_NAME;
                property_set(BY_NAME, canonical_name)
                .map(hir_class)
                .ok_or(Error::PropertyValueNotFound)
            }
            /// Returns the Unicode HIR class corresponding to the given Unicode boolean property.
            fn bool_property( canonical_name: &'static str ) -> Result<hir::ClassUnicode, Error>
            {

                match canonical_name
                {
                    "Decimal_Number" => perl_digit(),
                    "White_Space" => perl_space(),
                    name =>
                    {
                        use tables::property_bool::BY_NAME;
                        property_set(BY_NAME, name)
                        .map(hir_class)
                        .ok_or(Error::PropertyNotFound)
                    }
                }
            }
            /// Returns the Unicode HIR class corresponding to the given grapheme cluster break property.
            fn gcb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                use tables::grapheme_cluster_break::BY_NAME;
                property_set(BY_NAME, canonical_name)
                .map(hir_class)
                .ok_or(Error::PropertyValueNotFound)
            }
            /// Returns the Unicode HIR class corresponding to the given word break property.
            fn wb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                use tables::word_break::BY_NAME;
                property_set(BY_NAME, canonical_name)
                .map(hir_class)
                .ok_or(Error::PropertyValueNotFound)
            }
            /// Returns the Unicode HIR class corresponding to the given sentence reak property.
            fn sb(canonical_name: &'static str) -> Result<hir::ClassUnicode, Error>
            {
                use tables::sentence_break::BY_NAME;
                property_set(BY_NAME, canonical_name)
                .map(hir_class)
                .ok_or(Error::PropertyValueNotFound)
            }
            /// Like symbolic_name_normalize_bytes, but operates on a string.
            fn symbolic_name_normalize(x: &str) -> String
            {
                let mut tmp = x.as_bytes().to_vec();
                let len = symbolic_name_normalize_bytes(&mut tmp).len();
                tmp.truncate(len);
                String::from_utf8(tmp).unwrap()
            }
            /// Normalize the given symbolic name in place according to UAX44-LM3.
            fn symbolic_name_normalize_bytes(slice: &mut [u8]) -> &mut [u8] 
            {
                let mut start = 0;
                let mut starts_with_is = false;

                if slice.len() >= 2 
                {
                    starts_with_is = slice[0..2] == b"is"[..]
                    || slice[0..2] == b"IS"[..]
                    || slice[0..2] == b"iS"[..]
                    || slice[0..2] == b"Is"[..];

                    if starts_with_is { start = 2; }
                }

                let mut next_write = 0;
                for i in start..slice.len() 
                {
                    let b = slice[i];
                    if b == b' ' || b == b'_' || b == b'-' {
                        continue;
                    } else if b'A' <= b && b <= b'Z' {
                        slice[next_write] = b + (b'a' - b'A');
                        next_write += 1;
                    } else if b <= 0x7F {
                        slice[next_write] = b;
                        next_write += 1;
                    }
                }
                
                if starts_with_is && next_write == 1 && slice[0] == b'c' 
                {
                    slice[0] = b'i';
                    slice[1] = b's';
                    slice[2] = b'c';
                    next_write = 3;
                }

                &mut slice[..next_write]
            }

        }
        /// Escapes all regular expression meta characters in `text`.
        pub fn escape(text: &str) -> String
        {
            let mut quoted = String::new();
            escape_into(text, &mut quoted);
            quoted
        }
        /// Escapes all meta characters in `text` and writes the result into `buf`.
        pub fn escape_into(text: &str, buf: &mut String)
        {
            buf.reserve(text.len());

            for c in text.chars()
            {
                if is::meta_character(c) { buf.push('\\'); }

                buf.push(c);
            }
        }

    }
    /// Escapes all regular expression meta characters in `pattern`.
    pub fn escape( pattern:&str ) -> String
    {
        syntax::escape( pattern )
    }
    /// Returns the longest common prefix of a set of strings.
    pub fn longest_common_prefix<'a, I, S>( iter: I ) -> Option<&'a str> where
    I: IntoIterator<Item=&'a S>,
    S: 'a + ?Sized + AsRef<str>
    {
        let mut iter = iter.into_iter();

        let mut pfx = iter.next()?.as_ref();

        for s in iter {
            let s = s.as_ref();

            let n = pfx.chars().zip( s.chars() )
                .take_while( |&( a, b )| a == b )
                .map( |( ch, _ )| ch.len_utf8() ).sum();

            if n == 0 {
                return None;
            } else {
                pfx = &pfx[..n];
            }
        }

        Some( pfx )
    }
    
    pub fn backward_word( n: usize, buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[..cur].char_indices().rev();

        for _ in 0..n 
        {
            iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }

            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some( ( ind, ch ) ) => ind + ch.len_utf8(),
            None => 0
        }
    }

    pub fn forward_word( n: usize, buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n 
        {
            iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some( ( ind, _ ) ) => cur + ind,
            None => buf.len()
        }
    }

    pub fn back_n_words( n: usize, buf:&str, cur: usize, word_break:&str ) -> ops::Range<usize>
    {
        let prev = regex::backward_word( 1, buf, cur, word_break );
        let end = regex::word_end( &buf, prev, word_break );

        if n > 1 {
            let start = regex::backward_word( n - 1, buf, prev, word_break );
            start..end
        } else {
            prev..end
        }
    }

    pub fn forward_n_words( n: usize, buf:&str, cur: usize, word_break:&str ) -> ops::Range<usize>
    {
        let start = next_word( 1, buf, cur, word_break );

        if n > 1 {
            let last = next_word( n - 1, buf, start, word_break );
            let end = regex::word_end( buf, last, word_break );
            start..end
        } else {
            let end = regex::word_end( buf, start, word_break );
            start..end
        }
    }

    pub fn first_word( buf:&str, word_break:&str ) -> Option<usize>
    {
        let mut chars = buf.char_indices();

        iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );

        chars.next().map( |( idx, _ )| idx )
    }

    pub fn word_start( buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let fwd = match buf[cur..].chars().next() {
            Some( ch ) => word_break.contains( ch ),
            None => return buf.len()
        };

        if fwd {
            next_word( 1, buf, cur, word_break )
        } else {
            let mut chars = buf[..cur].char_indices().rev();

            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );

            match chars.next() {
                Some( ( idx, ch ) ) => idx + ch.len_utf8(),
                None => 0
            }
        }
    }

    pub fn next_word( n: usize, buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n 
        {
            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }

            iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
        }

        match chars.next() 
        {
            Some( ( idx, _ ) ) => cur + idx,
            None => buf.len()
        }
    }

    pub fn word_end( buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );

        match chars.next()
        {
            Some( ( idx, _ ) ) => cur + idx,
            None => buf.len()
        }
    }
    
    pub fn find_matching_parenthesis( s:&str, quotes:&str, open:char, close:char ) -> Option<usize>
    {
        let mut chars = s.char_indices().rev();
        let mut level = 0;
        let mut string_delim = None;

        while let Some( ( ind, ch ) ) = chars.next()
        {
            if string_delim == Some( ch ) {
                string_delim = None;
            } else if quotes.contains( ch ) {
                string_delim = Some( ch );
            } else if string_delim.is_none() && ch == close {
                level += 1;
            } else if string_delim.is_none() && ch == open {
                level -= 1;

                if level == 0 {
                    return Some( ind );
                }
            }
        }

        None
    }

    pub fn match_name( name:&str, value:&str ) -> bool
    {
        name == value || ( name.starts_with( value ) && name.as_bytes()[value.len()] == b'-' )
    }

    pub fn contains( needle:&str, haystack:&str ) -> bool
    {
        let haystack = match Regex::new( haystack )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println!( "Regex new error: {:?}", e );
                return false;
            }
        };

        haystack.is_match( needle )
    }

    pub fn find_first_group( ptn: &str, text:&str ) -> Option<String>
    {
        let re = match regex::Regex::new( ptn )
        {
            Ok( x ) => x,
            Err(_ ) => return None,
        };

        match re.captures( text )
        {
            Some( Caps ) =>
            {
                if let Some( x ) = caps.get(1) { return Some(x.as_str().to_owned() ); }
            }

            None => { return None; }
        }

        None
    }

    pub fn replace_all( text: &str, ptn: &str, ptn_to:&str ) -> String
    {
        let re = regex::Regex::new( ptn ).unwrap();
        let result = re.replace_all( text, ptn_to);
        result.to_string()
    }

}

pub mod result
{
    pub use std::result::{ * };
    use ::
    {
        error::{ OverError, ParseError },
        *,
    };
    /// Result type for this crate.
    pub type OverResult<T> = Result<T, OverError>;    
    /*
    */
    pub type ParseResult<T> = Result<T, ParseError>;
}

pub mod shell
{
    /*!
    */
    use ::
    {
        collections::{ HashMap, HashSet },
        error::no::{ errno },
        io::{ Write },
        regex::{ Regex },
        types::{ * },
        uuid::{ Uuid },
        *,
    };
    /*
    */
    #[derive( Debug, Clone )]
    pub struct Shell
    {
        pub jobs: HashMap<i32, Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }
    
    impl Shell
    {
        pub fn new() -> Shell
        {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = get::current_directory();
            let has_terminal = has::terminal();
            let ( session_id, _ ) = uuid.split_at( 13 );
            Shell
            {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }
    }
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };
    use ::
    {
        borrow::{ Borrow, BorrowMut, Cow },
        boxed::{ Box },
        cmp::{ Ordering },
        convert::{ Infallible },
        ffi::{ OsStr, OsString },
        fs::{ File },
        hash::{ Hash, Hasher },
        io::{ Read, Write },
        iter::{ FromIterator, FusedIterator },
        marker::{ PhantomData },
        smallvec::{ Array, SmallVec },
        string::{ String },
        *,
    };
    /*
    */
    macro_rules! eq_str 
    {
        ( $rhs:ty ) =>
        {
            impl<'a, A: Array<Item = u8>> PartialEq<$rhs> for SmallString<A>
            {
                #[inline] fn eq( &self, rhs:&$rhs ) -> bool { self[..] == rhs[..] }
            }
        };
    }
    /// Iterator over string prefixes.
    pub struct Prefixes<'a>
    {
        s:&'a str,
        iter: CharIndices<'a>,
    }
    /// Returns an iterator over all non-empty prefixes of `s`, beginning with the shortest.
    #[inline] pub fn prefixes( s:&str ) -> Prefixes
    {
        Prefixes
        {
            s,
            iter: s.char_indices(),
        }
    }
    
    impl<'a> Iterator for Prefixes<'a>
    {
        type Item = &'a str;

        fn next( &mut self ) -> Option<&'a str> { self.iter.next().map( |( idx, ch )| &self.s[..idx + ch.len_utf8()] ) }
    }
    /// Reads a file and returns its contents in a string.   
    pub fn read_from_file( fname:&str ) -> io::Result<String>
    {
        let mut file = File::open( fname )?;

        let mut contents = String::new();
        let _ = file.read_to_string( &mut contents )?;

        Ok( contents )
    }
    /// Writes a string to a file.
    //pub fn write_file_str( fname:&str, contents:&str ) -> io::Result<()>
    pub fn write_file_from( fname:&str, contents:&str ) -> io::Result<()>
    {
       
        let mut file = File::create( fname )?;

        file.write_all( contents.as_bytes() )?;

        Ok( () )
    }
    /// A `String`-like container that can store a small number of bytes inline.
    #[derive( Clone, Default )]
    pub struct SmallString<A: Array<Item = u8>> {
        data: SmallVec<A>,
    }

    impl<A: Array<Item = u8>> SmallString<A> {
        /// Construct an empty string.
        #[inline] pub fn new() -> SmallString<A> {
            SmallString {
                data: SmallVec::new(),
            }
        }
        /// Construct an empty string with enough capacity pre-allocated to store
        /// at least `n` bytes.
        #[inline] pub fn with_capacity( n: usize ) -> SmallString<A> {
            SmallString {
                data: SmallVec::with_capacity( n ),
            }
        }
        /// Construct a `SmallString` by copying data from a `&str`.
        #[allow( clippy::should_implement_trait )]
        #[inline] pub fn from_str( s:&str ) -> SmallString<A> {
            SmallString {
                data: SmallVec::from_slice( s.as_bytes() ),
            }
        }
        /// Construct a `SmallString` by using an existing allocation.
        #[inline] pub fn from_string( s: String ) -> SmallString<A> {
            SmallString {
                data: SmallVec::from_vec( s.into_bytes() ),
            }
        }
        /// Constructs a new `SmallString` on the stack using UTF-8 bytes.
        #[inline] pub fn from_buf( buf: A ) -> Result<SmallString<A>, FromUtf8Error<A>>
        {
            let data = SmallVec::from_buf( buf );

            match str::from_utf8( &data ) {
                Ok( _ ) => Ok( SmallString { data } ),
                Err( error ) => {
                    let buf = data.into_inner().ok().unwrap();

                    Err( FromUtf8Error { buf, error } )
                }
            }
        }
        /// Constructs a new `SmallString` on the stack using the provided byte array
        /// without checking that the array contains valid UTF-8.
        #[inline] pub unsafe fn from_buf_unchecked( buf: A ) -> SmallString<A> {
            SmallString {
                data: SmallVec::from_buf( buf ),
            }
        }
        /// The maximum number of bytes this string can hold inline.
        #[inline] pub fn inline_size( &self ) -> usize {
            A::size()
        }
        /// Returns the length of this string, in bytes.
        #[inline] pub fn len( &self ) -> usize {
            self.data.len()
        }
        /// Returns `true` if this string is empty.
        #[inline] pub fn is_empty( &self ) -> bool {
            self.data.is_empty()
        }
        /// Returns the number of bytes this string can hold without reallocating.
        #[inline] pub fn capacity( &self ) -> usize {
            self.data.capacity()
        }
        /// Returns `true` if the data has spilled into a separate heap-allocated buffer.
        #[inline] pub fn spilled( &self ) -> bool {
            self.data.spilled()
        }
        /// Empties the string and returns an iterator over its former contents.
        pub fn drain( &mut self ) -> Drain<'_> {
            unsafe {
                let len = self.len();

                self.data.set_len( 0 );

                let ptr = self.as_ptr();

                let slice = slice::from_raw_parts( ptr, len );
                let s = str::from_utf8_unchecked( slice );

                Drain { iter: s.chars() }
            }
        }
        /// Empties the sub string and returns an iterator over its former contents.
        pub fn drain_range<R>( &mut self, range: R ) -> DrainRange<'_, A>
        where
            R: ops::RangeBounds<usize>,
        {
            DrainRange {
                drain: self.data.drain( range ),
            }
        }
        /// Appends the given `char` to the end of this string.
        #[inline] pub fn push( &mut self, ch:char ) {
            match ch.len_utf8() {
                1 => self.data.push( ch as u8 ),
                _ => self.push_str( ch.encode_utf8( &mut [0; 4] ) ),
            }
        }
        /// Appends the given string slice to the end of this string.
        #[inline] pub fn push_str( &mut self, s:&str ) {
            self.data.extend_from_slice( s.as_bytes() );
        }
        /// Removes the last character from this string and returns it.
        #[inline] pub fn pop( &mut self ) -> Option<char> {
            match self.chars().next_back() {
                Some( ch ) => unsafe {
                    let new_len = self.len() - ch.len_utf8();
                    self.data.set_len( new_len );
                    Some( ch )
                },
                None => None,
            }
        }
        /// Reallocates to set the new capacity to `new_cap`.
        #[inline] pub fn grow( &mut self, new_cap: usize ) {
            self.data.grow( new_cap );
        }
        /// Ensures that this string's capacity is at least `additional` bytes larger
        /// than its length.
        #[inline] pub fn reserve( &mut self, additional: usize ) {
            self.data.reserve( additional );
        }
        /// Ensures that this string's capacity is `additional` bytes larger than
        /// its length.
        #[inline] pub fn reserve_exact( &mut self, additional: usize ) {
            self.data.reserve( additional );
        }
        /// Shrink the capacity of the string as much as possible.
        #[inline] pub fn shrink_to_fit( &mut self ) {
            self.data.shrink_to_fit();
        }
        /// Shorten the string, keeping the first `len` bytes.
        #[inline] pub fn truncate( &mut self, len: usize ) {
            assert!( self.is_char_boundary( len ) );
            self.data.truncate( len );
        }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_str( &self ) -> &str { self }
        /// Extracts a string slice containing the entire string.
        #[inline] pub fn as_mut_str( &mut self ) -> &mut str { self }
        /// Removes all contents of the string.
        #[inline] pub fn clear( &mut self ) {
            self.data.clear();
        }
        /// Removes a `char` from this string at a byte position and returns it.
        #[inline] pub fn remove( &mut self, idx: usize ) -> char {
            let ch = match self[idx..].chars().next() {
                Some( ch ) => ch,
                None => panic!( "cannot remove a char from the end of a string" ),
            };

            let ch_len = ch.len_utf8();
            let next = idx + ch_len;
            let len = self.len();

            unsafe {
                let ptr = self.as_mut_ptr();

                ptr::copy( ptr.add( next ), ptr.add( idx ), len - next );
                self.data.set_len( len - ch_len );
            }

            ch
        }
        /// Inserts a `char` into this string at the given byte position.
        #[inline] pub fn insert( &mut self, idx: usize, ch:char ) {
            assert!( self.is_char_boundary( idx ) );

            match ch.len_utf8() {
                1 => self.data.insert( idx, ch as u8 ),
                _ => self.insert_str( idx, ch.encode_utf8( &mut [0; 4] ) ),
            }
        }
        /// Inserts a `&str` into this string at the given byte position.
        #[inline] pub fn insert_str( &mut self, idx: usize, s:&str ) {
            assert!( self.is_char_boundary( idx ) );

            let len = self.len();
            let amt = s.len();

            self.data.reserve( amt );

            let ptr = self.as_mut_ptr();

            unsafe {
                ptr::copy( ptr.add( idx ), ptr.add( idx + amt ), len - idx );
                ptr::copy_nonoverlapping( s.as_ptr(), ptr.add( idx ), amt );
                self.data.set_len( len + amt );
            }
        }
        /// Returns a mutable reference to the contents of the `SmallString`.
        #[inline] pub unsafe fn as_mut_vec( &mut self ) -> &mut SmallVec<A> {
            &mut self.data
        }
        /// Converts the `SmallString` into a `String`, without reallocating if the
        /// `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_string( self ) -> String {
            unsafe { String::from_utf8_unchecked( self.data.into_vec() ) }
        }
        /// Converts the `SmallString` into a `Box<str>`, without reallocating if the
        /// `SmallString` has already spilled onto the heap.
        #[inline] pub fn into_boxed_str( self ) -> Box<str> {
            self.into_string().into_boxed_str()
        }
        /// Convert the `SmallString` into `A`, if possible. Otherwise, return `Err( self )`.
        #[inline] pub fn into_inner( self ) -> Result<A, Self> {
            self.data.into_inner().map_err( |data| SmallString { data } )
        }
        /// Retains only the characters specified by the predicate.
        #[inline] pub fn retain<F: FnMut( char ) -> bool>( &mut self, mut f: F ) {
            struct SetLenOnDrop<'a, A: Array<Item = u8>> {
                s:&'a mut SmallString<A>,
                idx: usize,
                del_bytes: usize,
            }

            impl<'a, A: Array<Item = u8>> Drop for SetLenOnDrop<'a, A> {
                fn drop( &mut self ) {
                    let new_len = self.idx - self.del_bytes;
                    debug_assert!( new_len <= self.s.len() );
                    unsafe { self.s.data.set_len( new_len ) };
                }
            }

            let len = self.len();
            let mut guard = SetLenOnDrop {
                s: self,
                idx: 0,
                del_bytes: 0,
            };

            while guard.idx < len {
                let ch = unsafe {
                    guard
                        .s
                        .get_unchecked( guard.idx..len )
                        .chars()
                        .next()
                        .unwrap()
                };
                let ch_len = ch.len_utf8();

                if !f( ch ) {
                    guard.del_bytes += ch_len;
                } else if guard.del_bytes > 0 {
                    let ptr = guard.s.as_mut_ptr();

                    unsafe {
                        ptr::copy( 
                            ptr.add( guard.idx ),
                            ptr.add( guard.idx - guard.del_bytes ),
                            ch_len,
                         );
                    }
                }
                
                guard.idx += ch_len;
            }

            drop( guard );
        }

        fn as_ptr( &mut self ) -> *const u8 {
            self.data.as_ptr()
        }

        fn as_mut_ptr( &mut self ) -> *mut u8 {
            self.data.as_mut_ptr()
        }
    }

    impl<A: Array<Item = u8>> ops::Deref for SmallString<A> {
        type Target = str;

        #[inline] fn deref( &self ) -> &str {
            let bytes:&[u8] = &self.data;
            unsafe { str::from_utf8_unchecked( bytes ) }
        }
    }

    impl<A: Array<Item = u8>> ops::DerefMut for SmallString<A> {
        #[inline] fn deref_mut( &mut self ) -> &mut str {
            let bytes:&mut [u8] = &mut self.data;
            unsafe { str::from_utf8_unchecked_mut( bytes ) }
        }
    }

    impl<A: Array<Item = u8>> AsRef<str> for SmallString<A> {
        #[inline] fn as_ref( &self ) -> &str { self }
    }

    impl<A: Array<Item = u8>> AsMut<str> for SmallString<A> {
        #[inline] fn as_mut( &mut self ) -> &mut str { self }
    }

    impl<A: Array<Item = u8>> Borrow<str> for SmallString<A> {
        #[inline] fn borrow( &self ) -> &str { self }
    }

    impl<A: Array<Item = u8>> BorrowMut<str> for SmallString<A> {
        #[inline] fn borrow_mut( &mut self ) -> &mut str { self }
    }

    impl<A: Array<Item = u8>> AsRef<[u8]> for SmallString<A> {
        #[inline] fn as_ref( &self ) -> &[u8] {
            self.data.as_ref()
        }
    }

    impl<A: Array<Item = u8>> fmt::Write for SmallString<A> {
        #[inline] fn write_str( &mut self, s:&str ) -> fmt::Result {
            self.push_str( s  );
            Ok( () )
        }

        #[inline] fn write_char( &mut self, ch:char ) -> fmt::Result {
            self.push( ch );
            Ok( () )
        }
    }

    impl<A: Array<Item = u8>> FromStr for SmallString<A> {
        type Err = Infallible;

        fn from_str( s:&str ) -> Result<Self, Self::Err> {
            Ok( SmallString::from( s ) )
        }
    }
    
    impl<A: Array<Item = u8>> From<char> for SmallString<A> {
        #[inline] fn from( ch:char ) -> SmallString<A> {
            SmallString::from_str( ch.encode_utf8( &mut [0; 4] ) )
        }
    }

    impl<A: Array<Item = u8>> From<&'_ str> for SmallString<A> {
        #[inline] fn from( s:&str ) -> SmallString<A> {
            SmallString::from_str( s )
        }
    }

    impl<A: Array<Item = u8>> From<Box<str>> for SmallString<A> {
        #[inline] fn from( s: Box<str> ) -> SmallString<A> {
            SmallString::from_string( s.into() )
        }
    }

    impl<A: Array<Item = u8>> From<String> for SmallString<A> {
        #[inline] fn from( s: String ) -> SmallString<A> {
            SmallString::from_string( s )
        }
    }

    impl<'a, A: Array<Item = u8>> From<Cow<'a, str>> for SmallString<A> {
        fn from( value: Cow<'a, str> ) -> Self {
            match value {
                Cow::Borrowed( s ) => Self::from_str( s ),
                Cow::Owned( s ) => Self::from_string( s ),
            }
        }
    }

    macro_rules! impl_index_str {
        ( $index_type: ty ) => {
            impl<A: Array<Item = u8>> ops::Index<$index_type> for SmallString<A> {
                type Output = str;

                #[inline] fn index( &self, index: $index_type ) -> &str {
                    &self.as_str()[index]
                }
            }

            impl<A: Array<Item = u8>> ops::IndexMut<$index_type> for SmallString<A> {
                #[inline] fn index_mut( &mut self, index: $index_type ) -> &mut str {
                    &mut self.as_mut_str()[index]
                }
            }
        };
    }

    impl_index_str!( ops::Range<usize> );
    impl_index_str!( ops::RangeFrom<usize> );
    impl_index_str!( ops::RangeTo<usize> );
    impl_index_str!( ops::RangeFull );

    impl<A: Array<Item = u8>> FromIterator<char> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = char>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a char> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = &'a char>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter.into_iter().cloned() );
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<Cow<'a, str>> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a str> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = &'a str>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<A: Array<Item = u8>> FromIterator<String> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = String>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<A: Array<Item = u8>> Extend<char> for SmallString<A> {
        fn extend<I: IntoIterator<Item = char>>( &mut self, iter: I ) {
            let iter = iter.into_iter();
            let ( lo, _ ) = iter.size_hint();

            self.reserve( lo );

            for ch in iter {
                self.push( ch );
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a char> for SmallString<A> {
        fn extend<I: IntoIterator<Item = &'a char>>( &mut self, iter: I ) {
            self.extend( iter.into_iter().cloned() );
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<Cow<'a, str>> for SmallString<A> {
        fn extend<I: IntoIterator<Item = Cow<'a, str>>>( &mut self, iter: I ) {
            for s in iter {
                self.push_str( &s );
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a str> for SmallString<A> {
        fn extend<I: IntoIterator<Item = &'a str>>( &mut self, iter: I ) {
            for s in iter {
                self.push_str( s  );
            }
        }
    }

    impl<A: Array<Item = u8>> Extend<String> for SmallString<A> {
        fn extend<I: IntoIterator<Item = String>>( &mut self, iter: I ) {
            for s in iter {
                self.push_str( &s );
            }
        }
    }

    impl<A: Array<Item = u8>> fmt::Debug for SmallString<A> {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            fmt::Debug::fmt( &**self, f )
        }
    }

    impl<A: Array<Item = u8>> fmt::Display for SmallString<A> {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            fmt::Display::fmt( &**self, f )
        }
    }

    eq_str!( str );
    eq_str!( &'a str );
    eq_str!( String );
    eq_str!( Cow<'a, str> );
    
    impl<A: Array<Item = u8>> PartialEq<OsStr> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&OsStr ) -> bool {
            &self[..] == rhs
        }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<&'a OsStr> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&&OsStr ) -> bool {
            &self[..] == *rhs
        }
    }
    
    impl<A: Array<Item = u8>> PartialEq<OsString> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&OsString ) -> bool {
            &self[..] == rhs
        }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<Cow<'a, OsStr>> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&Cow<OsStr> ) -> bool {
            self[..] == **rhs
        }
    }

    impl<A, B> PartialEq<SmallString<B>> for SmallString<A> where
        A: Array<Item = u8>,
        B: Array<Item = u8>,
    {
        #[inline] fn eq( &self, rhs:&SmallString<B> ) -> bool {
            self[..] == rhs[..]
        }
    }

    impl<A: Array<Item = u8>> Eq for SmallString<A> {}

    impl<A: Array<Item = u8>> PartialOrd for SmallString<A> 
    {
        #[inline] fn partial_cmp( &self, rhs:&SmallString<A> ) -> Option<Ordering> {
            Some( self.cmp( rhs ) )
        }
    }

    impl<A: Array<Item = u8>> Ord for SmallString<A> 
    {
        #[inline] fn cmp( &self, rhs:&SmallString<A> ) -> Ordering {
            self[..].cmp( &rhs[..] )
        }
    }

    impl<A: Array<Item = u8>> Hash for SmallString<A> 
    {
        #[inline] fn hash<H: Hasher>( &self, state:&mut H ) {
            self[..].hash( state )
        }
    }
    /// A draining iterator for `SmallString`.
    pub struct Drain<'a> {
        iter: Chars<'a>,
    }

    impl<'a> Iterator for Drain<'a> 
    {
        type Item = char;

        #[inline] fn next( &mut self ) -> Option<char> {
            self.iter.next()
        }

        #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) {
            self.iter.size_hint()
        }
    }

    impl<'a> DoubleEndedIterator for Drain<'a> 
    {
        #[inline] fn next_back( &mut self ) -> Option<char> {
            self.iter.next_back()
        }
    }
    /// A range draining iterator for `SmallString`.
    pub struct DrainRange<'a, A: Array<Item = u8>> 
    {
        drain: smallvec::Drain<'a, A>,
    }

    impl<A: Array<Item = u8>> fmt::Debug for DrainRange<'_, A> 
    {
        fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
            self.drain.fmt( f )
        }
    }

    impl<A: Array<Item = u8>> Iterator for DrainRange<'_, A> 
    {
        type Item = char;

        fn next( &mut self ) -> Option<Self::Item>
        {
            let mut buf = [0; 4];

            buf[0] = self.drain.next()?;
            let utf8_len = 1.max( buf[0].leading_ones() as usize );

            for b in &mut buf[1..utf8_len] {
                *b = self.drain.next().unwrap();
            }

            unsafe { str::from_utf8_unchecked( &buf[..utf8_len] ) }
                .chars()
                .next()
        }

        fn size_hint( &self ) -> ( usize, Option<usize> ) {
            let len = self.drain.len();
            ( len.div_ceil( 4 ), Some( len ) )
        }
    }

    impl<A: Array<Item = u8>> DoubleEndedIterator for DrainRange<'_, A> 
    {
        fn next_back( &mut self ) -> Option<Self::Item>
        {
            let mut buf = [0; 4];
            let mut i = 3;

            buf[i] = self.drain.next_back()?;

            while buf[i].leading_ones() == 1 {
                i -= 1;
                buf[i] = self.drain.next_back().unwrap();
            }

            unsafe { str::from_utf8_unchecked( &buf[i..] ) }
                .chars()
                .next()
        }
    }
    impl<A: Array<Item = u8>> FusedIterator for DrainRange<'_, A> {}
    /// A possible error value when creating a `SmallString` from a byte array.
    #[derive( Debug )]
    pub struct FromUtf8Error<A: Array<Item = u8>> 
    {
        buf: A,
        error: Utf8Error,
    }

    impl<A: Array<Item = u8>> FromUtf8Error<A> 
    {
        /// Returns the slice of `[u8]` bytes that were attempted to convert to a `SmallString`.
        #[inline] pub fn as_bytes( &self ) -> &[u8] {
            let ptr = &self.buf as *const _ as *const u8;
            unsafe { slice::from_raw_parts( ptr, A::size() ) }
        }
        /// Returns the byte array that was attempted to convert into a `SmallString`.
        #[inline] pub fn into_buf( self ) -> A {
            self.buf
        }
        /// Returns the `Utf8Error` to get more details about the conversion failure.
        #[inline] pub fn utf8_error( &self ) -> Utf8Error {
            self.error
        }
    }

    impl<A: Array<Item = u8>> fmt::Display for FromUtf8Error<A>
    {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            fmt::Display::fmt( &self.error, f )
        }
    }
    
    pub fn filter_visible( s:&str ) -> Cow<str>
    {
        use ::system::reader::{START_INVISIBLE, END_INVISIBLE};

        if !s.contains( START_INVISIBLE ) { return Cow::Borrowed( s ); }

        let mut virt = String::new();
        let mut ignore = false;

        for ch in s.chars()
        {
            if ch == START_INVISIBLE { ignore = true; }
            
            else if ch == END_INVISIBLE { ignore = false; }

            else if !ignore { virt.push( ch  ); }
        }

        Cow::Owned( virt )
    }
}

pub mod string
{
    pub use std::string::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
}
/*
    linefeed v0.0.0
    mortal v0.0.0
    terminfo v0.0.0
*/
pub mod system
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    nix v0.0.0
    
    use nix::unistd::{read, write};
    */
    pub mod api
    {
        /*!
        */
        use ::
        {
            cell::{ Ref, RefCell },
            convert::{ TryFrom },
            ffi::{ c_void },
            hash::{ Hash, Hasher },
            iter::{ FromIterator, FusedIterator },
            ops::{ BitOr, Range },
            os::
            {
                fd::{ AsFd, AsRawFd, BorrowedFd, RawFd },
            },
            ptr::{ null_mut },
            *,
        };
        /*
        */
        
        pub type __fsword_t = i64;
        pub type clock_t = i64;
        
        pub type c_char = i8;
        pub type c_double = f64;
        pub type c_float = f32;
        pub type c_int = i32;
        cfg_if!
        {
            if #[cfg(all(target_pointer_width = "64", not(windows)))]
            {
                pub type c_long = i64;
                pub type c_ulong = u64;
            }
            
            else
            {
                pub type c_long = i32;
                pub type c_ulong = u32;
            }
        }
        pub type c_longlong = i64;
        pub type c_schar = i8;
        pub type c_short = i16;
        pub type c_uchar = u8;
        pub type c_uint = u32;
        pub type c_ulonglong = u64;
        pub type c_ushort = u16;        
        pub type cc_t = c_uchar;
        
        pub type Error = Errno;

        pub type gid_t = u32;

        pub type intptr_t = isize;

        pub type pid_t = i32;
        pub type ptrdiff_t = isize;

        pub type Result<Type> = ::result::Result<Type, Errno>;
        
        pub type SaFlags_t = c_int;
        pub type sighandler_t = size_t;
        pub type size_t = usize;
        pub type speed_t = c_uint;
        pub type ssize_t = isize;
        pub type suseconds_t = i64;
        
        pub type tcflag_t = c_uint;
        pub type time_t = i64;

        pub type uintptr_t = usize;
        
        pub type uid_t = u32;

        
        pub const EDEADLOCK: c_int = 35;
        pub const EISNAM: c_int = 120;
        pub const ENAVAIL: c_int = 119;
        pub const ENOTNAM: c_int = 118;
        pub const EREMOTEIO: c_int = 121;
        pub const EUCLEAN: c_int = 117;        

        pub const EPERM: c_int = 1;
        pub const ENOENT: c_int = 2;
        pub const ESRCH: c_int = 3;
        pub const EINTR: c_int = 4;
        pub const EIO: c_int = 5;
        pub const ENXIO: c_int = 6;
        pub const E2BIG: c_int = 7;
        pub const ENOEXEC: c_int = 8;
        pub const EBADF: c_int = 9;
        pub const ECHILD: c_int = 10;
        pub const EAGAIN: c_int = 11;
        pub const ENOMEM: c_int = 12;
        pub const EACCES: c_int = 13;
        pub const EFAULT: c_int = 14;
        pub const ENOTBLK: c_int = 15;
        pub const EBUSY: c_int = 16;
        pub const EEXIST: c_int = 17;
        pub const EXDEV: c_int = 18;
        pub const ENODEV: c_int = 19;
        pub const ENOTDIR: c_int = 20;
        pub const EISDIR: c_int = 21;
        pub const EINVAL: c_int = 22;
        pub const ENFILE: c_int = 23;
        pub const EMFILE: c_int = 24;
        pub const ENOTTY: c_int = 25;
        pub const ETXTBSY: c_int = 26;
        pub const EFBIG: c_int = 27;
        pub const ENOSPC: c_int = 28;
        pub const ESPIPE: c_int = 29;
        pub const EROFS: c_int = 30;
        pub const EMLINK: c_int = 31;
        pub const EPIPE: c_int = 32;
        pub const EDOM: c_int = 33;
        pub const ERANGE: c_int = 34;
        
        pub const FD_SETSIZE: c_int = 1024;
        
        pub const INT_MIN: c_int = -2147483648;
        pub const INT_MAX: c_int = 2147483647;

        pub const NANOS_PER_SEC: i64 = 1_000_000_000;
        pub const NCCS: usize = 32;

        pub const SECS_PER_MINUTE: i64 = 60;
        pub const SECS_PER_HOUR: i64 = 3600;
        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;
        pub const SIG_IGN: sighandler_t = 1 as sighandler_t;
        pub const SIG_ERR: sighandler_t = !0 as sighandler_t;
        pub const SIG_HUP: c_int = 1;
        pub const SIG_INT: c_int = 2;
        pub const SIG_QUIT: c_int = 3;
        pub const SIG_ILL: c_int = 4;
        pub const SIG_ABRT: c_int = 6;
        pub const SIG_FPE: c_int = 8;
        pub const SIG_KILL: c_int = 9;
        pub const SIG_SEGV: c_int = 11;
        pub const SIG_PIPE: c_int = 13;
        pub const SIG_ALRM: c_int = 14;
        pub const SIG_TERM: c_int = 15;
        pub const SIG_TSTP: c_int = 20;

        pub const VDISCARD: usize = 13;
        pub const VMIN: usize = 6;
        pub const VREPRINT: usize = 12;
        pub const VSUSP: usize = 10;
        pub const VSTART: usize = 8;
        pub const VSTOP: usize = 9;        
        pub const VTIME: usize = 5;
        pub const VWERASE: usize = 14;
        // External libc Unix Functions
        extern "C"
        {
            pub fn fork() -> pid_t;
            pub fn getpgid( pid: pid_t ) -> pid_t;
            pub fn getpgrp() -> pid_t;
            pub fn getpid() -> pid_t;
            pub fn getppid() -> pid_t;
            pub fn getuid() -> uid_t;
            pub fn isatty( fd: c_int ) -> c_int;
            pub fn pipe( fds: *mut c_int ) -> c_int;
            pub fn select
            ( 
                nfds: c_int,
                readfds: *mut FDSet,
                writefds: *mut FDSet,
                errorfds: *mut FDSet,
                timeout: *mut TimeValue,
            ) -> c_int;
            pub fn sigaction( signum:c_int, act:*const SignalAction, oldact:*mut SignalAction ) -> c_int;
            pub fn signal( signum:c_int, handler:sighandler_t ) -> sighandler_t;
            pub fn sigaddset( set:*mut SignalSet, signum:c_int ) -> c_int;
            pub fn sigemptyset( set:*mut SignalSet ) -> c_int;
            pub fn sigismember( set:*const SignalSet, signum:c_int ) -> c_int;
            pub fn sigfillset( set: *mut SignalSet ) -> c_int;
            pub fn strlen( Cs: *const c_char ) -> size_t;
            pub fn strerror_r( errnum:c_int, buf: *mut c_char, buflen: size_t ) -> c_int;
            pub fn tcgetpgrp( fd:c_int ) -> pid_t;
            pub fn tcsetpgrp( fd:c_int, pgrp:pid_t ) -> c_int;
        }
        // Controls the behavior of a [`SigAction`]
        libc_bitflags!
        {
            /// Controls the behavior of a [`SigAction`]
            #[cfg_attr( docsrs, doc( cfg( feature = "signal" ) ) )]
            pub struct SaFlags: SaFlags_t {
                /// When catching a [`Signal::SIGCHLD`] signal, the signal will be
                /// generated only when a child process exits, not when a child process
                /// stops.
                SA_NOCLDSTOP;
                /// When catching a [`Signal::SIGCHLD`] signal, the system will not
                /// create zombie processes when children of the calling process exit.
                #[cfg( not( target_os = "hurd" ) )]
                SA_NOCLDWAIT;
                /// Further occurrences of the delivered signal are not masked during
                /// the execution of the handler.
                SA_NODEFER;
                /// The system will deliver the signal to the process on a signal stack,
                /// specified by each thread with sigaltstack( 2 ).
                SA_ONSTACK;
                /// The handler is reset back to the default at the moment the signal is
                /// delivered.
                SA_RESETHAND;
                /// Requests that certain system calls restart if interrupted by this
                /// signal.  See the man page for complete details.
                SA_RESTART;
                /// This flag is controlled internally by Nix.
                SA_SIGINFO;
            }
        }
        
        pub use self::Signal::*;
        pub const SIGNALS: [Signal; 29] =
        [
            SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,
            SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,
            SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,
            SIGPROF, SIGWINCH, SIGIO, SIGSYS
        ];
        /// Iterate through all signals defined by this operating system
        #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SignalIterator
        {
            next: usize,
        }

        impl Iterator for SignalIterator
        {
            type Item = Signal;

            fn next( &mut self ) -> Option<Signal>
            {
                if self.next < SIGNALS.len() {
                    let next_signal = SIGNALS[self.next];
                    self.next += 1;
                    Some( next_signal )
                } else {
                    None
                }
            }
        }

        impl Signal
        {
            /// Iterate through all signals defined by this OS
            pub const fn iterator() -> SignalIterator { SignalIterator{ next:0 } }
        }
        //sigset_t
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SignalSet
        {
            #[cfg( target_pointer_width = "32" )]
            pub __val: [u32; 32],
            #[cfg( target_pointer_width = "64" )]
            pub __val: [u64; 16],
        }
        /// Specifies a set of [`Signal`]s that may be blocked, waited for, etc.
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SigSet
        {
            sigset:SignalSet
        }

        impl SigSet
        {
            /// Add the specified signal to the set.
            pub fn add( &mut self, signal: Signal ) { unsafe { sigaddset( &mut self.sigset, signal as c_int ) }; }
            /// Initialize to include all signals.
            pub fn all() -> SigSet
            {
                let mut sigset = mem::MaybeUninit::uninit();
                let _ = unsafe { sigfillset( sigset.as_mut_ptr() ) };

                unsafe{ SigSet { sigset: sigset.assume_init() } }
            }
            /// Return whether this set includes the specified signal.
            pub fn contains( &self, signal: Signal ) -> bool
            {
                let res = unsafe { sigismember( &self.sigset, signal as c_int ) };

                match res
                {
                    1 => true,
                    0 => false,
                    _ => unreachable!( "unexpected value from sigismember" ),
                }
            }
            /// Initialize to include nothing.
            pub fn empty() -> SigSet
            {
                let mut sigset = mem::MaybeUninit::uninit();
                let _ = unsafe { sigemptyset( sigset.as_mut_ptr() ) };
                unsafe{ SigSet { sigset: sigset.assume_init() } }
            }
            /// Returns an iterator that yields the signals contained in this set.
            pub fn iter( &self ) -> SigSetIter<'_> { self.into_iter() }
        }

        impl From<Signal> for SigSet 
        {
            fn from( signal: Signal ) -> SigSet {
                let mut sigset = SigSet::empty();
                sigset.add( signal );
                sigset
            }
        }

        impl BitOr for Signal 
        {
            type Output = SigSet;

            fn bitor( self, rhs: Self ) -> Self::Output {
                let mut sigset = SigSet::empty();
                sigset.add( self );
                sigset.add( rhs );
                sigset
            }
        }

        impl BitOr<Signal> for SigSet 
        {
            type Output = SigSet;

            fn bitor( mut self, rhs: Signal ) -> Self::Output {
                self.add( rhs );
                self
            }
        }

        impl BitOr for SigSet 
        {
            type Output = Self;

            fn bitor( self, rhs: Self ) -> Self::Output {
                self.iter().chain( rhs.iter() ).collect()
            }
        }

        impl AsRef<SignalSet> for SigSet
        {
            fn as_ref( &self ) -> &SignalSet
            {
                &self.sigset
            }
        }
        
        impl Extend<Signal> for SigSet 
        {
            fn extend<T>( &mut self, iter: T )
            where T: IntoIterator<Item = Signal> {
                for signal in iter {
                    self.add( signal );
                }
            }
        }

        impl<'a> IntoIterator for &'a SigSet
        {
            type Item = Signal;
            type IntoIter = SigSetIter<'a>;
            fn into_iter( self ) -> Self::IntoIter
            {
                SigSetIter { sigset: self, inner: Signal::iterator() }
            }
        }

        impl FromIterator<Signal> for SigSet 
        {
            fn from_iter<T>( iter: T ) -> Self where T: IntoIterator<Item = Signal>
            {
                let mut sigset = SigSet::empty();
                sigset.extend( iter );
                sigset
            }
        }
        /// Iterator for a [`SigSet`].
        #[derive( Clone, Debug )]
        pub struct SigSetIter<'a>
        {
            sigset:&'a SigSet,
            inner: SignalIterator,
        }

        impl Iterator for SigSetIter<'_>
        {
            type Item = Signal;
            fn next( &mut self ) -> Option<Signal>
            {
                loop
                {
                    match self.inner.next()
                    {
                        None => return None,
                        Some( signal ) if self.sigset.contains( signal ) => return Some( signal ),
                        Some( _signal ) => continue,
                    }
                }
            }
        }
        
        pub struct SignalInformation
        {
            pub si_signo: c_int,
            pub si_errno: c_int,
            pub si_code: c_int,
            #[doc(hidden )]
            #[deprecated(
                since = "0.2.54",
                note = "Please leave a comment on \
                    https://github.com/rust-lang/libc/pull/1316 if you're using \
                    this field"
            )]
            pub _pad: [c_int; 29],
            _align: [u64; 0],
        }
        /// A signal handler.
        #[derive( Clone, Copy, Debug, Hash )]
        pub enum SigHandler 
        {
            /// Default signal handling.
            SigDfl,
            /// Request that the signal be ignored.
            SigIgn,
            /// Use the given signal-catching function, which takes in the signal.
            Handler( extern "C" fn( c_int ) ),
            /// Use the given signal-catching function, which takes in the signal, information about how
            /// the signal was generated, and a pointer to the threads `ucontext_t`.
            #[cfg( not( target_os = "redox" ) )]
            SigAction( extern "C" fn( c_int, *mut SignalInformation, *mut c_void ) )
        }
        
        #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SignalAction
        {
            pub sa_sigaction: sighandler_t,
            pub sa_mask: SignalSet,
            #[cfg( target_arch = "sparc64" )]
            __reserved0: c_int,
            pub sa_flags: c_int,
            pub sa_restorer: Option<extern "C" fn()>,
        }
        /// Action to take on receipt of a signal. Corresponds to `sigaction`.
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SigAction
        {
            sigaction:SignalAction
        }

        impl SigAction
        {
            /// Creates a new action.
            pub fn new( handler:SigHandler, flags:SaFlags, mask:SigSet ) -> SigAction
            {
                unsafe fn install_sig( p: *mut SignalAction, handler: SigHandler ) 
                {
                    unsafe 
                    {
                        ( *p ).sa_sigaction = match handler 
                        {
                            SigHandler::SigDfl => libc::SIG_DFL,
                            SigHandler::SigIgn => libc::SIG_IGN,
                            SigHandler::Handler( f )   => f as *const extern "C" fn( c_int ) as usize,
                            SigHandler::SigAction( f ) => f as *const extern "C" fn( c_int, *mut SignalAction, *mut c_void ) as usize,
                        };
                    }
                }

                let mut s = mem::MaybeUninit::<SignalAction>::uninit();
                unsafe 
                {
                    let p = s.as_mut_ptr();
                    install_sig( p, handler );
                    ( *p ).sa_flags = match handler 
                    {
                        SigHandler::SigAction( _ ) => ( flags | SaFlags::SA_SIGINFO ).bits(),
                        _ => ( flags - SaFlags::SA_SIGINFO ).bits(),
                    };

                    ( *p ).sa_mask = mask.sigset;

                    SigAction { sigaction: s.assume_init() }
                }
            }
        }
        
        impl From<SigAction> for SignalAction
        {
            fn from( value: SigAction ) -> SignalAction {
                value.sigaction
            }
        }
        // Types of operating system signals
        libc_enum!
        {
            /// Types of operating system signals
            #[repr( i32 )] #[non_exhaustive]
            pub enum Signal {
                /// Hangup
                SIGHUP,
                /// Interrupt
                SIGINT,
                /// Quit
                SIGQUIT,
                /// Illegal instruction ( not reset when caught )
                SIGILL,
                /// Trace trap ( not reset when caught )
                SIGTRAP,
                /// Abort
                SIGABRT,
                /// Bus error
                SIGBUS,
                /// Floating point exception
                SIGFPE,
                /// Kill ( cannot be caught or ignored )
                SIGKILL,
                /// User defined signal 1
                SIGUSR1,
                /// Segmentation violation
                SIGSEGV,
                /// User defined signal 2
                SIGUSR2,
                /// Write on a pipe with no one to read it
                SIGPIPE,
                /// Alarm clock
                SIGALRM,
                /// Software termination signal from kill
                SIGTERM,
                /// To parent on child stop or exit
                SIGCHLD,
                /// Continue a stopped process
                SIGCONT,
                /// Sendable stop signal not from tty
                SIGSTOP,
                /// Stop signal from tty
                SIGTSTP,
                /// To readers pgrp upon background tty read
                SIGTTIN,
                /// Like TTIN if ( tp->t_local&LTOSTOP )
                SIGTTOU,
                /// Urgent condition on IO channel
                SIGURG,
                /// Exceeded CPU time limit
                SIGXCPU,
                /// Exceeded file size limit
                SIGXFSZ,
                /// Virtual time alarm
                SIGVTALRM,
                /// Profiling time alarm
                SIGPROF,
                /// Window size changes
                SIGWINCH,
                /// Input/output possible signal
                #[cfg( not( target_os = "haiku" ) )]
                SIGIO,
                /// Bad system call
                SIGSYS,
            }
            impl TryFrom<i32>
        }

        cfg_if!
        {
            if #[cfg( target_pointer_width = "32" )] {
                const ULONG_SIZE: usize = 32;
            } else if #[cfg( target_pointer_width = "64" )] {
                const ULONG_SIZE: usize = 64;
            } else {
                // Unknown target_pointer_width
            }
        }

        #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct FDSet
        {
            pub fds_bits: [c_ulong; FD_SETSIZE as usize / ULONG_SIZE],
        }
        /// Contains a set of file descriptors used by [`select`]
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct FdSet<'fd> 
        {
            set:FDSet,
            _fd: ::marker::PhantomData<BorrowedFd<'fd>>,
        }

        impl <'fd> FdSet<'fd>
        {        
            /// Create an empty `FdSet`
            pub fn new() -> FdSet<'fd>
            {
                let mut fdset = mem::MaybeUninit::uninit();
                unsafe
                {
                    FD_ZERO( fdset.as_mut_ptr() );
                    Self
                    {
                        set: fdset.assume_init(),
                        _fd: ::marker::PhantomData,
                    }
                }
            }
            /// Add a file descriptor to an `FdSet`
            pub fn insert( &mut self, fd:RawFd )
            {
                assert_fd_valid( fd  );
                unsafe { FD_SET( fd.into(), &mut self.set ) };
            }
            /// Test an `FdSet` for the presence of a certain file descriptor.
            pub fn contains( &self, fd: BorrowedFd<'fd> ) -> bool
            {
                assert_fd_valid( fd.as_raw_fd() );
                FD_ISSET( fd.as_raw_fd(), &self.set )
            }
            /// Finds the highest file descriptor in the set.
            pub fn highest( &self ) -> Option<BorrowedFd<'_>> {
                self.fds( None ).next_back()
            }
            /// Returns an iterator over the file descriptors in the set.
            #[inline] pub fn fds( &self, highest: Option<RawFd> ) -> Fds<'_, '_> {
                Fds {
                    set: self,
                    range: 0..highest.map( |h| h as usize + 1 ).unwrap_or( FD_SETSIZE ),
                }
            }
        }
        /// Iterator over `FdSet`.
        #[derive( Debug )]
        pub struct Fds<'a, 'fd> 
        {
            set:&'a FdSet<'fd>,
            range: Range<usize>,
        }
        
        impl<'fd> Iterator for Fds<'_, 'fd>
        {
            type Item = BorrowedFd<'fd>;

            fn next( &mut self ) -> Option<Self::Item> 
            {
                for i in &mut self.range {
                    let borrowed_i = unsafe { BorrowedFd::borrow_raw( i as RawFd ) };
                    if self.set.contains( borrowed_i ) {
                        return Some( borrowed_i );
                    }
                }
                None
            }

            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) 
            {
                let ( _, upper ) = self.range.size_hint();
                ( 0, upper )
            }
        }

        impl<'fd> DoubleEndedIterator for Fds<'_, 'fd>
        {
            #[inline] fn next_back( &mut self ) -> Option<BorrowedFd<'fd>>
            {
                while let Some( i ) = self.range.next_back() {
                    let borrowed_i = unsafe { BorrowedFd::borrow_raw( i as RawFd ) };
                    if self.set.contains( borrowed_i ) {
                        return Some( borrowed_i );
                    }
                }
                None
            }
        }

        impl FusedIterator for Fds<'_, '_> {}

        pub struct timespec
        {
            pub tv_sec: time_t,
            #[cfg( all(gnu_time_bits64, target_endian = "big" ) )]
            __pad: i32,
            #[cfg( not( all( target_arch = "x86_64", target_pointer_width = "32" ) ) )]
            pub tv_nsec: c_long,
            #[cfg( all( target_arch = "x86_64", target_pointer_width = "32" ) )]
            pub tv_nsec: i64,
            #[cfg( all(gnu_time_bits64, target_endian = "little" ) )]
            __pad: i32,
        }

        #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct TimeValue
        {
            pub tv_sec: time_t,
            #[cfg( not( gnu_time_bits64 ) )]
            pub tv_usec: suseconds_t,
            #[cfg( gnu_time_bits64 )]
            pub tv_usec: __suseconds64_t,
        }

        pub trait TimeValLike:Sized
        {
            #[inline] fn zero() -> Self { Self::seconds( 0 ) }

            #[inline] fn hours( hours: i64 ) -> Self
            {
                let secs = hours
                .checked_mul( SECS_PER_HOUR )
                .expect( "TimeValLike::hours ouf of bounds" );
                Self::seconds( secs )
            }

            #[inline] fn minutes( minutes: i64 ) -> Self
            {
                let secs = minutes
                    .checked_mul( SECS_PER_MINUTE )
                    .expect( "TimeValLike::minutes out of bounds" );
                Self::seconds( secs )
            }

            fn seconds( seconds: i64 ) -> Self;
            fn milliseconds( milliseconds: i64 ) -> Self;
            fn microseconds( microseconds: i64 ) -> Self;
            fn nanoseconds( nanoseconds: i64 ) -> Self;

            #[inline] fn num_hours( &self ) -> i64 {
                self.num_seconds() / 3600
            }

            #[inline] fn num_minutes( &self ) -> i64 {
                self.num_seconds() / 60
            }

            fn num_seconds( &self ) -> i64;
            fn num_milliseconds( &self ) -> i64;
            fn num_microseconds( &self ) -> i64;
            fn num_nanoseconds( &self ) -> i64;
        }
        
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct TimeVal( TimeValue  );
        impl TimeVal
        {
            /// Makes a new `TimeVal` with given number of microseconds.
            #[inline] fn microseconds( microseconds: i64 ) -> TimeVal {
                let ( secs, micros ) = div_mod_floor_64( microseconds, MICROS_PER_SEC );
                assert!( 
                    ( TV_MIN_SECONDS..=TV_MAX_SECONDS ).contains( &secs ),
                    "TimeVal out of bounds"
                 );
                #[cfg_attr( 
                    any( target_env = "musl", target_env = "ohos" ),
                    allow( deprecated )
                )]
                // https://github.com/rust-lang/libc/issues/1848
                TimeVal( TimeValue {
                    tv_sec: secs as time_t,
                    tv_usec: micros as suseconds_t,
                } )
            }

            #[inline] pub fn milliseconds( milliseconds: i64 ) -> TimeVal {
                let microseconds = milliseconds
                    .checked_mul( 1_000 )
                    .expect( "TimeVal::milliseconds out of bounds" );

                TimeVal::microseconds( microseconds )
            }
        }
        /// Monitors file descriptors for readiness.
        pub fn selects<'a,'fd,N,R,W,E,T>( nfds:N, readfds:R, writefds:W, errorfds:E, timeout:T ) -> Result<c_int>
        where
        'fd: 'a,
        N: Into<Option<c_int>>,
        R: Into<Option<&'a mut FdSet<'fd>>>,
        W: Into<Option<&'a mut FdSet<'fd>>>,
        E: Into<Option<&'a mut FdSet<'fd>>>,
        T: Into<Option<&'a mut TimeVal>>
        {
            unsafe
            {
                
                let mut readfds = readfds.into();
                let mut writefds = writefds.into();
                let mut errorfds = errorfds.into();
                let timeout = timeout.into();

                let nfds = nfds.into().unwrap_or_else( || {
                    readfds
                        .iter_mut()
                        .chain( writefds.iter_mut() )
                        .chain( errorfds.iter_mut() )
                        .map( |set| {
                            set.highest()
                                .map( |borrowed_fd| borrowed_fd.as_raw_fd() )
                                .unwrap_or( -1 )
                        } )
                        .max()
                        .unwrap_or( -1 )
                        + 1
                } );

                let readfds = readfds
                    .map( |set| set as *mut _ as *mut FDSet )
                    .unwrap_or( null_mut() );
                let writefds = writefds
                    .map( |set| set as *mut _ as *mut FDSet )
                    .unwrap_or( null_mut() );
                let errorfds = errorfds
                    .map( |set| set as *mut _ as *mut FDSet )
                    .unwrap_or( null_mut() );
                let timeout = timeout
                    .map( |tv| tv as *mut _ as *mut TimeValue )
                    .unwrap_or( null_mut() );

                let res = select( nfds, readfds, writefds, errorfds, timeout  );

                Errno::result( res )
            }
            
        }
        
        libc_bitflags!
        {
            /// Flags for configuring the input mode of a terminal
            pub struct InputFlags: tcflag_t {
                IGNBRK;
                BRKINT;
                IGNPAR;
                PARMRK;
                INPCK;
                ISTRIP;
                INLCR;
                IGNCR;
                ICRNL;
                IXON;
                IXOFF;
                #[cfg( not( target_os = "redox" ) )]
                IXANY;
                #[cfg( not( any( target_os = "redox", target_os = "haiku" ) ) )]
                IMAXBEL;
                #[cfg( any( linux_android, apple_targets ) )]
                IUTF8;
            }
        }

        libc_bitflags! 
        {
            /// Flags for configuring the output mode of a terminal
            pub struct OutputFlags: tcflag_t {
                OPOST;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        target_os = "openbsd" ) )]
                OLCUC;
                ONLCR;
                OCRNL as tcflag_t;
                ONOCR as tcflag_t;
                ONLRET as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                OFDEL as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                NL0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                NL1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR2 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR3 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "freebsd",
                        target_os = "haiku",
                        apple_targets ) )]
                TAB0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                TAB1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                TAB2 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "freebsd",
                        target_os = "haiku",
                        apple_targets ) )]
                TAB3 as tcflag_t;
                #[cfg( linux_android )]
                XTABS;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                BS0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                BS1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                VT0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                VT1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                FF0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                FF1 as tcflag_t;
                #[cfg( bsd )]
                OXTABS;
                #[cfg( bsd )]
                ONOEOT as tcflag_t;

                // Bitmasks for use with OutputFlags to select specific settings
                // These should be moved to be a mask once https://github.com/rust-lang-nursery/bitflags/issues/110
                // is resolved.

                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                NLDLY as tcflag_t; // FIXME: Datatype needs to be corrected in libc for mac
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CRDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "freebsd",
                        target_os = "haiku",
                        apple_targets ) )]
                TABDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                BSDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                VTDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                FFDLY as tcflag_t;
            }
        }

        libc_bitflags! 
        {
            /// Flags for setting the control mode of a terminal
            pub struct ControlFlags: tcflag_t {
                #[cfg( bsd )]
                CIGNORE;
                CS5;
                CS6;
                CS7;
                CS8;
                CSTOPB;
                CREAD;
                PARENB;
                PARODD;
                HUPCL;
                CLOCAL;
                #[cfg( not( any( target_os = "redox", target_os = "aix" ) ) )]
                CRTSCTS;
                #[cfg( linux_android )]
                CBAUD;
                #[cfg( any( target_os = "android", all( target_os = "linux", not( target_arch = "mips" ) ) ) )]
                CMSPAR;
                #[cfg( any( target_os = "android",
                        all( target_os = "linux",
                            not( any( target_arch = "powerpc", target_arch = "powerpc64" ) ) ) ) )]
                CIBAUD;
                #[cfg( linux_android )]
                CBAUDEX;
                #[cfg( bsd )]
                MDMBUF;
                #[cfg( netbsdlike )]
                CHWFLOW;
                #[cfg( any( freebsdlike, netbsdlike ) )]
                CCTS_OFLOW;
                #[cfg( any( freebsdlike, netbsdlike ) )]
                CRTS_IFLOW;
                #[cfg( freebsdlike )]
                CDTR_IFLOW;
                #[cfg( freebsdlike )]
                CDSR_OFLOW;
                #[cfg( freebsdlike )]
                CCAR_OFLOW;
                CSIZE;
            }
        }

        libc_bitflags! 
        {
            /// Flags for setting any local modes
            pub struct LocalFlags: tcflag_t {
                #[cfg( not( target_os = "redox" ) )]
                ECHOKE;
                ECHOE;
                ECHOK;
                ECHO;
                ECHONL;
                #[cfg( not( any( target_os = "redox", target_os = "cygwin" ) ) )]
                ECHOPRT;
                #[cfg( not( target_os = "redox" ) )]
                ECHOCTL;
                ISIG;
                ICANON;
                #[cfg( bsd )]
                ALTWERASE;
                IEXTEN;
                #[cfg( not( any( target_os = "redox", target_os = "haiku", target_os = "aix", target_os = "cygwin" ) ) )]
                EXTPROC;
                TOSTOP;
                #[cfg( not( target_os = "redox" ) )]
                FLUSHO;
                #[cfg( bsd )]
                NOKERNINFO;
                #[cfg( not( any( target_os = "redox", target_os = "cygwin" ) ) )]
                PENDIN;
                NOFLSH;
            }
        }
        /**
        The termios functions describe a general terminal interface that
        is provided to control asynchronous communications ports. */
        #[repr( C )] #[derive( Clone, Debug, Eq, PartialEq )]
        pub struct AsynchronousTerminalInterface
        {
            pub c_iflag: tcflag_t,
            pub c_oflag: tcflag_t,
            pub c_cflag: tcflag_t,
            pub c_lflag: tcflag_t,
            pub c_line: cc_t,
            pub c_cc: [cc_t; NCCS],
            #[cfg( not( any( 
                target_arch = "sparc",
                target_arch = "sparc64",
                target_arch = "mips",
                target_arch = "mips32r6",
                target_arch = "mips64",
                target_arch = "mips64r6"
            ) ) )]
            pub c_ispeed:speed_t,
            #[cfg( not( any( 
                target_arch = "sparc",
                target_arch = "sparc64",
                target_arch = "mips",
                target_arch = "mips32r6",
                target_arch = "mips64",
                target_arch = "mips64r6"
            ) ) )]
            pub c_ospeed:speed_t,
        }
        /// Stores settings for the termios API
        #[derive( Clone, Debug, Eq, PartialEq )]
        pub struct Termios 
        {
            inner: RefCell<AsynchronousTerminalInterface>,
            /// Input mode flags ( see `termios.c_iflag` documentation )
            pub input_flags: InputFlags,
            /// Output mode flags ( see `termios.c_oflag` documentation )
            pub output_flags: OutputFlags,
            /// Control mode flags ( see `termios.c_cflag` documentation )
            pub control_flags: ControlFlags,
            /// Local mode flags ( see `termios.c_lflag` documentation )
            pub local_flags: LocalFlags,
            /// Control characters ( see `termios.c_cc` documentation )
            pub control_chars: [cc_t; NCCS],
        }

        impl Termios
        {
            pub fn create
            ( 
                ati:AsynchronousTerminalInterface,
                input_flags:InputFlags,
                output_flags:OutputFlags,
                control_flags:ControlFlags,
                local_flags:LocalFlags,
                control_chars: [cc_t; NCCS]
            ) -> Self
            {
                Self
                {
                    inner: RefCell::new( ati ),
                    input_flags,
                    output_flags,
                    control_flags,
                    local_flags,
                    control_chars,
                }
            }
            /// Exposes an immutable reference to the underlying `AsynchronousTerminalInterface` data structure.
            pub fn get_libc_termios( &self ) -> Ref<'_, AsynchronousTerminalInterface> 
            {
                {
                    let mut termios = self.inner.borrow_mut();
                    termios.c_iflag = self.input_flags.bits();
                    termios.c_oflag = self.output_flags.bits();
                    termios.c_cflag = self.control_flags.bits();
                    termios.c_lflag = self.local_flags.bits();
                    termios.c_cc = self.control_chars;
                    #[cfg( any( linux_android, target_os = "haiku" ) )]
                    {
                        termios.c_line = self.line_discipline;
                    }
                }
                self.inner.borrow()
            }
            /// Exposes the inner `AsynchronousTerminalInterface` datastore within `Termios`.
            pub unsafe fn get_libc_termios_mut( &mut self ) -> *mut AsynchronousTerminalInterface
            {
                {
                    let mut termios = self.inner.borrow_mut();
                    termios.c_iflag = self.input_flags.bits();
                    termios.c_oflag = self.output_flags.bits();
                    termios.c_cflag = self.control_flags.bits();
                    termios.c_lflag = self.local_flags.bits();
                    termios.c_cc = self.control_chars;
                    #[cfg( any( linux_android, target_os = "haiku" ) )]
                    {
                        termios.c_line = self.line_discipline;
                    }
                }
                self.inner.as_ptr()
            }
        }

        impl From<AsynchronousTerminalInterface> for Termios
        {
            fn from( ati:AsynchronousTerminalInterface ) -> Self
            {
                let a = ati.clone();
                let input_flags   = InputFlags::from_bits_truncate( a.c_iflag  );
                let output_flags  = OutputFlags::from_bits_truncate( a.c_oflag  );
                let control_flags = ControlFlags::from_bits_truncate( a.c_cflag  );
                let local_flags   = LocalFlags::from_bits_truncate( a.c_lflag  );
                let control_chars = a.c_cc.clone();
                Termios
                {
                    inner: RefCell::new( ati ),
                    input_flags,
                    output_flags,
                    control_flags,
                    local_flags,
                    control_chars,
                    /*
                    input_flags: InputFlags::from_bits_truncate( termios.c_iflag ),
                    output_flags: OutputFlags::from_bits_truncate( termios.c_oflag ),
                    control_flags: ControlFlags::from_bits_truncate( termios.c_cflag ),
                    local_flags: LocalFlags::from_bits_truncate( termios.c_lflag ),
                    control_chars: termios.c_cc,
                    #[cfg( any( linux_android, target_os = "haiku" ) )]
                    line_discipline: termios.c_line, */
                }
            }
        }

        impl From<Termios> for AsynchronousTerminalInterface
        {
            fn from( termios: Termios ) -> Self { termios.inner.into_inner() }
        }
        /// Indices into the `termios.c_cc` array for special characters.
        #[repr( usize )] #[non_exhaustive]
        #[derive( Clone, Copy, Debug, Eq, PartialEq )]
        pub enum SpecialCharacterIndices 
        {
            VDISCARD,
            VEOF,
            VEOL,
            VEOL2,
            VERASE,
            VINTR,
            VKILL,
            VLNEXT,
            VQUIT,
            VREPRINT,
            VSTART,
            VSTATUS,
            VSTOP,
            VSUSP,
            VSWTC,
            VWERASE,
        }
        // Specify when a port configuration change should occur.
        libc_enum! 
        {
            /// Specify when a port configuration change should occur.
            ///
            /// Used as an argument to `tcsetattr()`
            #[repr( i32 )]
            #[non_exhaustive]
            pub enum SetArg {
                /// The change will occur immediately
                TCSANOW,
                /// The change occurs after all output has been written
                TCSADRAIN,
                /// Same as `TCSADRAIN`, but will also flush the input buffer
                TCSAFLUSH,
            }
        }

        pub const MICROS_PER_SEC: i64 = 1_000_000;
        
        #[cfg( target_pointer_width = "64" )]
        pub const TS_MAX_SECONDS: i64 = ( i64::MAX / NANOS_PER_SEC ) - 1;

        #[cfg( target_pointer_width = "32" )]
        pub const TS_MAX_SECONDS: i64 = isize::MAX as i64;

        pub const TS_MIN_SECONDS: i64 = -TS_MAX_SECONDS;
        
        #[cfg( target_pointer_width = "64" )]
        pub const TV_MAX_SECONDS: i64 = ( i64::MAX / MICROS_PER_SEC ) - 1;

        #[cfg( target_pointer_width = "32" )]
        pub const TV_MAX_SECONDS: i64 = isize::MAX as i64;

        pub const TV_MIN_SECONDS: i64 = -TV_MAX_SECONDS;
        
        #[cfg( all( target_arch = "x86_64", target_pointer_width = "32" ) )]
        type timespec_tv_nsec_t = i64;
        #[cfg( not( all( target_arch = "x86_64", target_pointer_width = "32" ) ) )]
        type timespec_tv_nsec_t = c_long;

        #[repr( C )] #[derive( Clone, Copy, Debug )]
        pub struct TimeSpecification
        {
            pub tv_sec: time_t,
            #[cfg( all( gnu_time_bits64, target_endian = "big" ) )]
            __pad: i32,
            #[cfg( not( all( target_arch = "x86_64", target_pointer_width = "32" ) ) )]
            pub tv_nsec: c_long,
            #[cfg( all( target_arch = "x86_64", target_pointer_width = "32" ) )]
            pub tv_nsec: i64,
            #[cfg( all( gnu_time_bits64, target_endian = "little" ) )]
            __pad: i32,
        }

        #[repr( C )] #[derive( Clone, Copy, Debug )]
        pub struct TimeSpec( TimeSpecification  );
        
        impl TimeSpec
        {
             

            pub fn nanoseconds( nanoseconds: i64 ) -> TimeSpec
            {
                let ( secs, nanos ) = div_mod_floor_64( nanoseconds, NANOS_PER_SEC );
                assert!
                ( 
                    ( TS_MIN_SECONDS..=TS_MAX_SECONDS ).contains( &secs ),
                    "TimeSpec out of bounds"
                 );
                let mut ts = zero_init_time_specification();
                ts.tv_sec = secs as time_t;
                ts.tv_nsec = nanos as timespec_tv_nsec_t;
                TimeSpec( ts )
            }
        }

        impl Eq for TimeSpec {}

        impl PartialEq for TimeSpec
        {
            fn eq( &self, other:&Self ) -> bool
            {
                self.0.tv_sec  == other.0.tv_sec &&
                self.0.tv_nsec == other.0.tv_nsec
            }
        }
        
        impl Hash for TimeSpec
        {
            fn hash<H: Hasher>( &self, state:&mut H )
            {
                self.0.tv_sec.hash( state )
            }
        }
        /// Nix's main error type.
        #[repr( i32 )] #[non_exhaustive] #[derive( Clone, Copy, Debug, Eq, PartialEq )]
        pub enum Errno
        {
            EUN = -1,
            /// Operation not permitted
            EPERM = 1,
            /// No such file or directory
            ENOENT = 2,
            /// No such process
            ESRCH = 3,
            /// Interrupted system call
            EINTR = 4,
            /// I/O error
            EIO = 5,
            /// No such device or address
            ENXIO = 6,
            /// Argument list too long
            E2BIG = 7,
            /// Exec format error
            ENOEXEC = 8,
            /// Bad file number
            EBADF = 9,
            /// No child processes
            ECHILD = 10,
            /// Try again
            EAGAIN = 11,
            /// Out of memory
            ENOMEM = 12,
            /// Permission denied
            EACCES = 13,
            /// Bad address
            EFAULT = 14,
            /// Block device required
            ENOTBLK = 15,
            /// Device or resource busy
            EBUSY = 16,
            /// File exists
            EEXIST = 17,
            /// Cross-device link
            EXDEV = 18,
            /// No such device
            ENODEV = 19,
            /// Not a directory
            ENOTDIR = 20,
            /// Is a directory
            EISDIR = 21,
            /// Invalid argument
            EINVAL = 22,
            /// File table overflow
            ENFILE = 23,
            /// Too many open files
            EMFILE = 24,
            /// Not a typewriter
            ENOTTY = 25,
            /// Text file busy
            ETXTBSY = 26,
            /// File too large
            EFBIG = 27,
            /// No space left on device
            ENOSPC = 28,
            /// Illegal seek
            ESPIPE = 29,
            /// Read-only file system
            EROFS = 30,
            /// Too many links
            EMLINK = 31,
            /// Broken pipe
            EPIPE = 32,
            /// Math argument out of domain of func
            EDOM = 33,
            /// Math result not representable
            ERANGE = 34,
            /// Resource deadlock would occur
            EDEADLK = 35,
            /// File name too long
            ENAMETOOLONG = 36,
            /// No record locks available
            ENOLCK = 37,
            /// Invalid system call number
            ENOSYS = 38,
            /// Directory not empty
            ENOTEMPTY = 39,
            /// Too many symbolic links encountered
            ELOOP = 40,
            /// No message of desired type
            ENOMSG = 42,
            /// Identifier removed
            EIDRM = 43,
            /// Channel number out of range
            ECHRNG = 44,
            /// Level 2 not synchronized
            EL2NSYNC = 45,
            /// Level 3 halted
            EL3HLT = 46,
            /// Level 3 reset
            EL3RST = 47,
            /// Link number out of range
            ELNRNG = 48,
            /// Protocol driver not attached
            EUNATCH = 49,
            /// No CSI structure available
            ENOCSI = 50,
            /// Level 2 halted
            EL2HLT = 51,
            /// Invalid exchange
            EBADE = 52,
            /// Invalid request descriptor
            EBADR = 53,
            /// Exchange full
            EXFULL = 54,
            /// No anode
            ENOANO = 55,
            /// Invalid request code
            EBADRQC = 56,
            /// Invalid slot
            EBADSLT = 57,
            /// Bad font file format
            EBFONT = 59,
            /// Device not a stream
            ENOSTR = 60,
            /// No data available
            ENODATA = 61,
            /// Timer expired
            ETIME = 62,
            /// Out of streams resources
            ENOSR = 63,
            /// Machine is not on the network
            ENONET = 64,
            /// Package not installed
            ENOPKG = 65,
            /// Object is remote
            EREMOTE = 66,
            /// Link has been severed
            ENOLINK = 67,
            /// Advertise error
            EADV = 68,
            /// Srmount error
            ESRMNT = 69,
            /// Communication error on send
            ECOMM = 70,
            /// Protocol error
            EPROTO = 71,
            /// Multihop attempted
            EMULTIHOP = 72,
            /// RFS specific error
            EDOTDOT = 73,
            /// Not a data message
            EBADMSG = 74,
            /// Value too large for defined data type
            EOVERFLOW = 75,
            /// Name not unique on network
            ENOTUNIQ = 76,
            /// File descriptor in bad state
            EBADFD = 77,
            /// Remote address changed
            EREMCHG = 78,
            /// Can not access a needed shared library
            ELIBACC = 79,
            /// Accessing a corrupted shared library
            ELIBBAD = 80,
            /// .lib section in a.out corrupted
            ELIBSCN = 81,
            /// Attempting to link in too many shared libraries
            ELIBMAX = 82,
            /// Cannot exec a shared library directly
            ELIBEXEC = 83,
            /// Illegal byte sequence
            EILSEQ = 84,
            /// Interrupted system call should be restarted
            ERESTART = 85,
            /// Streams pipe error
            ESTRPIPE = 86,
            /// Too many users
            EUSERS = 87,
            /// Socket operation on non-socket
            ENOTSOCK = 88,
            /// Destination address required
            EDESTADDRREQ = 89,
            /// Message too long
            EMSGSIZE = 90,
            /// Protocol wrong type for socket
            EPROTOTYPE = 91,
            /// Protocol not available
            ENOPROTOOPT = 92,
            /// Protocol not supported
            EPROTONOSUPPORT = 93,
            /// Socket type not supported
            ESOCKTNOSUPPORT = 94,
            /// Operation not supported on transport endpoint
            EOPNOTSUPP = 95,
            /// Protocol family not supported
            EPFNOSUPPORT = 96,
            /// Address family not supported by protocol
            EAFNOSUPPORT = 97,
            /// Address already in use
            EADDRINUSE = 98,
            /// Cannot assign requested address
            EADDRNOTAVAIL = 99,
            /// Network is down
            ENETDOWN = 100,
            /// Network is unreachable
            ENETUNREACH = 101,
            /// Network dropped connection because of reset
            ENETRESET = 102,
            /// Software caused connection abort
            ECONNABORTED = 103,
            /// Connection reset by peer
            ECONNRESET = 104,
            /// No buffer space available
            ENOBUFS = 105,
            /// Transport endpoint is already connected
            EISCONN = 106,
            /// Transport endpoint is not connected
            ENOTCONN = 107,
            /// Cannot send after transport endpoint shutdown
            ESHUTDOWN = 108,
            /// Too many references: cannot splice
            ETOOMANYREFS = 109,
            /// Connection timed out
            ETIMEDOUT = 110,
            /// Connection refused
            ECONNREFUSED = 111,
            /// Host is down
            EHOSTDOWN = 112,
            /// No route to host
            EHOSTUNREACH = 113,
            /// Operation already in progress
            EALREADY = 114,
            /// Operation now in progress
            EINPROGRESS = 115,
            /// Stale file handle
            ESTALE = 116,
            /// Structure needs cleaning
            EUCLEAN = 117,
            /// Not a XENIX named type file
            ENOTNAM = 118,
            /// No XENIX semaphores available
            ENAVAIL = 119,
            /// Is a named type file
            EISNAM = 120,
            /// Remote I/O error
            EREMOTEIO = 121,
            /// Quota exceeded
            EDQUOT = 122,
            /// No medium found
            ENOMEDIUM = 123,
            /// Wrong medium type
            EMEDIUMTYPE = 124,
            /// Operation Canceled
            ECANCELED = 125,
            /// Required key not available
            ENOKEY = 126,
            /// Key has expired
            EKEYEXPIRED = 127,
            /// Key has been revoked
            EKEYREVOKED = 128,
            /// Key was rejected by service
            EKEYREJECTED = 129,
            /// Owner died
            EOWNERDEAD = 130,
            /// State not recoverable
            ENOTRECOVERABLE = 131,
            /// Operation not possible due to RF-kill
            ERFKILL = 132,
            /// Memory page has hardware error
            EHWPOISON = 133,
        }

        impl Errno
        {
            pub const fn from_raw( err: i32 ) -> Errno { from_i32( err ) }
            /// Returns the current raw i32 value of errno
            pub fn last_raw() -> i32 { unsafe { *errno_location() } }
            /// Returns the current value of errno
            pub fn last() -> Self { Self::from_raw( Self::last_raw() ) }
            /// Returns `Ok( value )` if it does not contain the sentinel value.
            #[inline] pub fn result<S: ErrnoSentinel + PartialEq<S>>( value: S ) -> Result<S>
            {
                if value == S::sentinel() { Err( Self::last() ) }
                else { Ok( value ) }
            }
        }
        /// Indicates that a function failed and more detailed information about the error can be found in `errno`.
        pub trait ErrnoSentinel:Sized
        {
            fn sentinel() -> Self;
        }

        impl ErrnoSentinel for isize 
        {
            fn sentinel() -> Self {
                -1
            }
        }

        impl ErrnoSentinel for i32 {
            fn sentinel() -> Self {
                -1
            }
        }

        impl ErrnoSentinel for i64 {
            fn sentinel() -> Self {
                -1
            }
        }

        impl ErrnoSentinel for *mut c_void {
            fn sentinel() -> Self {
                -1isize as *mut c_void
            }
        }

        impl ErrnoSentinel for sighandler_t {
            fn sentinel() -> Self {
                libc::SIG_ERR
            }
        }
        /// Process identifier
        #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash )]
        pub struct Pid( pid_t );
        /// Represents the successful result of calling `fork`
        #[derive( Clone, Copy, Debug)]
        pub enum ForkResult
        {
            /// This is the parent process of the fork.
            Parent
            {
                /// The PID of the fork's child process
                child: Pid
            },
            /// This is the child process of the fork.
            Child,
        }

        

        fn assert_fd_valid( fd: RawFd )
        {
            assert!( 
                usize::try_from( fd ).map_or( false, |fd| fd < FD_SETSIZE ),
                "fd must be in the range 0..FD_SETSIZE",
             );
        }
        /// Return the configuration of a port.
        pub fn tcgetattraw( d:RawFd ) -> Result<Termios> 
        {
            unsafe
            {
                let mut t = ::mem::MaybeUninit::uninit();
                let r = libc::tcgetattr( d, t.as_mut_ptr()  );
                Errno::result( r )?;
                let a:AsynchronousTerminalInterface = ::mem::transmute( t.assume_init().clone()  );
                let b:AsynchronousTerminalInterface = a.clone();
                Ok
                ( 
                    Termios::create
                    ( 
                        a,
                        ::mem::transmute( b.c_iflag ),
                        ::mem::transmute( b.c_oflag ),
                        ::mem::transmute( b.c_cflag ),
                        ::mem::transmute( b.c_lflag ),
                        ::mem::transmute( b.c_cc ),
                    )
                )
                /*
                let mut t = ::mem::MaybeUninit::uninit();
                let r = libc::tcgetattr( d, t.as_mut_ptr()  );
                Errno::result( r )?;
                Ok( ::mem::transmute::<libc::termios, Termios>( t.assume_init() ) )*/
            }
        }
        /// Set the configuration for a terminal.
        pub fn tcsetattraw
        ( 
            fd: RawFd,
            actions: SetArg,
            termios:&Termios,
        ) -> Result<()> 
        {
            let inner_termios = termios.get_libc_termios();
            Errno::result( unsafe 
            {
                libc::tcsetattr
                ( 
                    fd,
                    actions as c_int,
                    ::mem::transmute( &*inner_termios ) //&*inner_termios,
                )
            } )
            .map( drop )
        }

        pub const fn from_i32( e: i32 ) -> Errno 
        {
            use self::Errno::*;

            match e 
            {
                libc::EPERM => EPERM,
                libc::ENOENT => ENOENT,
                libc::ESRCH => ESRCH,
                libc::EINTR => EINTR,
                libc::EIO => EIO,
                libc::ENXIO => ENXIO,
                libc::E2BIG => E2BIG,
                libc::ENOEXEC => ENOEXEC,
                libc::EBADF => EBADF,
                libc::ECHILD => ECHILD,
                libc::EAGAIN => EAGAIN,
                libc::ENOMEM => ENOMEM,
                libc::EACCES => EACCES,
                libc::EFAULT => EFAULT,
                libc::ENOTBLK => ENOTBLK,
                libc::EBUSY => EBUSY,
                libc::EEXIST => EEXIST,
                libc::EXDEV => EXDEV,
                libc::ENODEV => ENODEV,
                libc::ENOTDIR => ENOTDIR,
                libc::EISDIR => EISDIR,
                libc::EINVAL => EINVAL,
                libc::ENFILE => ENFILE,
                libc::EMFILE => EMFILE,
                libc::ENOTTY => ENOTTY,
                libc::ETXTBSY => ETXTBSY,
                libc::EFBIG => EFBIG,
                libc::ENOSPC => ENOSPC,
                libc::ESPIPE => ESPIPE,
                libc::EROFS => EROFS,
                libc::EMLINK => EMLINK,
                libc::EPIPE => EPIPE,
                libc::EDOM => EDOM,
                libc::ERANGE => ERANGE,
                libc::ENOMSG => ENOMSG,
                libc::EIDRM => EIDRM,
                libc::ECHRNG => ECHRNG,
                libc::EL2NSYNC => EL2NSYNC,
                libc::EL3HLT => EL3HLT,
                libc::EL3RST => EL3RST,
                libc::ELNRNG => ELNRNG,
                libc::EUNATCH => EUNATCH,
                libc::ENOCSI => ENOCSI,
                libc::EL2HLT => EL2HLT,
                libc::EDEADLK => EDEADLK,
                libc::ENOLCK => ENOLCK,
                libc::EBADE => EBADE,
                libc::EBADR => EBADR,
                libc::EXFULL => EXFULL,
                libc::ENOANO => ENOANO,
                libc::EBADRQC => EBADRQC,
                libc::EBADSLT => EBADSLT,
                //libc::EDEADLOCK => EDEADLOCK,
                libc::EBFONT => EBFONT,
                libc::ENOSTR => ENOSTR,
                libc::ENODATA => ENODATA,
                libc::ETIME => ETIME,
                libc::ENOSR => ENOSR,
                libc::ENONET => ENONET,
                libc::ENOPKG => ENOPKG,
                libc::EREMOTE => EREMOTE,
                libc::ENOLINK => ENOLINK,
                libc::EADV => EADV,
                libc::ESRMNT => ESRMNT,
                libc::ECOMM => ECOMM,
                libc::EPROTO => EPROTO,
                libc::EMULTIHOP => EMULTIHOP,
                libc::EDOTDOT => EDOTDOT,
                libc::EBADMSG => EBADMSG,
                libc::ENOTUNIQ => ENOTUNIQ,
                libc::EBADFD => EBADFD,
                libc::EREMCHG => EREMCHG,
                libc::ELIBACC => ELIBACC,
                libc::ELIBBAD => ELIBBAD,
                libc::ELIBSCN => ELIBSCN,
                libc::ELIBMAX => ELIBMAX,
                libc::ELIBEXEC => ELIBEXEC,
                libc::ENOSYS => ENOSYS,
                libc::ENOTEMPTY => ENOTEMPTY,
                libc::ENAMETOOLONG => ENAMETOOLONG,
                libc::ELOOP => ELOOP,
                libc::EOPNOTSUPP => EOPNOTSUPP,
                libc::EPFNOSUPPORT => EPFNOSUPPORT,
                libc::ECONNRESET => ECONNRESET,
                libc::ENOBUFS => ENOBUFS,
                libc::EAFNOSUPPORT => EAFNOSUPPORT,
                libc::EPROTOTYPE => EPROTOTYPE,
                libc::ENOTSOCK => ENOTSOCK,
                libc::ENOPROTOOPT => ENOPROTOOPT,
                libc::ESHUTDOWN => ESHUTDOWN,
                libc::ECONNREFUSED => ECONNREFUSED,
                libc::EADDRINUSE => EADDRINUSE,
                libc::ECONNABORTED => ECONNABORTED,
                libc::ENETUNREACH => ENETUNREACH,
                libc::ENETDOWN => ENETDOWN,
                libc::ETIMEDOUT => ETIMEDOUT,
                libc::EHOSTDOWN => EHOSTDOWN,
                libc::EHOSTUNREACH => EHOSTUNREACH,
                libc::EINPROGRESS => EINPROGRESS,
                libc::EALREADY => EALREADY,
                libc::EDESTADDRREQ => EDESTADDRREQ,
                libc::EMSGSIZE => EMSGSIZE,
                libc::EPROTONOSUPPORT => EPROTONOSUPPORT,
                libc::ESOCKTNOSUPPORT => ESOCKTNOSUPPORT,
                libc::EADDRNOTAVAIL => EADDRNOTAVAIL,
                libc::ENETRESET => ENETRESET,
                libc::EISCONN => EISCONN,
                libc::ENOTCONN => ENOTCONN,
                libc::ETOOMANYREFS => ETOOMANYREFS,
                libc::EUSERS => EUSERS,
                libc::EDQUOT => EDQUOT,
                libc::ESTALE => ESTALE,
                libc::ENOMEDIUM => ENOMEDIUM,
                libc::EILSEQ => EILSEQ,
                libc::EOVERFLOW => EOVERFLOW,
                libc::ECANCELED => ECANCELED,
                libc::ENOTRECOVERABLE => ENOTRECOVERABLE,
                libc::EOWNERDEAD => EOWNERDEAD,
                libc::ESTRPIPE => ESTRPIPE,
                _ => EUN,
            }
        }

        unsafe fn errno_location() -> *mut c_int { unsafe { libc::__errno_location() } }
        /// Read from a raw file descriptor.
        pub fn read( fd:RawFd, buf:&mut [u8] ) -> Result<usize> 
        {
            let res = unsafe {
                libc::read( 
                    fd,
                    buf.as_mut_ptr().cast(),
                    buf.len() as size_t,
                )
            };

            Errno::result( res ).map( |r| r as usize )
        }
        /// Write to a raw file descriptor.
        pub fn write( fd:RawFd, buf:&[u8] ) -> Result<usize> 
        {
            let res = unsafe {
                libc::write( 
                    fd,
                    buf.as_ptr().cast(),
                    buf.len() as size_t,
                )
            };

            Errno::result( res ).map( |r| r as usize )
        }

        #[inline] pub fn milliseconds( milliseconds: i64 ) -> TimeSpec
        {
            let nanoseconds = milliseconds
            .checked_mul( 1_000_000 )
            .expect( "TimeSpec::milliseconds out of bounds" );

            TimeSpec::nanoseconds( nanoseconds )
        }

        #[inline] pub fn div_rem_64( this: i64, other: i64 ) -> ( i64, i64 ) { ( this / other, this % other ) }
        
        #[inline] pub fn div_floor_64( this: i64, other: i64 ) -> i64
        {
            match div_rem_64( this, other )
            {
                ( d, r ) if ( r > 0 && other < 0 ) || ( r < 0 && other > 0 ) => d - 1,
                ( d, _ ) => d,
            }
        }
        
        #[inline] pub fn mod_floor_64( this: i64, other: i64 ) -> i64
        {
            match this % other 
            {
                r if ( r > 0 && other < 0 ) || ( r < 0 && other > 0 ) => r + other,
                r => r,
            }
        }

        #[inline] pub fn div_mod_floor_64( this: i64, other: i64 ) -> ( i64, i64 )
        {
            ( div_floor_64( this, other ), mod_floor_64( this, other ) )
        }
        /// Makes a new `TimeVal` with given number of nanoseconds.
        #[inline] pub fn nanoseconds( nanoseconds: i64 ) -> TimeVal 
        {
            let microseconds = nanoseconds / 1000;
            let ( secs, micros ) = div_mod_floor_64( microseconds, MICROS_PER_SEC );
            assert!( 
                ( TV_MIN_SECONDS..=TV_MAX_SECONDS ).contains( &secs ),
                "TimeVal out of bounds"
             );
            // https://github.com/rust-lang/libc/issues/1848
            TimeVal( TimeValue {
                tv_sec: secs as time_t,
                tv_usec: micros as suseconds_t,
            } )
        }
        
        pub const fn zero_init_time_specification() -> TimeSpecification
        {
            unsafe { ::mem::transmute( [0u8; ::mem::size_of::<TimeSpecification>()] ) }
        }
        
        pub fn FD_ISSET( fd:c_int, set:*const FDSet ) -> bool
        {
            unsafe
            {
                let fd = fd as usize;
                let size = size_of_val( &( *set ).fds_bits[0] ) * 8;
                return ( ( *set ).fds_bits[fd / size] & ( 1 << ( fd % size ) ) ) != 0;
            }
        }
        /// Changes the action taken by a process on receipt of a specific signal.
        //pub unsafe fn sigaction( signal: Signal, sigaction:&SigAction ) -> Result<SigAction> 
        pub unsafe fn react( s: Signal, a:&SigAction ) -> Result<SigAction>
        {
            let mut oldact = mem::MaybeUninit::<SignalAction>::uninit();

            let res = unsafe { sigaction( s as c_int,
                                    &a.sigaction as *const SignalAction,
                                    oldact.as_mut_ptr() ) };

            Errno::result( res ).map( |_| SigAction { sigaction: unsafe { oldact.assume_init() } } )
        }

        pub fn FD_SET( fd:c_int, set:*mut FDSet ) -> ()
        {
            unsafe
            {
                let fd = fd as usize;
                let size = size_of_val( &( *set ).fds_bits[0] ) * 8;
                ( *set ).fds_bits[fd / size] |= 1 << ( fd % size );
                return;
            }
        }

        pub fn FD_ZERO( set:*mut FDSet ) -> ()
        {
            unsafe
            {
                for slot in &mut ( *set ).fds_bits
                {
                    *slot = 0;
                }
            }
        }
    }
    /*
    mortal v0.0.0 */
    pub mod common
    {
        /*!
        Platform-independent terminal interface */
        use ::
        {
            fs::{ File },
            io::{ BufWriter, Write },
            path::{ Path },
            *,
        };
        /*
        pub use crate::sequence::{FindResult, SequenceMap};
        */
        pub static mut BOOLEANS:String = String::new();
        pub const BOOLEAN:&[&str] = 
        &[
            "auto_left_margin", "auto_right_margin", "no_esc_ctlc", "ceol_standout_glitch", "eat_newline_glitch",
            "erase_overstrike", "generic_type", "hard_copy", "has_meta_key", "has_status_line", "insert_null_glitch",
            "memory_above", "memory_below", "move_insert_mode", "move_standout_mode", "over_strike",
            "status_line_esc_ok", "dest_tabs_magic_smso", "tilde_glitch", "transparent_underline", "xon_xoff",
            "needs_xon_xoff", "prtr_silent", "hard_cursor", "non_rev_rmcup", "no_pad_char", "non_dest_scroll_region",
            "can_change", "back_color_erase", "hue_lightness_saturation", "col_addr_glitch", "cr_cancels_micro_mode",
            "has_print_wheel", "row_addr_glitch", "semi_auto_right_margin", "cpi_changes_res", "lpi_changes_res",
            "backspaces_with_bs", "crt_no_scrolling", "no_correctly_working_cr", "gnu_has_meta_key",
            "linefeed_is_newline", "has_hardware_tabs", "return_does_clr_eol"
        ];

        pub static mut NUMBERS:String = String::new();
        pub const NUMBER:&[&str] = 
        &[
            "columns", "init_tabs", "lines", "lines_of_memory", "magic_cookie_glitch", "padding_baud_rate", 
            "virtual_terminal", "width_status_line", "num_labels", "label_height", "label_width", "max_attributes",
            "maximum_windows", "max_colors", "max_pairs", "no_color_video", "buffer_capacity", "dot_vert_spacing",
            "dot_horz_spacing", "max_micro_address", "max_micro_jump", "micro_col_size", "micro_line_size",
            "number_of_pins", "output_res_char", "output_res_line", "output_res_horz_inch", "output_res_vert_inch",
            "print_rate", "wide_char_size", "buttons", "bit_image_entwining", "bit_image_type",
            "magic_cookie_glitch_ul", "carriage_return_delay", "new_line_delay", "backspace_delay",
            "horizontal_tab_delay", "number_of_function_keys"
        ];
        
        pub static mut STRINGS:String = String::new();
        pub const STRING:&[&str] = 
        &[
            "back_tab", "bell", "carriage_return", "change_scroll_region", "clear_all_tabs", "clear_screen",
            "clr_eol", "clr_eos", "column_address", "command_character", "cursor_address", "cursor_down",
            "cursor_home", "cursor_invisible", "cursor_left", "cursor_mem_address", "cursor_normal", "cursor_right",
            "cursor_to_ll", "cursor_up", "cursor_visible", "delete_character", "delete_line", "dis_status_line",
            "down_half_line", "enter_alt_charset_mode", "enter_blink_mode", "enter_bold_mode", "enter_ca_mode",
            "enter_delete_mode", "enter_dim_mode", "enter_insert_mode", "enter_secure_mode", "enter_protected_mode",
            "enter_reverse_mode", "enter_standout_mode", "enter_underline_mode", "erase_chars",
            "exit_alt_charset_mode", "exit_attribute_mode", "exit_ca_mode", "exit_delete_mode", "exit_insert_mode",
            "exit_standout_mode", "exit_underline_mode", "flash_screen", "form_feed", "from_status_line",
            "init_1string", "init_2string", "init_3string", "init_file", "insert_character", "insert_line",
            "insert_padding", "key_backspace", "key_catab", "key_clear", "key_ctab", "key_dc", "key_dl", "key_down",
            "key_eic", "key_eol", "key_eos", "key_f0", "key_f1", "key_f10", "key_f2", "key_f3", "key_f4", "key_f5",
            "key_f6", "key_f7", "key_f8", "key_f9", "key_home", "key_ic", "key_il", "key_left", "key_ll",
            "key_npage", "key_ppage", "key_right", "key_sf", "key_sr", "key_stab", "key_up", "keypad_local",
            "keypad_xmit", "lab_f0", "lab_f1", "lab_f10", "lab_f2", "lab_f3", "lab_f4", "lab_f5", "lab_f6", "lab_f7",
            "lab_f8", "lab_f9", "meta_off", "meta_on", "newline", "pad_char", "parm_dch", "parm_delete_line",
            "parm_down_cursor", "parm_ich", "parm_index", "parm_insert_line", "parm_left_cursor", "parm_right_cursor",
            "parm_rindex", "parm_up_cursor", "pkey_key", "pkey_local", "pkey_xmit", "print_screen", "prtr_off",
            "prtr_on", "repeat_char", "reset_1string", "reset_2string", "reset_3string", "reset_file",
            "restore_cursor", "row_address", "save_cursor", "scroll_forward", "scroll_reverse", "set_attributes",
            "set_tab", "set_window", "tab", "to_status_line", "underline_char", "up_half_line", "init_prog", "key_a1",
            "key_a3", "key_b2", "key_c1", "key_c3", "prtr_non", "char_padding", "acs_chars", "plab_norm", "key_btab",
            "enter_xon_mode", "exit_xon_mode", "enter_am_mode", "exit_am_mode", "xon_character", "xoff_character",
            "ena_acs", "label_on", "label_off", "key_beg", "key_cancel", "key_close", "key_command", "key_copy",
            "key_create", "key_end", "key_enter", "key_exit", "key_find", "key_help", "key_mark", "key_message",
            "key_move", "key_next", "key_open", "key_options", "key_previous", "key_print", "key_redo",
            "key_reference", "key_refresh", "key_replace", "key_restart", "key_resume", "key_save", "key_suspend",
            "key_undo", "key_sbeg", "key_scancel", "key_scommand", "key_scopy", "key_screate", "key_sdc", "key_sdl",
            "key_select", "key_send", "key_seol", "key_sexit", "key_sfind", "key_shelp", "key_shome", "key_sic", 
            "key_sleft", "key_smessage", "key_smove", "key_snext", "key_soptions", "key_sprevious", "key_sprint",
            "key_sredo", "key_sreplace", "key_sright", "key_srsume", "key_ssave", "key_ssuspend", "key_sundo",
            "req_for_input", "key_f11", "key_f12", "key_f13", "key_f14", "key_f15", "key_f16", "key_f17", "key_f18",
            "key_f19", "key_f20", "key_f21", "key_f22", "key_f23", "key_f24", "key_f25", "key_f26", "key_f27",
            "key_f28", "key_f29", "key_f30", "key_f31", "key_f32", "key_f33", "key_f34", "key_f35", "key_f36",
            "key_f37", "key_f38", "key_f39", "key_f40", "key_f41", "key_f42", "key_f43", "key_f44", "key_f45",
            "key_f46", "key_f47", "key_f48", "key_f49", "key_f50", "key_f51", "key_f52", "key_f53", "key_f54",
            "key_f55", "key_f56", "key_f57", "key_f58", "key_f59", "key_f60", "key_f61", "key_f62", "key_f63",
            "clr_bol", "clear_margins", "set_left_margin", "set_right_margin", "label_format", "set_clock",
            "display_clock", "remove_clock", "create_window", "goto_window", "hangup", "dial_phone", "quick_dial",
            "tone", "pulse", "flash_hook", "fixed_pause", "wait_tone", "user0", "user1", "user2", "user3", "user4",
            "user5", "user6", "user7", "user8", "user9", "orig_pair", "orig_colors", "initialize_color",
            "initialize_pair", "set_color_pair", "set_foreground", "set_background", "change_char_pitch",
            "change_line_pitch", "change_res_horz", "change_res_vert", "define_char", "enter_doublewide_mode",
            "enter_draft_quality", "enter_italics_mode", "enter_leftward_mode", "enter_micro_mode",
            "enter_near_letter_quality", "enter_normal_quality", "enter_shadow_mode", "enter_subscript_mode",
            "enter_superscript_mode", "enter_upward_mode", "exit_doublewide_mode", "exit_italics_mode",
            "exit_leftward_mode", "exit_micro_mode", "exit_shadow_mode", "exit_subscript_mode",
            "exit_superscript_mode", "exit_upward_mode", "micro_column_address", "micro_down", "micro_left",
            "micro_right", "micro_row_address", "micro_up", "order_of_pins", "parm_down_micro", "parm_left_micro",
            "parm_right_micro", "parm_up_micro", "select_char_set", "set_bottom_margin", "set_bottom_margin_parm",
            "set_left_margin_parm", "set_right_margin_parm", "set_top_margin", "set_top_margin_parm",
            "start_bit_image", "start_char_set_def", "stop_bit_image", "stop_char_set_def", "subscript_characters",
            "superscript_characters", "these_cause_cr", "zero_motion", "char_set_names", "key_mouse", "mouse_info",
            "req_mouse_pos", "get_mouse", "set_a_foreground", "set_a_background", "pkey_plab", "device_type",
            "code_set_init", "set0_des_seq", "set1_des_seq", "set2_des_seq", "set3_des_seq", "set_lr_margin",
            "set_tb_margin", "bit_image_repeat", "bit_image_newline", "bit_image_carriage_return", "color_names",
            "define_bit_image_region", "end_bit_image_region", "set_color_band", "set_page_length", "display_pc_char",
            "enter_pc_charset_mode", "exit_pc_charset_mode", "enter_scancode_mode", "exit_scancode_mode",
            "pc_term_options", "scancode_escape", "alt_scancode_esc", "enter_horizontal_hl_mode",
            "enter_left_hl_mode", "enter_low_hl_mode", "enter_right_hl_mode", "enter_top_hl_mode", 
            "enter_vertical_hl_mode", "set_a_attributes", "set_pglen_inch", "termcap_init2", "termcap_reset", 
            "linefeed_if_not_lf", "backspace_if_not_bs", "other_non_function_keys", "arrow_key_map", "acs_ulcorner",
            "acs_llcorner", "acs_urcorner", "acs_lrcorner", "acs_ltee", "acs_rtee", "acs_btee", "acs_ttee",
            "acs_hline", "acs_vline", "acs_plus", "memory_lock", "memory_unlock", "box_chars_1"
        ];
        
        pub static mut INFORMATION:String = String::new();
        pub static mut ALIASES:String = String::new();
        pub const TERMINFO:&[( &str, &str )] = 
        &[
            // Boolean names.
            ( "auto_left_margin", "bw" ), ( "auto_right_margin", "am" ), ( "back_color_erase", "bce" ),
            ( "can_change", "ccc" ), ( "ceol_standout_glitch", "xhp" ), ( "col_addr_glitch", "xhpa" ), ( "cpi_changes_res", "cpix" ),
            ( "cr_cancels_micro_mode", "crxm" ),
            ( "dest_tabs_magic_smso", "xt" ),
            ( "eat_newline_glitch", "xenl" ),
            ( "erase_overstrike", "eo" ),
            ( "generic_type", "gn" ),
            ( "hard_copy", "hc" ),
            ( "hard_cursor", "chts" ),
            ( "has_meta_key", "km" ),
            ( "has_print_wheel", "daisy" ),
            ( "has_status_line", "hs" ),
            ( "hue_lightness_saturation", "hls" ),
            ( "insert_null_glitch", "in" ),
            ( "lpi_changes_res", "lpix" ),
            ( "memory_above", "da" ),
            ( "memory_below", "db" ),
            ( "move_insert_mode", "mir" ),
            ( "move_standout_mode", "msgr" ),
            ( "needs_xon_xoff", "nxon" ),
            ( "no_esc_ctlc", "xsb" ),
            ( "no_pad_char", "npc" ),
            ( "non_dest_scroll_region", "ndscr" ),
            ( "non_rev_rmcup", "nrrmc" ),
            ( "over_strike", "os" ),
            ( "prtr_silent", "mc5i" ),
            ( "row_addr_glitch", "xvpa" ),
            ( "semi_auto_right_margin", "sam" ),
            ( "status_line_esc_ok", "eslok" ),
            ( "tilde_glitch", "hz" ),
            ( "transparent_underline", "ul" ),
            ( "xon_xoff", "xon" ),
            // Number names.
            ( "bit_image_entwining", "bitwin" ),
            ( "bit_image_type", "bitype" ),
            ( "buffer_capacity", "bufsz" ),
            ( "buttons", "btns" ),
            ( "columns", "cols" ),
            ( "dot_horz_spacing", "spinh" ),
            ( "dot_vert_spacing", "spinv" ),
            ( "init_tabs", "it" ),
            ( "label_height", "lh" ),
            ( "label_width", "lw" ),
            ( "lines", "lines" ),
            ( "lines_of_memory", "lm" ),
            ( "max_attributes", "ma" ),
            ( "magic_cookie_glitch", "xmc" ),
            ( "max_colors", "colors" ),
            ( "max_micro_address", "maddr" ),
            ( "max_micro_jump", "mjump" ),
            ( "max_pairs", "pairs" ),
            ( "maximum_windows", "wnum" ),
            ( "micro_col_size", "mcs" ),
            ( "micro_line_size", "mls" ),
            ( "no_color_video", "ncv" ),
            ( "num_labels", "nlab" ),
            ( "number_of_pins", "npins" ),
            ( "output_res_char", "orc" ),
            ( "output_res_line", "orl" ),
            ( "output_res_horz_inch", "orhi" ),
            ( "output_res_vert_inch", "orvi" ),
            ( "padding_baud_rate", "pb" ),
            ( "print_rate", "cps" ),
            ( "virtual_terminal", "vt" ),
            ( "wide_char_size", "widcs" ),
            ( "width_status_line", "wsl" ),
            // String names.
            ( "acs_chars", "acsc" ),
            ( "alt_scancode_esc", "scesa" ),
            ( "back_tab", "cbt" ),
            ( "bell", "bel" ),
            ( "bit_image_carriage_return", "bicr" ),
            ( "bit_image_newline", "binel" ),
            ( "bit_image_repeat", "birep" ),
            ( "carriage_return", "cr" ),
            ( "change_char_pitch", "cpi" ),
            ( "change_line_pitch", "lpi" ),
            ( "change_res_horz", "chr" ),
            ( "change_res_vert", "cvr" ),
            ( "change_scroll_region", "csr" ),
            ( "char_padding", "rmp" ),
            ( "char_set_names", "csnm" ),
            ( "clear_all_tabs", "tbc" ),
            ( "clear_margins", "mgc" ),
            ( "clear_screen", "clear" ),
            ( "clr_bol", "el1" ),
            ( "clr_eol", "el" ),
            ( "clr_eos", "ed" ),
            ( "code_set_init", "csin" ),
            ( "color_names", "colornm" ),
            ( "column_address", "hpa" ),
            ( "command_character", "cmdch" ),
            ( "create_window", "cwin" ),
            ( "cursor_address", "cup" ),
            ( "cursor_down", "cud1" ),
            ( "cursor_home", "home" ),
            ( "cursor_invisible", "civis" ),
            ( "cursor_left", "cub1" ),
            ( "cursor_mem_address", "mrcup" ),
            ( "cursor_normal", "cnorm" ),
            ( "cursor_right", "cuf1" ),
            ( "cursor_to_ll", "ll" ),
            ( "cursor_up", "cuu1" ),
            ( "cursor_visible", "cvvis" ),
            ( "define_bit_image_region", "defbi" ),
            ( "define_char", "defc" ),
            ( "delete_character", "dch1" ),
            ( "delete_line", "dl1" ),
            ( "device_type", "devt" ),
            ( "dial_phone", "dial" ),
            ( "dis_status_line", "dsl" ),
            ( "display_clock", "dclk" ),
            ( "display_pc_char", "dispc" ),
            ( "down_half_line", "hd" ),
            ( "ena_acs", "enacs" ),
            ( "end_bit_image_region", "endbi" ),
            ( "enter_alt_charset_mode", "smacs" ),
            ( "enter_am_mode", "smam" ),
            ( "enter_blink_mode", "blink" ),
            ( "enter_bold_mode", "bold" ),
            ( "enter_ca_mode", "smcup" ),
            ( "enter_delete_mode", "smdc" ),
            ( "enter_dim_mode", "dim" ),
            ( "enter_doublewide_mode", "swidm" ),
            ( "enter_draft_quality", "sdrfq" ),
            ( "enter_horizontal_hl_mode", "ehhlm" ),
            ( "enter_insert_mode", "smir" ),
            ( "enter_italics_mode", "sitm" ),
            ( "enter_left_hl_mode", "elhlm" ),
            ( "enter_leftward_mode", "slm" ),
            ( "enter_low_hl_mode", "elohlm" ),
            ( "enter_micro_mode", "smicm" ),
            ( "enter_near_letter_quality", "snlq" ),
            ( "enter_normal_quality", "snrmq" ),
            ( "enter_pc_charset_mode", "smpch" ),
            ( "enter_protected_mode", "prot" ),
            ( "enter_reverse_mode", "rev" ),
            ( "enter_right_hl_mode", "erhlm" ),
            ( "enter_scancode_mode", "smsc" ),
            ( "enter_secure_mode", "invis" ),
            ( "enter_shadow_mode", "sshm" ),
            ( "enter_standout_mode", "smso" ),
            ( "enter_subscript_mode", "ssubm" ),
            ( "enter_superscript_mode", "ssupm" ),
            ( "enter_top_hl_mode", "ethlm" ),
            ( "enter_underline_mode", "smul" ),
            ( "enter_upward_mode", "sum" ),
            ( "enter_vertical_hl_mode", "evhlm" ),
            ( "enter_xon_mode", "smxon" ),
            ( "erase_chars", "ech" ),
            ( "exit_alt_charset_mode", "rmacs" ),
            ( "exit_am_mode", "rmam" ),
            ( "exit_attribute_mode", "sgr0" ),
            ( "exit_ca_mode", "rmcup" ),
            ( "exit_delete_mode", "rmdc" ),
            ( "exit_doublewide_mode", "rwidm" ),
            ( "exit_insert_mode", "rmir" ),
            ( "exit_italics_mode", "ritm" ),
            ( "exit_leftward_mode", "rlm" ),
            ( "exit_micro_mode", "rmicm" ),
            ( "exit_pc_charset_mode", "rmpch" ),
            ( "exit_scancode_mode", "rmsc" ),
            ( "exit_shadow_mode", "rshm" ),
            ( "exit_standout_mode", "rmso" ),
            ( "exit_subscript_mode", "rsubm" ),
            ( "exit_superscript_mode", "rsupm" ),
            ( "exit_underline_mode", "rmul" ),
            ( "exit_upward_mode", "rum" ),
            ( "exit_xon_mode", "rmxon" ),
            ( "fixed_pause", "pause" ),
            ( "flash_hook", "hook" ),
            ( "flash_screen", "flash" ),
            ( "form_feed", "ff" ),
            ( "from_status_line", "fsl" ),
            ( "get_mouse", "getm" ),
            ( "goto_window", "wingo" ),
            ( "hangup", "hup" ),
            ( "init_1string", "is1" ),
            ( "init_2string", "is2" ),
            ( "init_3string", "is3" ),
            ( "init_file", "if" ),
            ( "init_prog", "iprog" ),
            ( "initialize_color", "initc" ),
            ( "initialize_pair", "initp" ),
            ( "insert_character", "ich1" ),
            ( "insert_line", "il1" ),
            ( "insert_padding", "ip" ),
            ( "key_a1", "ka1" ),
            ( "key_a3", "ka3" ),
            ( "key_b2", "kb2" ),
            ( "key_backspace", "kbs" ),
            ( "key_beg", "kbeg" ),
            ( "key_btab", "kcbt" ),
            ( "key_c1", "kc1" ),
            ( "key_c3", "kc3" ),
            ( "key_cancel", "kcan" ),
            ( "key_catab", "ktbc" ),
            ( "key_clear", "kclr" ),
            ( "key_close", "kclo" ),
            ( "key_command", "kcmd" ),
            ( "key_copy", "kcpy" ),
            ( "key_create", "kcrt" ),
            ( "key_ctab", "kctab" ),
            ( "key_dc", "kdch1" ),
            ( "key_dl", "kdl1" ),
            ( "key_down", "kcud1" ),
            ( "key_eic", "krmir" ),
            ( "key_end", "kend" ),
            ( "key_enter", "kent" ),
            ( "key_eol", "kel" ),
            ( "key_eos", "ked" ),
            ( "key_exit", "kext" ),
            ( "key_f0", "kf0" ),
            ( "key_f1", "kf1" ),
            ( "key_f62", "kf62" ),
            ( "key_f63", "kf63" ),
            ( "key_find", "kfnd" ),
            ( "key_help", "khlp" ),
            ( "key_home", "khome" ),
            ( "key_ic", "kich1" ),
            ( "key_il", "kil1" ),
            ( "key_left", "kcub1" ),
            ( "key_ll", "kll" ),
            ( "key_mark", "kmrk" ),
            ( "key_message", "kmsg" ),
            ( "key_mouse", "kmous" ),
            ( "key_move", "kmov" ),
            ( "key_next", "knxt" ),
            ( "key_npage", "knp" ),
            ( "key_open", "kopn" ),
            ( "key_options", "kopt" ),
            ( "key_ppage", "kpp" ),
            ( "key_previous", "kprv" ),
            ( "key_print", "kprt" ),
            ( "key_redo", "krdo" ),
            ( "key_reference", "kref" ),
            ( "key_refresh", "krfr" ),
            ( "key_replace", "krpl" ),
            ( "key_restart", "krst" ),
            ( "key_resume", "kres" ),
            ( "key_right", "kcuf1" ),
            ( "key_save", "ksav" ),
            ( "key_sbeg", "kBEG" ),
            ( "key_scancel", "kCAN" ),
            ( "key_scommand", "kCMD" ),
            ( "key_scopy", "kCPY" ),
            ( "key_screate", "kCRT" ),
            ( "key_sdc", "kDC" ),
            ( "key_sdl", "kDL" ),
            ( "key_select", "kslt" ),
            ( "key_send", "kEND" ),
            ( "key_seol", "kEOL" ),
            ( "key_sexit", "kEXT" ),
            ( "key_sf", "kind" ),
            ( "key_sfind", "kFND" ),
            ( "key_shelp", "kHLP" ),
            ( "key_shome", "kHOM" ),
            ( "key_sic", "kIC" ),
            ( "key_sleft", "kLFT" ),
            ( "key_smessage", "kMSG" ),
            ( "key_smove", "kMOV" ),
            ( "key_snext", "kNXT" ),
            ( "key_soptions", "kOPT" ),
            ( "key_sprevious", "kPRV" ),
            ( "key_sprint", "kPRT" ),
            ( "key_sr", "kri" ),
            ( "key_sredo", "kRDO" ),
            ( "key_sreplace", "kRPL" ),
            ( "key_sright", "kRIT" ),
            ( "key_srsume", "kRES" ),
            ( "key_ssave", "kSAV" ),
            ( "key_ssuspend", "kSPD" ),
            ( "key_stab", "khts" ),
            ( "key_sundo", "kUND" ),
            ( "key_suspend", "kspd" ),
            ( "key_undo", "kund" ),
            ( "key_up", "kcuu1" ),
            ( "keypad_local", "rmkx" ),
            ( "keypad_xmit", "smkx" ),
            ( "lab_f0", "lf0" ),
            ( "lab_f1", "lf1" ),
            ( "lab_f2", "lf2" ),
            ( "lab_f3", "lf3" ),
            ( "lab_f4", "lf4" ),
            ( "lab_f5", "lf5" ),
            ( "lab_f6", "lf6" ),
            ( "lab_f7", "lf7" ),
            ( "lab_f8", "lf8" ),
            ( "lab_f9", "lf9" ),
            ( "lab_f10", "lf10" ),
            ( "label_format", "fln" ),
            ( "label_off", "rmln" ),
            ( "label_on", "smln" ),
            ( "meta_off", "rmm" ),
            ( "meta_on", "smm" ),
            ( "micro_column_address", "mhpa" ),
            ( "micro_down", "mcud1" ),
            ( "micro_left", "mcub1" ),
            ( "micro_right", "mcuf1" ),
            ( "micro_row_address", "mvpa" ),
            ( "micro_up", "mcuu1" ),
            ( "mouse_info", "minfo" ),
            ( "newline", "nel" ),
            ( "order_of_pins", "porder" ),
            ( "orig_colors", "oc" ),
            ( "orig_pair", "op" ),
            ( "pad_char", "pad" ),
            ( "parm_dch", "dch" ),
            ( "parm_delete_line", "dl" ),
            ( "parm_down_cursor", "cud" ),
            ( "parm_down_micro", "mcud" ),
            ( "parm_ich", "ich" ),
            ( "parm_index", "indn" ),
            ( "parm_insert_line", "il" ),
            ( "parm_left_cursor", "cub" ),
            ( "parm_left_micro", "mcub" ),
            ( "parm_right_cursor", "cuf" ),
            ( "parm_right_micro", "mcuf" ),
            ( "parm_rindex", "rin" ),
            ( "parm_up_cursor", "cuu" ),
            ( "parm_up_micro", "mcuu" ),
            ( "pc_term_options", "pctrm" ),
            ( "pkey_key", "pfkey" ),
            ( "pkey_local", "pfloc" ),
            ( "pkey_plab", "pfxl" ),
            ( "pkey_xmit", "pfx" ),
            ( "plab_norm", "pln" ),
            ( "print_screen", "mc0" ),
            ( "prtr_non", "mc5p" ),
            ( "prtr_off", "mc4" ),
            ( "prtr_on", "mc5" ),
            ( "pulse", "pulse" ),
            ( "quick_dial", "qdial" ),
            ( "remove_clock", "rmclk" ),
            ( "repeat_char", "rep" ),
            ( "req_for_input", "rfi" ),
            ( "req_mouse_pos", "reqmp" ),
            ( "reset_1string", "rs1" ),
            ( "reset_2string", "rs2" ),
            ( "reset_3string", "rs3" ),
            ( "reset_file", "rf" ),
            ( "restore_cursor", "rc" ),
            ( "row_address", "vpa" ),
            ( "save_cursor", "sc" ),
            ( "scancode_escape", "scesc" ),
            ( "scroll_forward", "ind" ),
            ( "scroll_reverse", "ri" ),
            ( "select_char_set", "scs" ),
            ( "set0_des_seq", "s0ds" ),
            ( "set1_des_seq", "s1ds" ),
            ( "set2_des_seq", "s2ds" ),
            ( "set3_des_seq", "s3ds" ),
            ( "set_a_attributes", "sgr1" ),
            ( "set_a_background", "setab" ),
            ( "set_a_foreground", "setaf" ),
            ( "set_attributes", "sgr" ),
            ( "set_background", "setb" ),
            ( "set_bottom_margin", "smgb" ),
            ( "set_bottom_margin_parm", "smgbp" ),
            ( "set_clock", "sclk" ),
            ( "set_color_band", "setcolor" ),
            ( "set_color_pair", "scp" ),
            ( "set_foreground", "setf" ),
            ( "set_left_margin", "smgl" ),
            ( "set_left_margin_parm", "smglp" ),
            ( "set_lr_margin", "smglr" ),
            ( "set_page_length", "slines" ),
            ( "set_pglen_inch", "slength" ),
            ( "set_right_margin", "smgr" ),
            ( "set_right_margin_parm", "smgrp" ),
            ( "set_tab", "hts" ),
            ( "set_tb_margin", "smgtb" ),
            ( "set_top_margin", "smgt" ),
            ( "set_top_margin_parm", "smgtp" ),
            ( "set_window", "wind" ),
            ( "start_bit_image", "sbim" ),
            ( "start_char_set_def", "scsd" ),
            ( "stop_bit_image", "rbim" ),
            ( "stop_char_set_def", "rcsd" ),
            ( "subscript_characters", "subcs" ),
            ( "superscript_characters", "supcs" ),
            ( "tab", "ht" ),
            ( "these_cause_cr", "docr" ),
            ( "to_status_line", "tsl" ),
            ( "tone", "tone" ),
            ( "user0", "u0" ),
            ( "user1", "u1" ),
            ( "user2", "u2" ),
            ( "user3", "u3" ),
            ( "user4", "u4" ),
            ( "user5", "u5" ),
            ( "user6", "u6" ),
            ( "user7", "u7" ),
            ( "user8", "u8" ),
            ( "user9", "u9" ),
            ( "underline_char", "uc" ),
            ( "up_half_line", "hu" ),
            ( "wait_tone", "wait" ),
            ( "xoff_character", "xoffc" ),
            ( "xon_character", "xonc" ),
            ( "zero_motion", "zerom" ), 
        ];

        pub const CanIdentTriplet:&[( &str, &str, &str, &str, &str, &str, &str, &str )] = 
        &[
            //define!( string SetTrueColorBackground => "8b"; r: u8, g: u8, b: u8 );
            ( 
                "SetTrueColorBackground", "8b",
                "r", "0",
                "g", "0",
                "b", "0",
            )
        ];

        pub const CanIdent:&[( &str, &str )] = 
        &[
            //define!( string ResetCursorColor => "Cr" );
            ( "ResetCursorColor", "Cr" )
        ];

        pub const CanIdentKeyValue:&[( &str, &str, &str, &str )] = 
        &[
            //define!( string SetCursorColor => "Cs"; color: String );
            ( "SetCursorColor", "Cs", "color", "white" )
        ];
        //string builder direct $ident:ident; $index:expr, $name:ident : $ty:ty

        pub static mut DATABASE:String = String::new();

        pub fn build() -> Result<(), error::parse::ParseError>
        {
            unsafe
            {
                /*
                Handle Booleans Table */
                BOOLEANS.push_str( r#"booleans:  {
                "#  );

                for ( index, name ) in BOOLEAN.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    BOOLEANS.push_str
                    ( 
                        format!( r#"   b{}: "{}"
                        "#, index, name ).as_str()
                     );
                }

                BOOLEANS.push_str( r#"}"#  );
                /*
                Handle Numbers Table */
                NUMBERS.push_str( r#"numbers:  {
                "#  );

                for ( index, name ) in NUMBER.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    NUMBERS.push_str
                    ( 
                        format!( r#"   n{}: "{}"
                    "#, index, name ).as_str()
                     );
                }

                NUMBERS.push_str( r#"}"#  );
                /*
                Handle Strings Table */
                STRINGS.push_str( r#"strings:  {
                "#  );

                for ( index, name ) in STRING.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    STRINGS.push_str
                    ( 
                        format!( r#"   s{}: "{}"
                    "#, index, name ).as_str()
                     );
                }

                STRINGS.push_str( r#"}"#  );
                /*
                Handle Information & Alias Table */
                INFORMATION.push_str( r#"information:  {
                "#  );
                ALIASES.push_str( r#"aliases:  {
                "#  );

                for ( index, pair ) in TERMINFO.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    INFORMATION.push_str
                    ( 
                        format!( r#"   i{}: ( "{}" "{}" )
                        "#, index, pair.0, pair.1 ).as_str()
                     );

                    ALIASES.push_str
                    ( 
                        format!( r#"   {}: "{}"
                        "#, pair.0, pair.1 ).as_str()
                     );
                }

                INFORMATION.push_str( r#"}"#  );

                ALIASES.push_str( r#"}"#  );

                DATABASE = format!( r#"
                {}
                {}
                {}
                {}
                {}
                "#, BOOLEANS, NUMBERS, STRINGS, INFORMATION, ALIASES  );
                Ok( () )
            }
        }
        
        pub mod buffer
        {
            /*!
            */
            use ::
            {
                mem::{ swap },
                ops::{ Range },
                str::{ SmallString },
                system::
                {
                    common::
                    {
                       terminal::{ Color, Cursor, Size, Style, Theme }, 
                    },
                },
                *,
            };
            /*
            use crate::terminal::{Color, Cursor, Size, Style, Theme};
            use crate::util::{char_width, is_combining_mark};
            */
            const TAB_STOP: usize = 8;

            pub struct ScreenBuffer 
            {
                buffer: Vec<Cell>,
                back_buffer: Vec<Cell>,
                size: Size,
                cursor: Cursor,
                fg: Option<Color>,
                bg: Option<Color>,
                style: Style,
            }

            impl ScreenBuffer 
            {
                pub fn new( size: Size ) -> ScreenBuffer 
                {
                    let area = size.area();

                    ScreenBuffer
                    {
                        buffer: vec![Cell::default(); area],
                        back_buffer: vec![Cell::default(); area],
                        size: size,
                        cursor: Cursor::default(),

                        fg: None,
                        bg: None,
                        style: Style::empty(),
                    }
                }

                pub fn cursor( &self ) -> Cursor { self.cursor }

                pub fn size( &self ) -> Size { self.size }

                pub fn resize( &mut self, new_size: Size )
                {
                    resize_buffer( &mut self.buffer, self.size, new_size );
                    new_buffer( &mut self.back_buffer, new_size );
                    self.size = new_size;
                }

                pub fn set_cursor( &mut self, pos: Cursor ) { self.cursor = pos; }

                pub fn next_line( &mut self, column: usize )
                {
                    self.cursor.line += 1;
                    self.cursor.column = column;
                }

                pub fn clear_attributes( &mut self )
                {
                    self.fg = None;
                    self.bg = None;
                    self.style = Style::empty();
                }

                pub fn add_style( &mut self, style: Style ) { self.style |= style; }

                pub fn remove_style( &mut self, style: Style ) { self.style -= style; }

                pub fn set_style( &mut self, style: Style ) { self.style = style; }

                pub fn set_fg( &mut self, fg: Option<Color> ) { self.fg = fg; }

                pub fn set_bg( &mut self, bg: Option<Color> ) { self.bg = bg; }

                pub fn set_theme( &mut self, theme: Theme )
                {
                    self.set_fg( theme.fg );
                    self.set_bg( theme.bg );
                    self.set_style( theme.style );
                }

                pub fn clear_screen( &mut self )
                {
                    for cell in &mut self.buffer
                    {
                        *cell = Cell::default();
                    }
                }

                pub fn indices( &self ) -> Range<usize> { 0..self.size.area() }
                
                pub fn next_cell( &mut self, indices:&mut Range<usize> ) -> Option<( Cursor, Cell )>
                {
                    while let Some( idx ) = indices.next() 
                    {
                        let first = self.buffer[idx].first_char();
                        let width = char::width( first ).unwrap_or( 0 );
                        
                        if width == 2 { let _ = indices.next(); }

                        if self.buffer[idx] != self.back_buffer[idx]
                        {
                            let cell = self.buffer[idx].clone();
                            let line = idx / self.size.columns;
                            let column = idx % self.size.columns;
                            self.back_buffer[idx] = cell.clone();
                            return Some( ( Cursor{line, column}, cell ) );
                        }
                    }

                    None
                }                

                fn cell_mut( &mut self, pos: Cursor ) -> &mut Cell 
                {
                    let size = self.size;
                    &mut self.buffer[pos.as_index( size )]
                }

                fn set_cell( &mut self, pos: Cursor, ch:char ) 
                {
                    let fg = self.fg;
                    let bg = self.bg;
                    let style = self.style;

                    let cell = self.cell_mut( pos );

                    cell.fg = fg;
                    cell.bg = bg;
                    cell.style = style;
                    cell.text = ch.into();
                }

                pub fn write_char( &mut self, ch:char ) -> Result<(), OutOfBounds> 
                {
                    if ch == '\t'
                    {
                        self.try_cursor()?;
                        let rem = self.size.columns - self.cursor.column;
                        let n = rem.min( TAB_STOP - ( self.cursor.column % TAB_STOP ) );

                        for _ in 0..n
                        {
                            self.write_char( ' ' )?;
                        }
                    }

                    else if ch == '\r' { self.cursor.column = 0; }
                    
                    else if ch == '\n'
                    {
                        self.cursor.line += 1;
                        self.cursor.column = 0;
                    }
                    
                    else if is::combining_mark( ch )
                    {
                        if let Some( prev ) = self.cursor.previous( self.size )
                        {
                            self.try_cursor_at( prev )?;
                            self.cell_mut( prev ).text.push( ch );
                        }
                    }
                    
                    else if is::visible( ch )
                    {
                        self.try_cursor()?;

                        if let Some( prev ) = self.cursor.previous( self.size )
                        {
                            let cell = self.cell_mut( prev );

                            if cell.is_wide() { *cell = Cell::default(); }
                        }

                        let rem = self.size.columns - self.cursor.column;
                        let width = char::width( ch ).unwrap_or( 0 );
                        
                        if rem < width 
                        {
                            self.try_cursor()?;
                            let mut pos = self.cursor;

                            for _ in 0..rem {
                                self.set_cell( pos, ch );
                                pos.column += 1;
                            }

                            self.cursor.column = 0;
                            self.cursor.line += 1;
                        }

                        self.try_cursor()?;

                        let mut pos = self.cursor;
                        self.set_cell( pos, ch );

                        for _ in 1..width 
                        {
                            pos.column += 1;
                            self.set_cell( pos, ' ' );
                        }

                        self.cursor.column += width;

                        if self.cursor.column >= self.size.columns 
                        {
                            self.cursor.line += 1;
                            self.cursor.column = 0;
                        }
                    }

                    Ok( () )
                }

                pub fn write_str( &mut self, s:&str ) -> Result<(), OutOfBounds>
                {
                    for ch in s.chars()
                    {
                        self.write_char( ch )?;
                    }

                    Ok( () )
                }

                pub fn write_at( &mut self, pos: Cursor, text:&str ) -> Result<(), OutOfBounds>
                {
                    self.try_cursor_at( pos )?;
                    self.cursor = pos;
                    self.write_str( text )
                }

                pub fn write_styled
                ( 
                    &mut self,
                    fg: Option<Color>,
                    bg: Option<Color>,
                    style: Style, text:&str
                ) -> Result<(), OutOfBounds>
                {
                    self.fg = fg;
                    self.bg = bg;
                    self.style = style;
                    self.write_str( text )?;
                    self.clear_attributes();
                    Ok( () )
                }

                pub fn write_styled_at
                ( 
                    &mut self,
                    pos: Cursor,
                    fg: Option<Color>,
                    bg: Option<Color>,
                    style: Style,
                    text:&str
                ) -> Result<(), OutOfBounds>
                {
                    self.try_cursor_at( pos )?;
                    self.cursor = pos;
                    self.write_styled( fg, bg, style, text )
                }

                fn try_cursor( &self ) -> Result<(), OutOfBounds> { self.try_cursor_at( self.cursor ) }

                fn try_cursor_at( &self, pos: Cursor ) -> Result<(), OutOfBounds>
                {
                    if pos.line >= self.size.lines || pos.column >= self.size.columns
                    { Err( OutOfBounds( () ) ) }
                    else { Ok( () ) }
                }
            }

            #[derive( Debug )]
            pub struct OutOfBounds( () );

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Cell 
            {
                fg: Option<Color>,
                bg: Option<Color>,
                style: Style,
                text: SmallString<[u8; 8]>,
            }

            impl Cell 
            {
                fn new( fg: Option<Color>, bg: Option<Color>, style: Style, chr:char ) -> Cell
                {
                    Cell
                    {
                        fg,
                        bg,
                        style,
                        text: chr.into(),
                    }
                }

                fn invalid() -> Cell 
                {
                    Cell
                    {
                        fg: None,
                        bg: None,
                        style: Style::empty(),
                        text: SmallString::new(),
                    }
                }

                pub fn attrs( &self ) -> ( Option<Color>, Option<Color>, Style )
                { ( self.fg, self.bg, self.style ) }

                pub fn text( &self ) -> &str { &self.text }

                fn first_char( &self ) -> char { self.text.chars().next().expect( "empty cell text" ) }

                fn is_wide( &self ) -> bool
                { self.text.chars().next().and_then( char::width ).unwrap_or( 0 ) == 2 }
            }

            impl Default for Cell 
            {
                fn default() -> Cell {
                    Cell::new( None, None, Style::empty(), ' ' )
                }
            }

            fn resize_buffer( buf:&mut Vec<Cell>, old: Size, new: Size ) 
            {
                if old != new
                {
                    let mut new_buf = vec![Cell::default(); new.area()];

                    if !buf.is_empty() 
                    {
                        let n_cols = old.columns.min( new.columns );

                        for ( old, new ) in buf
                        .chunks_mut( old.columns )
                        .zip( new_buf.chunks_mut( new.columns ) ) 
                        {
                            for i in 0..n_cols
                            {
                                swap( &mut new[i], &mut old[i] );
                            }
                        }
                    }

                    *buf = new_buf;
                }
            }

            fn new_buffer( buf:&mut Vec<Cell>, new_size: Size )
            {
                *buf = vec![Cell::invalid(); new_size.area()];
            }
        }

        pub mod screen
        {
            /*!
            Provides a drawable buffer on terminal devices */
            use ::
            {
                map::{ map_lock_result, map_try_lock_result },
                sync::{ LockResult, TryLockResult },
                system::
                {
                    common::
                    {
                        terminal::
                        {
                            Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style, Theme, 
                            Terminal,
                        }
                    },
                },
                time::std::{ Duration },
                *,
            };

            use super::sys;
            /*
            */
            /// Provides operations on an underlying terminal device in screen mode.
            pub struct Screen( sys::Screen  );
            /// Holds an exclusive lock for read operations on a `Screen`.
            pub struct ScreenReadGuard<'a>( sys::ScreenReadGuard<'a>  );
            /// Holds an exclusive lock for write operations on a `Screen`.
            pub struct ScreenWriteGuard<'a>( sys::ScreenWriteGuard<'a>  );

            impl Screen
            {
                /// Opens a new screen interface on `stdout`.
                pub fn new( config: PrepareConfig ) -> io::Result<Screen>
                { sys::Screen::stdout( config ).map( Screen ) }
                /// Opens a new screen interface on `stderr`.
                pub fn stderr( config: PrepareConfig ) -> io::Result<Screen>
                { sys::Screen::stderr( config ).map( Screen ) }
                /// Begins a new screen session using the given `Terminal` instance.
                pub fn with_terminal( term: Terminal, config: PrepareConfig ) -> io::Result<Screen>
                { sys::Screen::new( term.0, config ).map( Screen ) }
                /// Returns the name of the terminal.
                #[inline] pub fn name( &self ) -> &str { self.0.name() }
                /// Attempts to acquire an exclusive lock on terminal read operations.
                #[inline] pub fn lock_read( &self ) -> LockResult<ScreenReadGuard>
                { map_lock_result( self.0.lock_read(), ScreenReadGuard ) }
                /// Attempts to acquire an exclusive lock on terminal write operations.
                #[inline] pub fn lock_write( &self ) -> LockResult<ScreenWriteGuard>
                { map_lock_result( self.0.lock_write(), ScreenWriteGuard ) }
                /// Attempts to acquire an exclusive lock on terminal read operations.
                #[inline] pub fn try_lock_read( &self ) -> TryLockResult<ScreenReadGuard>
                { map_try_lock_result( self.0.try_lock_read(), ScreenReadGuard ) }
                /// Attempts to acquire an exclusive lock on terminal write operations.
                #[inline] pub fn try_lock_write( &self ) -> TryLockResult<ScreenWriteGuard>
                { map_try_lock_result( self.0.try_lock_write(), ScreenWriteGuard ) }
                /// Waits for an event from the terminal.
                pub fn wait_event( &self, timeout: Option<Duration> ) -> io::Result<bool> {
                    self.0.wait_event( timeout )
                }
                /// Reads an event from the terminal.
                pub fn read_event( &self, timeout: Option<Duration> ) -> io::Result<Option<Event>>  {
                    self.0.read_event( timeout )
                }
                /// Returns the current size of the terminal screen.
                #[inline] pub fn size( &self ) -> Size {
                    self.0.size()
                }
                /// Returns the current cursor position.
                #[inline] pub fn cursor( &self ) -> Cursor {
                    self.0.cursor()
                }
                /// Sets the cursor position.
                #[inline] pub fn set_cursor<C: Into<Cursor>>( &self, pos: C ) {
                    self.0.set_cursor( pos.into() );
                }
                /// Moves the cursor to the given column on the next line.
                #[inline] pub fn next_line( &self, column: usize ) {
                    self.0.next_line( column );
                }
                /// Set the current cursor mode.
                pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()> {
                    self.0.set_cursor_mode( mode )
                }
                /// Clears the internal screen buffer.
                pub fn clear_screen( &self ) {
                    self.0.clear_screen();
                }
                /// Adds a set of `Style` flags to the current style setting.
                #[inline] pub fn add_style( &self, style: Style ) {
                    self.0.add_style( style );
                }
                /// Removes a set of `Style` flags to the current style setting.
                #[inline] pub fn remove_style( &self, style: Style ) {
                    self.0.remove_style( style );
                }
                /// Sets the current style setting to the given set of flags.
                #[inline] pub fn set_style<S: Into<Option<Style>>>( &self, style: S ) {
                    self.0.set_style( style.into().unwrap_or_default() );
                }
                /// Sets or removes foreground text color.
                #[inline] pub fn set_fg<C: Into<Option<Color>>>( &self, fg: C ) {
                    self.0.set_fg( fg.into() );
                }
                /// Sets or removes background text color.
                #[inline] pub fn set_bg<C: Into<Option<Color>>>( &self, bg: C ) {
                    self.0.set_bg( bg.into() );
                }
                /// Sets all attributes for the screen.
                #[inline] pub fn set_theme( &self, theme: Theme ) {
                    self.0.set_theme( theme )
                }
                /// Removes color and style attributes.
                #[inline] pub fn clear_attributes( &self ) {
                    self.0.clear_attributes();
                }
                /// Adds bold to the current style setting.
                #[inline] pub fn bold( &self ) {
                    self.add_style( Style::BOLD );
                }
                /// Adds italic to the current style setting.
                #[inline] pub fn italic( &self ) {
                    self.add_style( Style::ITALIC );
                }
                /// Adds underline to the current style setting.
                #[inline] pub fn underline( &self ) {
                    self.add_style( Style::UNDERLINE );
                }
                /// Adds reverse to the current style setting.
                #[inline] pub fn reverse( &self ) {
                    self.add_style( Style::REVERSE );
                }
                /// Renders the internal buffer to the terminal screen.
                pub fn refresh( &self ) -> io::Result<()> {
                    self.0.refresh()
                }
                /// Writes text at the given position within the screen buffer.
                pub fn write_at<C>( &self, position: C, text:&str )
                        where C: Into<Cursor> {
                    self.0.write_at( position.into(), text );
                }
                /// Writes text with the given attributes at the current cursor position.
                pub fn write_styled<F, B, S>( &self, fg: F, bg: B, style: S, text:&str ) where
                        F: Into<Option<Color>>,
                        B: Into<Option<Color>>,
                        S: Into<Option<Style>>,
                        {
                    self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), text );
                }
                /// Writes text with the given attributes at the given position within
                /// the screen buffer.
                pub fn write_styled_at<C, F, B, S>( &self, position: C,
                        fg: F, bg: B, style: S, text:&str ) where
                        C: Into<Cursor>,
                        F: Into<Option<Color>>,
                        B: Into<Option<Color>>,
                        S: Into<Option<Style>>,
                        {
                    self.0.write_styled_at( position.into(),
                        fg.into(), bg.into(), style.into().unwrap_or_default(), text );
                }
                /// Writes a single character at the cursor position
                /// using the current style and color settings.
                pub fn write_char( &self, ch:char ) {
                    self.0.write_char( ch );
                }
                /// Writes a string at the cursor position
                /// using the current style and color settings.
                pub fn write_str( &self, s:&str ) {
                    self.0.write_str( s  );
                }
                /// Writes formatted text at the cursor position
                /// using the current style and color settings.
                pub fn write_fmt( &self, args: fmt::Arguments ) {
                    let s = args.to_string();
                    self.write_str( &s )
                }

                #[doc( hidden )]
                pub fn borrow_term_write_guard( &self ) -> ScreenWriteGuard {
                    self.lock_write().unwrap()
                }
            }

            impl<'a> ScreenReadGuard<'a>
            {
                /// Waits for an event from the terminal.
                pub fn wait_event( &mut self, timeout: Option<Duration> ) -> io::Result<bool>
                { self.0.wait_event( timeout ) }
                /// Reads an event from the terminal.
                pub fn read_event( &mut self, timeout: Option<Duration> ) -> io::Result<Option<Event>>
                { self.0.read_event( timeout ) }
            }

            impl<'a> ScreenWriteGuard<'a>
            {
                /// Returns the current size of the terminal screen.
                #[inline] pub fn size( &self ) -> Size { self.0.size() }
                /// Sets the cursor position.
                #[inline] pub fn cursor( &self ) -> Cursor { self.0.cursor() }
                /// Moves the cursor to the given column on the next line.
                #[inline] pub fn set_cursor<C: Into<Cursor>>( &mut self, pos: C ) 
                { self.0.set_cursor( pos.into() ); }
                /// Set the current cursor mode.
                #[inline] pub fn next_line( &mut self, column: usize ) { self.0.next_line( column ); }
                /// Set the current cursor mode.
                pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> 
                { self.0.set_cursor_mode( mode ) }
                /// Adds a set of `Style` flags to the current style setting.
                pub fn clear_screen( &mut self ) { self.0.clear_screen(); }
                /// Removes a set of `Style` flags to the current style setting.
                /// Adds a set of `Style` flags to the current style setting.
                #[inline] pub fn add_style( &mut self, style: Style ) { self.0.add_style( style ) }
                /// Sets the current style setting to the given set of flags.
                #[inline] pub fn remove_style( &mut self, style:Style ) { self.0.remove_style( style ) }
                /// Sets or removes foreground text color.
                #[inline] pub fn set_style<S: Into<Option<Style>>>( &mut self, style: S ) 
                { self.0.set_style( style.into().unwrap_or_default() ) }
                /// Sets or removes background text color.
                #[inline] pub fn set_fg<C: Into<Option<Color>>>( &mut self, fg: C ) 
                { self.0.set_fg( fg.into() ) }
                /// Removes color and style attributes.
                #[inline] pub fn set_bg<C: Into<Option<Color>>>( &mut self, bg: C ) 
                { self.0.set_bg( bg.into() ) }
                /// Sets all attributes for the screen.
                #[inline] pub fn set_theme( &mut self, theme: Theme ) { self.0.set_theme( theme ) }
                /// Adds bold to the current style setting.
                #[inline] pub fn clear_attributes( &mut self ) { self.0.clear_attributes() }
                /// Adds bold to the current style setting.
                #[inline] pub fn bold( &mut self ) { self.add_style( Style::BOLD ) }
                /// Adds italic to the current style setting.
                #[inline] pub fn italic( &mut self ) { self.add_style( Style::ITALIC ); }
                /// Adds underline to the current style setting.
                #[inline] pub fn underline( &mut self ) { self.add_style( Style::UNDERLINE ) }
                /// Adds reverse to the current style setting.
                #[inline] pub fn reverse( &mut self ) { self.add_style( Style::REVERSE ) }
                /// Renders the internal buffer to the terminal screen.
                pub fn refresh( &mut self ) -> io::Result<()> { self.0.refresh() }
                /// Writes text at the given position within the screen buffer.
                pub fn write_at<C>( &mut self, position: C, text:&str ) where 
                C: Into<Cursor>
                { self.0.write_at( position.into(), text ) }
                /// Writes text with the given attributes at the current cursor position.
                pub fn write_styled<F,B,S>( &mut self, fg: F, bg: B, style: S, text:&str ) where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                {
                    self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), text )
                }
                /// Writes text with the given attributes at the given position within
                /// the screen buffer.
                pub fn write_styled_at<C,F,B,S>
                ( 
                    &mut self,
                    position:C,
                    fg:F,
                    bg:B,
                    style:S,
                    text:&str
                ) where
                C: Into<Cursor>,
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                {
                    self.0.write_styled_at
                    ( position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text )
                }
                /// Writes a single character at the cursor position
                /// using the current style and color settings.
                pub fn write_char( &mut self, ch:char ) { self.0.write_char( ch ) }
                /// Writes a string at the cursor position
                /// using the current style and color settings.
                pub fn write_str( &mut self, s:&str ) { self.0.write_str( s ) }
                /// Writes formatted text at the cursor position
                /// using the current style and color settings.
                pub fn write_fmt( &mut self, args: fmt::Arguments )
                {
                    let s = args.to_string();
                    self.write_str( &s )
                }
                
                pub fn borrow_term_write_guard( &mut self ) -> &mut Self { self }
            }

            #[cfg( unix )] impl sys::TerminalExt for Screen
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout: Option<Duration> ) ->
                io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }

            #[cfg( unix )] impl<'a> sys::TerminalExt for ScreenReadGuard<'a>
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout: Option<Duration> ) ->
                io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }
            /*
            #[cfg( windows )]
            impl crate::windows::TerminalExt for Screen {
                fn read_raw( &mut self, buf:&mut [u16], timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw( buf, timeout )
                }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw_event( events, timeout )
                }
            }

            #[cfg( windows )]
            impl<'a> crate::windows::TerminalExt for ScreenReadGuard<'a> {
                fn read_raw( &mut self, buf:&mut [u16], timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw( buf, timeout )
                }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw_event( events, timeout )
                }
            } */
        } pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard };

        pub mod signal
        {
            /*!
            */
            use ::
            {
                iter::{ FromIterator },
                *,
            };
            /*
            */
            pub const NUM_SIGNALS: u8 = 6;
            
            macro_rules! impl_op
            {
                ( $tr:ident , $tr_meth:ident , $method:ident ) =>
                {
                    impl ops::$tr for SignalSet
                    {
                        type Output = SignalSet;
                        fn $tr_meth( self, rhs: SignalSet ) -> SignalSet { self.$method( rhs ) }
                    }
                }
            }

            macro_rules! impl_mut_op
            {
                ( $tr:ident , $tr_meth:ident , $method:ident ) =>
                {
                    impl ops::$tr for SignalSet
                    {
                        fn $tr_meth( &mut self, rhs: SignalSet ) { *self = self.$method( rhs ); }
                    }
                }
            }

            macro_rules! impl_unary_op
            {
                ( $tr:ident , $tr_meth:ident , $method:ident ) =>
                {
                    impl ops::$tr for SignalSet
                    {
                        type Output = SignalSet;
                        fn $tr_meth( self ) -> SignalSet { self.$method() }
                    }
                }
            }
            /// Signal received through a terminal device
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Signal
            {
                /// Break signal ( `CTRL_BREAK_EVENT` ); Windows only
                Break,
                /// Continue signal ( `SIGCONT` ); Unix only
                Continue,
                /// Interrupt signal ( `SIGINT` on Unix, `CTRL_C_EVENT` on Windows )
                Interrupt,
                /// Terminal resize ( `SIGWINCH` on Unix, `WINDOW_BUFFER_SIZE_EVENT` on Windows )
                Resize,
                /// Suspend signal ( `SIGTSTP` ); Unix only
                Suspend,
                /// Quit signal ( `SIGQUIT` ); Unix only
                Quit,
            }
            
            impl Signal
            {
                fn as_bit( &self ) -> u8 { 1 << ( *self as u8 ) }
                fn all_bits() -> u8 { ( 1 << NUM_SIGNALS ) - 1 }
            }

            impl ops::BitOr for Signal
            {
                type Output = SignalSet;
                fn bitor( self, rhs: Signal ) -> SignalSet
                {
                    let mut set = SignalSet::new();
                    set.insert( self );
                    set.insert( rhs );
                    set
                }
            }

            impl ops::Not for Signal
            {
                type Output = SignalSet;
                fn not( self ) -> SignalSet { !SignalSet::from( self ) }
            }
            /// Represents a set of `Signal` values
            #[derive( Copy, Clone, Default, Eq, PartialEq )]
            pub struct SignalSet( u8  );

            impl SignalSet
            {
                /// Returns an empty `SignalSet`.
                pub fn new() -> SignalSet { SignalSet( 0 ) }
                /// Returns a `SignalSet` containing all available signals.
                pub fn all() -> SignalSet { SignalSet( Signal::all_bits() ) }
                /// Returns whether this set contains the given `Signal`.
                pub fn contains( &self, sig: Signal ) -> bool { self.0 & sig.as_bit() != 0 }
                /// Returns whether this set contains all signals present in another set.
                pub fn contains_all( &self, other: SignalSet ) -> bool { self.0 & other.0 == other.0 }
                /// Returns whether this set contains any signals present in another set.
                pub fn intersects( &self, other: SignalSet ) -> bool { self.0 & other.0 != 0 }
                /// Returns whether this set contains any signals.
                pub fn is_empty( &self ) -> bool { self.0 == 0 }
                /// Inserts a `Signal` into this set.
                pub fn insert( &mut self, sig: Signal ) { self.0 |= sig.as_bit(); }
                /// Removes a `Signal` from this set.
                pub fn remove( &mut self, sig: Signal ) { self.0 &= !sig.as_bit(); }
                /// Sets whether this set contains the given `Signal`.
                pub fn set( &mut self, sig: Signal, set: bool )
                {
                    if set { self.insert( sig ); }
                    else { self.remove( sig ); }
                }
                /// Returns the difference of two sets.
                pub fn difference( &self, other: SignalSet ) -> SignalSet
                { SignalSet( self.0 & !other.0 ) }
                /// Returns the symmetric difference of two sets.
                pub fn symmetric_difference( &self, other: SignalSet ) -> SignalSet
                { SignalSet( self.0 ^ other.0 ) }
                /// Returns the intersection of two sets.
                pub fn intersection( &self, other: SignalSet ) -> SignalSet
                { SignalSet( self.0 & other.0 ) }
                /// Returns the union of two sets.
                pub fn union( &self, other: SignalSet ) -> SignalSet { SignalSet( self.0 | other.0 ) }
                /// Returns the inverse of the set.
                pub fn inverse( &self ) -> SignalSet { SignalSet( !self.0 & Signal::all_bits() ) }
            }

            impl fmt::Debug for SignalSet
            {
                fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
                {
                    const SIGNALS:&[Signal] = &
                    [
                        Signal::Break,
                        Signal::Continue,
                        Signal::Interrupt,
                        Signal::Resize,
                        Signal::Suspend,
                        Signal::Quit,
                    ];

                    let mut first = true;

                    f.write_str( "SignalSet( " )?;

                    for &sig in SIGNALS
                    {
                        if self.contains( sig )
                        {
                            if !first { f.write_str( " | " )?; }

                            write!( f, "{:?}", sig )?;
                            first = false;
                        }
                    }

                    f.write_str( " )" )
                }
            }

            impl From<Signal> for SignalSet
            {
                fn from( sig: Signal ) -> SignalSet
                {
                    let mut set = SignalSet::new();
                    set.insert( sig );
                    set
                }
            }

            impl Extend<Signal> for SignalSet
            {
                fn extend<I: IntoIterator<Item=Signal>>( &mut self, iter: I )
                {
                    for sig in iter
                    {
                        self.insert( sig );
                    }
                }
            }

            impl FromIterator<Signal> for SignalSet
            {
                fn from_iter<I: IntoIterator<Item=Signal>>( iter: I ) -> SignalSet
                {
                    let mut set = SignalSet::new();
                    set.extend( iter );
                    set
                }
            }

            impl_op!{ BitAnd, bitand, intersection }
            impl_op!{ BitOr, bitor, union }
            impl_op!{ BitXor, bitxor, symmetric_difference }
            impl_op!{ Sub, sub, difference }
            impl_unary_op!{ Not, not, inverse }
            impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
            impl_mut_op!{ BitOrAssign, bitor_assign, union }
            impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
            impl_mut_op!{ SubAssign, sub_assign, difference }
        } pub use self::signal::{ Signal, SignalSet };

        pub mod terminal        
        {
            /*!
            Provides an interface to terminal devices. */
            use ::
            {
                map::{ map_lock_result, map_try_lock_result },
                sync::{ LockResult, TryLockResult },
                time::std::{ Duration },
                *,
            };
            use super::{ sys, Signal, SignalSet };
            /*
            */
            /// Represents a color attribute applied to text foreground or background.
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Color
            {
                /// Black
                Black,
                /// Blue
                Blue,
                /// Cyan
                Cyan,
                /// Green
                Green,
                /// Magenta
                Magenta,
                /// Red
                Red,
                /// White
                White,
                /// Yellow
                Yellow,
            }

            bitflags!
            {
                /// Represents a set of style attributes applied to text.
                #[derive( Copy, Clone, Debug, Default, Eq, PartialEq, Hash )]
                pub struct Style: u8
                {
                    /// Bold
                    const BOLD      = 1 << 0;
                    /// Italic
                    const ITALIC    = 1 << 1;
                    /// Reverse; foreground and background color swapped
                    const REVERSE   = 1 << 2;
                    /// Underline
                    const UNDERLINE = 1 << 3;
                }
            }
            /// Represents a terminal output theme.
            #[derive( Copy, Clone, Debug, Default )]
            pub struct Theme
            {
                /// Foreground color
                pub fg: Option<Color>,
                /// Background color
                pub bg: Option<Color>,
                /// Style
                pub style: Style,
            }

            impl Theme
            {
                /// Creates a new theme with given values.
                pub fn new<F,B,S>( fg: F, bg: B, style: S ) -> Theme where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                {
                    Theme
                    {
                        fg: fg.into(),
                        bg: bg.into(),
                        style: style.into().unwrap_or_default(),
                    }
                }
                /// Sets the foreground color on the given Theme and returns the new.
                pub fn fg<F>( mut self, fg: F ) -> Theme where
                F: Into<Option<Color>>
                {
                    self.fg = fg.into();
                    self
                }
                /// Sets the background color on the given Theme and returns the new.
                pub fn bg<B>( mut self, bg: B ) -> Theme where
                B: Into<Option<Color>>
                {
                    self.bg = bg.into();
                    self
                }
                /// Sets the style on the given Theme and returns the new.
                pub fn style<S>( mut self, style: S ) -> Theme where
                S:Into<Option<Style>>
                {
                    self.style = style.into().unwrap_or_default();
                    self
                }
            }
            /// Represents the cursor position in a terminal device
            #[derive( Copy, Clone, Debug, Default, Eq, PartialEq )]
            pub struct Cursor
            {
                /// Index of line in terminal, beginning at `0`.
                pub line: usize,
                /// Index of column in terminal, beginning at `0`.
                pub column: usize,
            }

            impl Cursor
            {
                /// Returns the position of the next cell within a terminal of the given size.
                #[inline] pub fn next( &self, size: Size ) -> Option<Cursor>
                {
                    let mut line = self.line;
                    let mut column = self.column + 1;

                    if column >= size.columns
                    {
                        column = 0;
                        line += 1;
                    }

                    if line >= size.lines { None }
                    else { Some( Cursor{line, column} ) }
                }
                /// Returns the position of the previous cell within a terminal of the given size.
                #[inline] pub fn previous( &self, size: Size ) -> Option<Cursor>
                {
                    if self.column == 0
                    {
                        if self.line == 0 { None }
                        else { Some( Cursor{line: self.line - 1, column: size.columns - 1} ) }
                    }

                    else { Some( Cursor{line: self.line, column: self.column - 1} ) }
                }
                /// Returns a `Cursor` pointing to the first cell, i.e. `( 0, 0 )`.
                #[inline] pub fn first() -> Cursor
                {
                    Cursor
                    {
                        line: 0,
                        column: 0,
                    }
                }
                /// Returns a `Cursor` pointing to the last cell of a screen of the given size.
                #[inline] pub fn last( size: Size ) -> Cursor
                {
                    Cursor
                    {
                        line: size.lines - 1,
                        column: size.columns - 1,
                    }
                }
                /// Returns whether the cursor is out of bounds of the given size.
                #[inline] pub fn is_out_of_bounds( &self, size: Size ) -> bool 
                {
                    self.line >= size.lines || self.column >= size.columns
                }
                /// Returns index of the cursor position within a one-dimensional array
                /// of the given size.
                pub fn as_index( &self, size: Size ) -> usize 
                { self.line * size.columns + self.column }
            }

            impl From<( usize, usize )> for Cursor
            {
                /// Returns a `Cursor` value from a `( line, column )` or `( y, x )` tuple.
                fn from( ( line, column ): ( usize, usize ) ) -> Cursor { Cursor{line, column} }
            }
            /// Represents the visual appearance of the cursor in the terminal
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum CursorMode
            {
                /// Normal mode
                Normal,
                /// Invisible mode
                Invisible,
                /// Overwrite mode
                Overwrite,
            }
            /// Represents an event generated from a terminal interface
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Event
            {
                /// Keyboard event
                Key( Key ),
                /// Mouse event
                Mouse( MouseEvent ),
                /// Raw data read
                Raw( usize ),
                /// Terminal window size changed; contained value is the new size.
                Resize( Size ),
                /// Terminal signal received
                Signal( Signal ),
                /// No event.
                NoEvent,
            }
            /// Represents a keyboard key press event
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Key
            {
                /// Backspace
                Backspace,
                /// Enter
                Enter,
                /// Escape
                Escape,
                /// Tab
                Tab,
                /// Up arrow
                Up,
                /// Down arrow
                Down,
                /// Left arrow
                Left,
                /// Right arrow
                Right,
                /// Delete
                Delete,
                /// Insert
                Insert,
                /// Home
                Home,
                /// End
                End,
                /// PageUp
                PageUp,
                /// PageDown
                PageDown,
                /// Character key
                Char( char ),
                /// Control character
                Ctrl( char ),
                /// Function `n` key; e.g. F1, F2, ...
                F( u32 ),
            }

            impl From<char> for Key
            {
                fn from( ch:char ) -> Key
                {
                    use ::char::unctrl_lower;
                    match ch
                    {
                        '\x1b' => Key::Escape,
                        '\x7f' => Key::Backspace,
                        '\r' | '\n' => Key::Enter,
                        '\t' => Key::Tab,
                        _ if is::control( ch ) => Key::Ctrl( unctrl_lower( ch ) ),
                        _ => Key::Char( ch ),
                    }
                }
            }
            /// Represents a mouse event
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub struct MouseEvent
            {
                /// The position of the mouse within the terminal when the event occurred
                pub position: Cursor,
                /// The input event that occurred
                pub input: MouseInput,
                /// Modifier keys held when the input event occurred.
                pub modifiers: ModifierState,
            }
            /// Represents the type of mouse input event
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum MouseInput
            {
                /// The mouse cursor was moved
                Motion,
                /// A mouse button was pressed
                ButtonPressed( MouseButton ),
                /// A mouse button was released
                ButtonReleased( MouseButton ),
                /// The mouse wheel was scrolled up
                WheelUp,
                /// The mouse wheel was scrolled down
                WheelDown,
            }
            /// Represents a button on a mouse device
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum MouseButton
            {
                /// Left mouse button
                Left,
                /// Right mouse button
                Right,
                /// Middle mouse button
                Middle,
                /// Other mouse button
                Other( u32 ),
            }

            bitflags!
            {
                /// Represents a set of modifier keys
                #[derive( Copy, Clone, Debug, Eq, PartialEq, Hash )]
                pub struct ModifierState: u8
                {
                    /// Alt key
                    const ALT   = 1 << 0;
                    /// Ctrl key
                    const CTRL  = 1 << 1;
                    /// Shift key
                    const SHIFT = 1 << 2;
                }
            }
            /// Configures a [`Terminal`] or [`Screen`] instance to read special input.
            #[derive( Copy, Clone, Debug )]
            pub struct PrepareConfig
            {
                /// Whether to block signals that result from user input.
                pub block_signals: bool,
                /// Whether to enable control flow characters.
                pub enable_control_flow: bool,
                /// If `true`, terminal will be configured to generate events from function keys.
                pub enable_keypad: bool,
                /// If `true`, the terminal will be configured to generate events for
                /// mouse input, if supported, and `read_event` may return `Event::Mouse( _ )`.
                pub enable_mouse: bool,
                /// If `true`, mouse motion events will always be reported.
                /// If `false`, such events will only be reported while at least one mouse
                /// button is pressed.
                pub always_track_motion: bool,
                /// For each signal in the set, a signal handler will intercept the signal
                /// and report it by returning an `Event::Signal( _ )` value.
                pub report_signals: SignalSet,
            }

            impl Default for PrepareConfig
            {
                fn default() -> PrepareConfig
                {
                    PrepareConfig
                    {
                        block_signals: true,
                        enable_control_flow: false,
                        enable_keypad: true,
                        enable_mouse: false,
                        always_track_motion: false,
                        report_signals: SignalSet::new(),
                    }
                }
            }
            /// Represents a previous device state of a [`Terminal`].
            #[must_use = "the result of `terminal.prepare()` should be passed to \
            `terminal.restore()` to restore terminal to its original state"]
            pub struct PrepareState( sys::PrepareState  );
            /// Represents the size of a terminal window.
            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub struct Size
            {
                /// Number of lines in the terminal
                pub lines: usize,
                /// Number of columns in the terminal
                pub columns: usize,
            }

            impl Size
            {
                /// Returns the total number of cells in a terminal of the given size.
                #[inline] pub fn area( &self ) -> usize
                {
                    self.checked_area()
                        .unwrap_or_else( || panic!( "overflow in Size::area {:?}", self ) )
                }
                /// Returns the total number of cells in a terminal of the given size.
                #[inline] pub fn checked_area( &self ) -> Option<usize>
                { self.lines.checked_mul( self.columns ) }
            }
            /// Provides concurrent read and write access to a terminal device.
            pub struct Terminal( pub sys::Terminus  );
            /// Holds an exclusive lock for read operations on a `Terminal`.
            pub struct TerminalReadGuard<'a>( sys::TerminalReadGuard<'a>  );
            /// Holds an exclusive lock for write operations on a `Terminal`.
            pub struct TerminalWriteGuard<'a>( sys::TerminalWriteGuard<'a>  );

            impl Terminal
            {
                /// Opens a new interface to the terminal on `stdout`.
                pub fn new() -> io::Result<Terminal>{ Ok( Terminal( sys::Terminus::stdout()? ) ) }
                /// Opens a new interface to the terminal on `stderr`.
                pub fn stderr() -> io::Result<Terminal> {Ok( Terminal( sys::Terminus::stderr()? ) )}
                /// Returns the name of the terminal.
                #[inline] pub fn name( &self ) -> &str { self.0.name() }
                /// Attempts to acquire an exclusive lock on terminal read operations.
                #[inline] pub fn lock_read( &self ) -> LockResult<TerminalReadGuard>
                { map_lock_result( self.0.lock_read(), TerminalReadGuard ) }
                /// Attempts to acquire an exclusive lock on terminal write operations.
                #[inline] pub fn lock_write( &self ) -> LockResult<TerminalWriteGuard>
                { map_lock_result( self.0.lock_write(), TerminalWriteGuard ) }
                /// Attempts to acquire an exclusive lock on terminal read operations.
                #[inline] pub fn try_lock_read( &self ) -> TryLockResult<TerminalReadGuard>
                { map_try_lock_result( self.0.try_lock_read(), TerminalReadGuard ) }
                /// Attempts to acquire an exclusive lock on terminal write operations.
                #[inline] pub fn try_lock_write( &self ) -> TryLockResult<TerminalWriteGuard>
                { map_try_lock_result( self.0.try_lock_write(), TerminalWriteGuard ) }
                /// Prepares the terminal to read input.
                pub fn prepare( &self, config: PrepareConfig ) -> io::Result<PrepareState>
                { self.0.prepare( config ).map( PrepareState ) }
                /// Restores the terminal to its previous state.
                pub fn restore( &self, state: PrepareState ) -> io::Result<()>
                { self.0.restore( state.0 ) }
                /// Waits for an event from the terminal.
                pub fn wait_event( &self, timeout: Option<Duration> ) -> io::Result<bool>
                { self.0.wait_event( timeout ) }
                /// Waits for input and reads an event from the terminal.
                pub fn read_event( &self, timeout: Option<Duration> ) -> io::Result<Option<Event>>
                { self.0.read_event( timeout ) }
                /// Returns the size of the terminal.
                #[inline] pub fn size( &self ) -> io::Result<Size> { self.0.size() }
                /// Clears the terminal screen, placing the cursor at the first line and column.
                pub fn clear_screen( &self ) -> io::Result<()> { self.0.clear_screen() }
                /// Clears the current line, starting at cursor position.
                pub fn clear_to_line_end( &self ) -> io::Result<()> { self.0.clear_to_line_end() }
                /// Clears the screen, starting at cursor position.
                pub fn clear_to_screen_end( &self ) -> io::Result<()> { self.0.clear_to_screen_end() }
                /// Moves the cursor up `n` lines.
                pub fn move_up( &self, n: usize ) -> io::Result<()> { self.0.move_up( n ) }
                /// Moves the cursor down `n` lines.
                pub fn move_down( &self, n: usize ) -> io::Result<()> { self.0.move_down( n ) }
                /// Moves the cursor left `n` columns.
                pub fn move_left( &self, n: usize ) -> io::Result<()> { self.0.move_left( n ) }
                /// Moves the cursor right `n` columns.
                pub fn move_right( &self, n: usize ) -> io::Result<()> { self.0.move_right( n ) }
                /// Moves the cursor to the first column of the current line
                pub fn move_to_first_column( &self ) -> io::Result<()> { self.0.move_to_first_column() }
                /// Set the current cursor mode.
                pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()>
                { self.0.set_cursor_mode( mode ) }
                /// Adds a set of `Style` flags to the current style setting.
                pub fn add_style( &self, style: Style ) -> io::Result<()>
                { self.0.add_style( style ) }
                /// Removes a set of `Style` flags from the current style setting.
                pub fn remove_style( &self, style: Style ) -> io::Result<()>
                { self.0.remove_style( style ) }
                /// Sets the current style to the given set of flags.
                pub fn set_style<S>( &self, style: S ) -> io::Result<()> where 
                S:Into<Option<Style>>
                { self.0.set_style( style.into().unwrap_or_default() ) }
                /// Sets all attributes for the terminal.
                pub fn set_theme( &self, theme: Theme ) -> io::Result<()> { self.0.set_theme( theme ) }
                /// Sets the foreground text color.
                pub fn set_fg<C: Into<Option<Color>>>( &self, fg: C ) -> io::Result<()>
                { self.0.set_fg( fg.into() ) }
                /// Sets the background text color.
                pub fn set_bg<C: Into<Option<Color>>>( &self, bg: C ) -> io::Result<()>
                { self.0.set_bg( bg.into() ) }
                /// Removes color and style attributes.
                pub fn clear_attributes( &self ) -> io::Result<()> { self.0.clear_attributes() }
                /// Adds bold to the current style setting.
                pub fn bold( &self ) -> io::Result<()> { self.add_style( Style::BOLD ) }
                /// Adds italic to the current style setting.
                pub fn italic( &self ) -> io::Result<()> { self.add_style( Style::ITALIC ) }
                /// Adds underline to the current style setting.
                pub fn underline( &self ) -> io::Result<()> { self.add_style( Style::UNDERLINE ) }
                /// Adds reverse to the current style setting.
                pub fn reverse( &self ) -> io::Result<()> { self.add_style( Style::REVERSE ) }
                /// Writes output to the terminal with the given color and style.
                pub fn write_styled<F,B,S>( &self, fg:F, bg:B, style:S, s:&str ) -> io::Result<()>
                where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                { self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), s ) }
                /// Writes a single character to the terminal
                /// using the current style and color settings.
                pub fn write_char( &self, ch:char ) -> io::Result<()> { self.0.write_char( ch ) }
                /// Writes a string to the terminal
                /// using the current style and color settings.
                pub fn write_str( &self, s:&str ) -> io::Result<()> { self.0.write_str( s ) }
                /// Writes formatted text to the terminal
                /// using the current style and color settings.
                pub fn write_fmt( &self, args: fmt::Arguments ) -> io::Result<()>
                {
                    let s = args.to_string();
                    self.write_str( &s )
                }
                
                pub fn borrow_term_write_guard( &self ) -> TerminalWriteGuard
                { self.lock_write().unwrap() }
            }

            impl<'a> TerminalReadGuard<'a> 
            {
                /// Prepares the terminal to read input.
                pub fn prepare( &mut self, config: PrepareConfig ) -> io::Result<PrepareState>
                { self.0.prepare( config ).map( PrepareState ) }
                /// Performs terminal preparation using both [`Terminal`] locks.
                pub fn prepare_with_lock
                ( 
                    &mut self,
                    writer:&mut TerminalWriteGuard,
                    config:PrepareConfig
                ) -> io::Result<PrepareState>
                { self.0.prepare_with_lock( &mut writer.0, config ).map( PrepareState ) }
                /// Restores the terminal to its previous state.
                pub fn restore( &mut self, state: PrepareState ) -> io::Result<()>
                { self.0.restore( state.0 ) }
                /// Performs terminal state restoration using both [`Terminal`] locks.
                pub fn restore_with_lock
                ( 
                    &mut self,
                    writer:&mut TerminalWriteGuard,
                    state:PrepareState
                ) -> io::Result<()>
                { self.0.restore_with_lock( &mut writer.0, state.0 ) }
                /// Waits for an event from the terminal.
                pub fn wait_event( &mut self, timeout: Option<Duration> ) -> io::Result<bool>
                { self.0.wait_event( timeout ) }
                /// Waits for input and reads an event from the terminal.
                pub fn read_event( &mut self, timeout: Option<Duration> ) -> io::Result<Option<Event>>
                { self.0.read_event( timeout ) }
            }

            impl<'a> TerminalWriteGuard<'a>
            {
                /// Flush all output to the terminal device.
                pub fn flush( &mut self ) -> io::Result<()> { self.0.flush() }
                /// Returns the size of the terminal.
                #[inline] pub fn size( &self ) -> io::Result<Size> { self.0.size() }
                /// Clears the terminal screen, placing the cursor at the first line and column.
                pub fn clear_screen( &mut self ) -> io::Result<()> { self.0.clear_screen() }
                /// Clears the current line, starting at cursor position.
                pub fn clear_to_line_end( &mut self ) -> io::Result<()> { self.0.clear_to_line_end() }
                /// Clears the screen, starting at cursor position.
                pub fn clear_to_screen_end( &mut self ) -> io::Result<()>
                { self.0.clear_to_screen_end() }
                /// Moves the cursor up `n` lines.
                pub fn move_up( &mut self, n: usize ) -> io::Result<()> { self.0.move_up( n ) }
                /// Moves the cursor down `n` lines.
                pub fn move_down( &mut self, n: usize ) -> io::Result<()> { self.0.move_down( n ) }
                /// Moves the cursor left `n` columns.
                pub fn move_left( &mut self, n: usize ) -> io::Result<()> { self.0.move_left( n ) }
                /// Moves the cursor right `n` columns.
                pub fn move_right( &mut self, n: usize ) -> io::Result<()> { self.0.move_right( n ) }
                /// Moves the cursor to the first column of the current line
                pub fn move_to_first_column( &mut self ) -> io::Result<()>
                { self.0.move_to_first_column() }
                /// Set the current cursor mode.
                pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()>
                { self.0.set_cursor_mode( mode ) }
                /// Adds a set of `Style` flags to the current style setting.
                pub fn add_style( &mut self, style: Style ) -> io::Result<()>
                { self.0.add_style( style ) }
                /// Removes a set of `Style` flags from the current style setting.
                pub fn remove_style( &mut self, style: Style ) -> io::Result<()>
                { self.0.remove_style( style ) }
                /// Sets the current style to the given set of flags.
                pub fn set_style<S>( &mut self, style: S ) -> io::Result<()> where 
                S:Into<Option<Style>>
                { self.0.set_style( style.into().unwrap_or_default() ) }
                /// Sets all attributes for the terminal.
                pub fn set_theme( &mut self, theme: Theme ) -> io::Result<()> { self.0.set_theme( theme ) }
                /// Sets the background text color.
                pub fn set_fg<C: Into<Option<Color>>>( &mut self, fg: C ) -> io::Result<()>
                { self.0.set_fg( fg.into() ) }
                /// Removes color and style attributes.
                pub fn set_bg<C: Into<Option<Color>>>( &mut self, bg: C ) -> io::Result<()>
                { self.0.set_bg( bg.into() ) }
                /// Adds bold to the current style setting.
                pub fn clear_attributes( &mut self ) -> io::Result<()> { self.0.clear_attributes() }
                /// Adds bold to the current style setting.
                pub fn bold( &mut self ) -> io::Result<()> { self.add_style( Style::BOLD ) }
                /// Adds italic to the current style setting.
                pub fn italic( &mut self ) -> io::Result<()> { self.add_style( Style::ITALIC ) }
                /// Adds underline to the current style setting.
                pub fn underline( &mut self ) -> io::Result<()> { self.add_style( Style::UNDERLINE ) }
                /// Adds reverse to the current style setting.
                pub fn reverse( &mut self ) -> io::Result<()> { self.add_style( Style::REVERSE ) }
                /// Writes output to the terminal with the given color and style added.
                pub fn write_styled<F,B,S>( &mut self, fg:F, bg:B, style:S, s:&str ) -> io::Result<()>
                where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                { self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), s ) }
                /// Writes a single character to the terminal
                /// using the current style and color settings.
                pub fn write_char( &mut self, ch:char ) -> io::Result<()> { self.0.write_char( ch ) }
                /// Writes a string to the terminal
                /// using the current style and color settings.
                pub fn write_str( &mut self, s:&str ) -> io::Result<()> { self.0.write_str( s ) }
                /// Writes formatted text to the terminal
                /// using the current style and color settings.
                pub fn write_fmt( &mut self, args: fmt::Arguments ) -> io::Result<()>
                {
                    let s = args.to_string();
                    self.write_str( &s )
                }
                
                pub fn borrow_term_write_guard( &mut self ) -> &mut Self { self }
            }

            #[cfg( unix )]
            use ::path::Path;

            #[cfg( unix )]
            impl sys::OpenTerminalExt for Terminal
            {
                fn from_path<P: AsRef<Path>>( path: P ) -> io::Result<Self>
                { sys::Terminus::open( path ).map( Terminal ) }
            }

            #[cfg( unix )]
            impl sys::TerminalExt for Terminal
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) 
                -> io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }

            #[cfg( unix )]
            impl<'a> sys::TerminalExt for TerminalReadGuard<'a>
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout: Option<Duration> ) 
                -> io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }
            /*
            #[cfg( windows )]
            impl crate::windows::TerminalExt for Terminal {
                fn read_raw( &mut self, buf:&mut [u16], timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw( buf, timeout )
                }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw_event( events, timeout )
                }
            }

            #[cfg( windows )]
            impl<'a> crate::windows::TerminalExt for TerminalReadGuard<'a> {
                fn read_raw( &mut self, buf:&mut [u16], timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw( buf, timeout )
                }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout: Option<Duration> ) -> io::Result<Option<Event>> {
                    self.0.read_raw_event( events, timeout )
                }
            } */
        } pub use self::terminal::
        {
            Color, Cursor, CursorMode, Size, Style, Theme, Event, Key, MouseEvent, MouseInput, 
            MouseButton, ModifierState, PrepareConfig, PrepareState, Terminal, TerminalReadGuard, 
            TerminalWriteGuard,
        };

        pub mod unix
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            mod ext
            {
                /*!
                */
                use ::
                {
                    path::{ Path },
                    system::common::{ Event },
                    time::std::{ Duration },
                    *,
                };
                /*
                */
                /// Implements Unix-only extensions for terminal interfaces.
                pub trait OpenTerminalExt:Sized
                {
                    /// Opens a terminal interface on the device at the given path.
                    fn from_path<P:AsRef<Path>>( path:P ) -> io::Result<Self>;
                }
                /// Implements Unix-only extensions for terminal interfaces.
                pub trait TerminalExt
                {
                    /// Reads raw data from the terminal.
                    fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>>;
                }
            } pub use self::ext::{ * };

            mod path
            {
                /*!
                */
                use ::
                {
                    path::{ PathBuf },
                    *,
                };
                /*
                */
                pub fn env_init_file() -> Option<PathBuf>
                {
                    // var_os( "INPUTRC" ).map( PathBuf::from )
                    None
                }

                pub fn system_init_file() -> Option<PathBuf> 
                {
                    // Some( PathBuf::from( "/etc/inputrc" ) )
                    None
                }

                pub fn user_init_file() -> Option<PathBuf>
                { 
                    // home_dir().map( |p| p.join( ".inputrc" ) )
                    None
                }
            } pub use self::path::{ * };

            mod screen
            {
                /*!
                */
                use ::
                {
                    map::{ map_lock_result, map_try_lock_result, map2_lock_result, map2_try_lock_result },
                    sync::{ LockResult, Mutex, MutexGuard, TryLockResult },
                    system::
                    {
                        common::
                        {
                            buffer::{ ScreenBuffer },
                            terminal::{ Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig }
                        },
                    },
                    time::std::{ Duration },
                    *,
                };
                use super::{ Terminus, TerminalReadGuard, TerminalWriteGuard, PrepareState };
                /*
                use crate::buffer::ScreenBuffer;
                use crate::sys::{Terminal, TerminalReadGuard, TerminalWriteGuard, PrepareState};
                use crate::terminal::{Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig};
                */
                pub struct Screen
                {
                    term: Terminus,
                    state: Option<PrepareState>,
                    writer: Mutex<Writer>,
                }

                pub struct ScreenReadGuard<'a> 
                {
                    screen:&'a Screen,
                    reader: TerminalReadGuard<'a>,
                }

                pub struct ScreenWriteGuard<'a> 
                {
                    writer: TerminalWriteGuard<'a>,
                    data: MutexGuard<'a, Writer>,
                }

                struct Writer 
                {
                    buffer: ScreenBuffer,
                    clear_screen: bool,
                    real_cursor: Cursor,
                }

                impl Screen 
                {
                    pub fn new( term: Terminus, config: PrepareConfig ) -> io::Result<Screen> 
                    {
                        let size = term.size()?;
                        let state = term.prepare( config )?;

                        let screen = Screen
                        {
                            term: term,
                            state: Some( state ),
                            writer: Mutex::new( Writer
                            {
                                buffer: ScreenBuffer::new( size ),
                                clear_screen: false,
                                real_cursor: Cursor::default(),
                            } ),
                        };

                        screen.term.enter_screen()?;
                        Ok( screen )
                    }

                    pub fn stdout( config: PrepareConfig ) -> io::Result<Screen>
                    { Screen::new( Terminus::stdout()?, config ) }

                    pub fn stderr( config: PrepareConfig ) -> io::Result<Screen>
                    { Screen::new( Terminus::stderr()?, config ) }

                    forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                    pub fn lock_read( &self ) -> LockResult<ScreenReadGuard>
                    {
                        map_lock_result( self.term.lock_read(),
                        |r| ScreenReadGuard::new( self, r ) )
                    }

                    pub fn try_lock_read( &self ) -> TryLockResult<ScreenReadGuard>
                    {
                        map_try_lock_result( self.term.try_lock_read(),
                        |r| ScreenReadGuard::new( self, r ) )
                    }

                    pub fn lock_write( &self ) -> LockResult<ScreenWriteGuard>
                    {
                        map2_lock_result( self.term.lock_write(), self.writer.lock(),
                        |a, b| ScreenWriteGuard::new( a, b ) )
                    }

                    pub fn try_lock_write( &self ) -> TryLockResult<ScreenWriteGuard>
                    {
                        map2_try_lock_result( self.term.try_lock_write(), self.writer.try_lock(),
                        |a, b| ScreenWriteGuard::new( a, b ) )
                    }
                    
                    pub fn name( &self ) -> &str { self.term.name() }
                    pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()> { self.term.set_cursor_mode( mode ) }
                    pub fn wait_event( &self, timeout: Option<Duration> ) -> io::Result<bool> { self.lock_reader().wait_event( timeout ) }
                    pub fn read_event( &self, timeout: Option<Duration> ) -> io::Result<Option<Event>> { self.lock_reader().read_event( timeout ) }
                    pub fn read_raw( &self, buf:&mut [u8], timeout: Option<Duration> ) -> io::Result<Option<Event>> { self.lock_reader().read_raw( buf, timeout ) }
                    pub fn refresh( &self ) -> io::Result<()> { self.lock_writer().refresh() }

                    fn lock_reader( &self ) -> ScreenReadGuard { self.lock_read().expect( "Screen::lock_reader" ) }
                    fn lock_writer( &self ) -> ScreenWriteGuard { self.lock_write().expect( "Screen::lock_writer" ) }
                    fn lock_write_data( &self ) -> MutexGuard<Writer> { self.writer.lock().expect( "Screen::lock_write_data" ) }
                }

                impl Drop for Screen
                {
                    fn drop( &mut self )
                    {
                        let res = if let Some( state ) = self.state.take() { self.term.restore( state ) }
                        else { Ok( () ) };

                        if let Err( e ) = res.and_then( |_| self.term.exit_screen() ) { eprintln!( "failed to restore terminal: {}", e ); }
                    }
                }

                impl<'a> ScreenReadGuard<'a>
                {
                    fn new( screen:&'a Screen, reader: TerminalReadGuard<'a> ) -> ScreenReadGuard<'a>
                    { ScreenReadGuard{screen, reader} }

                    pub fn wait_event( &mut self, timeout: Option<Duration> ) -> io::Result<bool>
                    { self.reader.wait_event( timeout ) }

                    pub fn read_event( &mut self, timeout:Option<Duration> ) -> io::Result<Option<Event>> 
                    {
                        let r = self.reader.read_event( timeout )?;

                        if let Some( Event::Resize( size ) ) = r { self.screen.lock_write_data().update_size( size ); }

                        Ok( r )
                    }

                    pub fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        let r = self.reader.read_raw( buf, timeout )?;

                        if let Some( Event::Resize( size ) ) = r { self.screen.lock_write_data().update_size( size ); }

                        Ok( r )
                    }
                }

                impl<'a> ScreenWriteGuard<'a>
                {
                    fn new( writer:TerminalWriteGuard<'a>, data:MutexGuard<'a, Writer> ) -> ScreenWriteGuard<'a>
                    { ScreenWriteGuard{writer, data} }

                    forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                    pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()>
                    { self.writer.set_cursor_mode( mode ) }

                    pub fn refresh( &mut self ) -> io::Result<()>
                    {
                        if self.data.clear_screen
                        {
                            self.writer.clear_screen()?;
                            self.data.clear_screen = false;
                        }

                        self.writer.clear_attributes()?;

                        let mut indices = self.data.buffer.indices();

                        while let Some( ( pos, cell ) ) = self.data.buffer.next_cell( &mut indices )
                        {
                            self.move_cursor( pos )?;
                            self.apply_attrs( cell.attrs() )?;
                            self.writer.write_str( cell.text() )?;
                            self.data.real_cursor.column += 1;
                        }

                        self.writer.clear_attributes()?;                        
                        let size = self.data.buffer.size();
                        let pos = self.data.buffer.cursor();

                        if pos.is_out_of_bounds( size ) { self.move_cursor( Cursor::last( size ) )?; }

                        else { self.move_cursor( pos )?; }

                        self.writer.flush()
                    }

                    fn move_cursor( &mut self, pos:Cursor ) -> io::Result<()>
                    {
                        if self.data.real_cursor != pos
                        {
                            self.writer.move_cursor( pos )?;
                            self.data.real_cursor = pos;
                        }

                        Ok( () )
                    }

                    fn apply_attrs( &mut self, ( fg, bg, style ):( Option<Color>, Option<Color>, Style ) )
                    -> io::Result<()>
                    { self.writer.set_attrs( fg, bg, style ) }
                }

                impl<'a> Drop for ScreenWriteGuard<'a>
                {
                    fn drop( &mut self )
                    {
                        if let Err( e ) = self.refresh() { eprintln!( "Failed to refresh screen: {}", e ); }
                    }
                }

                impl Writer
                {
                    fn update_size( &mut self, new_size:Size )
                    {
                        if self.real_cursor.is_out_of_bounds( new_size )
                        { self.real_cursor = ( !0, !0 ).into(); }

                        self.buffer.resize( new_size  );
                        self.clear_screen = true;
                    }
                }

            } pub use self::screen::{ * };

            mod terminal
            {
                /*!
                */
                use system::api::selects;
                use ::
                {
                    convert::{ TryFrom },
                    fs::{ File },
                    map::{ map_lock_result, map_try_lock_result },
                    mem::{ replace, zeroed },
                    libc::
                    { 
                        ioctl, c_int, c_ushort, termios, STDIN_FILENO, STDOUT_FILENO, 
                        STDERR_FILENO, TIOCGWINSZ
                    },                    
                    os::
                    { 
                        fd::{ AsFd, AsRawFd },
                        unix::io::{ FromRawFd, IntoRawFd, RawFd }
                    },
                    path::{ Path },
                    str::{ from_utf8, SmallString },
                    sync::{ atomic::{ AtomicUsize, Ordering }, LockResult, Mutex, MutexGuard, TryLockResult },
                    system::
                    {
                        api::
                        {
                            self, AsynchronousTerminalInterface, Errno, select, FdSet, react, sigaction, SaFlags, 
                            SigAction, SigHandler, Signal as NixSignal, SigSet, SetArg, InputFlags, LocalFlags,
                            tcsetattraw, Termios, TimeVal, TimeValLike, read, VMIN, VTIME, write
                        },
                        common::
                        {
                            signal::{ Signal, SignalSet },
                            terminal::
                            {
                                Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme,
                                MouseButton, MouseEvent, MouseInput, ModifierState
                            }
                        },
                        terminal::{ RawRead },
                    },
                    time::std::{ Duration },
                    *,
                };
                /*

                use mortal::{Event, TerminalReadGuard};
                use mortal::unix::TerminalExt;

                use crate::terminal::RawRead;
                use crate::sequence::{FindResult, SequenceMap};
                use crate::util::prefixes;
                
                use smallstr::SmallString;

                use terminfo::{self, capability as cap, Database};
                use terminfo::capability::Expansion;
                use terminfo::expand::Context;

                use crate::priv_util::{map_lock_result, map_try_lock_result};
                use crate::sequence::{FindResult, SequenceMap};
                use crate::signal::{Signal, SignalSet};
                use crate::terminal::{
                    Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme,
                    MouseButton, MouseEvent, MouseInput, ModifierState,
                };
                use crate::util::prefixes;
                */

                macro_rules! expand_opt
                {
                    ( $slf:expr , $cap:path ) => 
                    { {
                        if let Some( cap ) = $slf.term.info.get::<$cap>() {
                            $slf.expand( cap.expand() )
                        } else {
                            Ok( () )
                        }
                    } };

                    ( $slf:expr , $cap:path , |$ex:ident| $expansion:expr ) => 
                    { {
                        if let Some( cap ) = $slf.term.info.get::<$cap>() {
                            let $ex = cap.expand();
                            $slf.expand( $expansion )
                        } else {
                            Ok( () )
                        }
                    } }
                }

                macro_rules! expand_req 
                {
                    ( $slf:expr , $cap:path , $name:expr ) => 
                    { {
                        $slf.term.info.get::<$cap>()
                            .ok_or_else( || not_supported( $name ) )
                            .and_then( |cap| $slf.expand( cap.expand() ) )
                    } };

                    ( $slf:expr , $cap:path , $name:expr , |$ex:ident| $expansion:expr ) => { {
                        $slf.term.info.get::<$cap>()
                            .ok_or_else( || not_supported( $name ) )
                            .and_then( |cap| {
                                let $ex = cap.expand();
                                $slf.expand( $expansion )
                            } )
                    } }
                }
                
                const OUT_BUFFER_SIZE: usize = 8192;

                const XTERM_ENABLE_MOUSE:&str = "\x1b[?1006h\x1b[?1002h";
                const XTERM_DISABLE_MOUSE:&str = "\x1b[?1006l\x1b[?1002l";
                const XTERM_ENABLE_MOUSE_MOTION:&str = "\x1b[?1003h";
                const XTERM_DISABLE_MOUSE_MOTION:&str = "\x1b[?1003l";
                const XTERM_MOUSE_INTRO:&str = "\x1b[<";

                const XTERM_SHIFT_MASK: u32 = 0x04;
                const XTERM_META_MASK: u32  = 0x08;
                const XTERM_CTRL_MASK: u32  = 0x10;
                const XTERM_MODIFIER_MASK: u32 = XTERM_SHIFT_MASK | XTERM_META_MASK | XTERM_CTRL_MASK;

                pub fn terminal_read( term:&mut TerminalReadGuard, buf:&mut Vec<u8> ) -> io::Result<RawRead>
                {
                    let mut buffer = [0; 1024];

                    match term.read_raw( &mut buffer, Some( Duration::new( 0, 0 ) ) )?
                    {
                        None => Ok( RawRead::Bytes( 0 ) ),
                        Some( Event::Raw( n ) ) =>
                        {
                            buf.extend( &buffer[..n] );
                            Ok( RawRead::Bytes( n ) )
                        }
                        Some( Event::Resize( size ) ) => Ok( RawRead::Resize( size ) ),
                        Some( Event::Signal( sig ) ) => Ok( RawRead::Signal( sig ) ),
                        _ => unreachable!()
                    }
                }

                //type SeqMap = SequenceMap<SmallString<[u8; 8]>, SeqData>;

                #[derive( Copy, Clone )]
                enum SeqData 
                {
                    XTermMouse,
                    Key( Key ),
                }

                pub struct Terminus
                {
                    //info: Database,
                    out_fd: RawFd,
                    in_fd: RawFd,
                    owned_fd: bool,
                    // sequences: SeqMap,
                    reader: Mutex<Reader>,
                    writer: Mutex<Writer>,
                }

                pub struct TerminalReadGuard<'a> 
                {
                    term:&'a Terminus,
                    reader: MutexGuard<'a, Reader>,
                }

                pub struct TerminalWriteGuard<'a> 
                {
                    term:&'a Terminus,
                    writer: MutexGuard<'a, Writer>,
                }

                struct Reader
                {
                    in_buffer: Vec<u8>,
                    resume: Option<Resume>,
                    report_signals: SignalSet,
                }

                struct Writer
                {
                    //context: Context,
                    out_buffer: Vec<u8>,
                    fg: Option<Color>,
                    bg: Option<Color>,
                    cur_style: Style,
                }

                impl Terminus 
                {
                    fn new( in_fd: RawFd, out_fd: RawFd, owned_fd: bool ) -> io::Result<Terminus>
                    {
                        //let info = Database::from_env().map_err( ti_to_io )?;
                        //let sequences = sequences( &info );

                        Ok
                        ( 
                            Terminus
                            {
                                //info,
                                in_fd,
                                out_fd,
                                owned_fd,
                                //sequences,
                                reader: Mutex::new( Reader{
                                    in_buffer: Vec::new(),
                                    resume: None,
                                    report_signals: SignalSet::new(),
                                } ),
                                writer: Mutex::new( Writer::new() ),
                            }
                        )
                    }

                    pub fn open<P: AsRef<Path>>( path: P ) -> io::Result<Terminus> 
                    {
                        let fd = open_rw( path )?;
                        let r = Terminus::new( fd, fd, true );

                        if r.is_err() { unsafe { close_fd( fd ); } }

                        r
                    }

                    pub fn stdout() -> io::Result<Terminus> { Terminus::new( STDIN_FILENO, STDOUT_FILENO, false ) }

                    pub fn stderr() -> io::Result<Terminus> { Terminus::new( STDIN_FILENO, STDERR_FILENO, false ) }

                    pub fn name( &self ) -> &str 
                    { 
                        //self.info.name()
                        ""                        
                    }

                    fn is_xterm( &self ) -> bool { is::xterm( self.name() ) }

                    pub fn size( &self ) -> io::Result<Size> { self.lock_writer().size() }

                    pub fn wait_event( &self, timeout: Option<Duration> ) -> io::Result<bool>
                    { self.lock_reader().wait_event( timeout ) }

                    pub fn read_event( &self, timeout: Option<Duration> ) -> io::Result<Option<Event>>
                    { self.lock_reader().read_event( timeout ) }

                    pub fn read_raw( &self, buf:&mut [u8], timeout: Option<Duration> ) -> io::Result<Option<Event>>
                    { self.lock_reader().read_raw( buf, timeout ) }

                    pub fn enter_screen( &self ) -> io::Result<()>
                    { self.lock_writer().enter_screen() }

                    pub fn exit_screen( &self ) -> io::Result<()> { self.lock_writer().exit_screen() }

                    pub fn prepare( &self, config: PrepareConfig ) -> io::Result<PrepareState>
                    { self.lock_reader().prepare( config ) }

                    pub fn restore( &self, state: PrepareState ) -> io::Result<()>
                    { self.lock_reader().restore( state ) }

                    pub fn clear_screen( &self ) -> io::Result<()>
                    { self.lock_writer().clear_screen() }

                    pub fn clear_to_line_end( &self ) -> io::Result<()>
                    { self.lock_writer().clear_to_line_end() }

                    pub fn clear_to_screen_end( &self ) -> io::Result<()>
                    { self.lock_writer().clear_to_screen_end() }

                    pub fn move_up( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_up( n )?; }
                        Ok( () )
                    }

                    pub fn move_down( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_down( n )?; }
                        Ok( () )
                    }

                    pub fn move_left( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_left( n )?; }
                        Ok( () )
                    }

                    pub fn move_right( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_right( n )?; }
                        Ok( () )
                    }

                    pub fn move_to_first_column( &self ) -> io::Result<()>
                    { self.lock_writer().move_to_first_column() }

                    pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()>
                    { self.lock_writer().set_cursor_mode( mode ) }

                    pub fn write_char( &self, ch:char ) -> io::Result<()>
                    { self.write_str( ch.encode_utf8( &mut [0; 4] ) ) }

                    pub fn write_str( &self, s:&str ) -> io::Result<()> { self.lock_writer().write_str( s ) }

                    pub fn write_styled( &self, fg:Option<Color>, bg:Option<Color>, style:Style, text:&str ) 
                    -> io::Result<()>
                    { self.lock_writer().write_styled( fg, bg, style, text ) }

                    pub fn clear_attributes( &self ) -> io::Result<()> {
                        self.lock_writer().clear_attributes()
                    }

                    pub fn set_fg( &self, fg: Option<Color> ) -> io::Result<()> { self.lock_writer().set_fg( fg ) }
                    pub fn set_bg( &self, bg: Option<Color> ) -> io::Result<()> { self.lock_writer().set_bg( bg ) }
                    pub fn add_style( &self, style: Style ) -> io::Result<()> { self.lock_writer().add_style( style ) }
                    pub fn remove_style( &self, style: Style ) -> io::Result<()> { self.lock_writer().remove_style( style ) }
                    pub fn set_style( &self, style: Style ) -> io::Result<()> { self.lock_writer().set_style( style ) }
                    pub fn set_theme( &self, theme: Theme ) -> io::Result<()> { self.lock_writer().set_theme( theme ) }
                    pub fn lock_read( &self ) -> LockResult<TerminalReadGuard>
                    {
                        map_lock_result( self.reader.lock(), |r| TerminalReadGuard::new( self, r ) )
                    }

                    pub fn lock_write( &self ) -> LockResult<TerminalWriteGuard>
                    {
                        map_lock_result( self.writer.lock(), |w| TerminalWriteGuard::new( self, w ) )
                    }

                    pub fn try_lock_read( &self ) -> TryLockResult<TerminalReadGuard>
                    {
                        map_try_lock_result( self.reader.try_lock(), |r| TerminalReadGuard::new( self, r ) )
                    }

                    pub fn try_lock_write( &self ) -> TryLockResult<TerminalWriteGuard>
                    {
                        map_try_lock_result( self.writer.try_lock(), |w| TerminalWriteGuard::new( self, w ) )
                    }

                    fn lock_reader( &self ) -> TerminalReadGuard { self.lock_read().expect( "Terminal::lock_reader" ) }

                    fn lock_writer( &self ) -> TerminalWriteGuard { self.lock_write().expect( "Terminal::lock_writer" ) }
                }

                impl Drop for Terminus
                {
                    fn drop( &mut self ) {
                        if let Err( e ) = self.set_cursor_mode( CursorMode::Normal ) {
                            eprintln!( "failed to restore terminus: {}", e );
                        }

                        if self.owned_fd {
                            unsafe { close_fd( self.out_fd ); }
                        }
                    }
                }

                impl<'a> TerminalReadGuard<'a>
                {
                    fn new( term:&'a Terminus, reader: MutexGuard<'a, Reader> ) -> TerminalReadGuard<'a>
                    { TerminalReadGuard{term, reader} }

                    pub fn prepare( &mut self, config: PrepareConfig ) -> io::Result<PrepareState>
                    {
                        let mut writer = self.term.lock_writer();
                        self.prepare_with_lock( &mut writer, config )
                    }

                    pub fn prepare_with_lock( &mut self, w:&mut TerminalWriteGuard, c:PrepareConfig )
                    -> io::Result<PrepareState>
                    {
                        unsafe
                        {
                            use ::system::api::SpecialCharacterIndices::{ * };

                            let tiold =  ::system::api::tcgetattraw( self.term.in_fd ).map_err( nix_to_io )?;
                            let mut tio = tiold.clone();
                            
                            let mut state = PrepareState
                            {
                                old_tio: Some
                                ( 
                                    ::mem::transmute::<AsynchronousTerminalInterface, termios>( tiold.into() )
                                ),
                                old_sigcont: None,
                                old_sigint: None,
                                old_sigtstp: None,
                                old_sigquit: None,
                                old_sigwinch: None,
                                restore_keypad: false,
                                restore_mouse: false,
                                prev_resume: self.reader.resume,
                            };

                            tio.input_flags.remove( InputFlags::INLCR  | InputFlags::ICRNL  );
                            tio.local_flags.remove( LocalFlags::ICANON | LocalFlags::ECHO   );
                        
                            if c.block_signals { tio.local_flags.remove( LocalFlags::ISIG  ); }
                            else { tio.local_flags.insert( LocalFlags::ISIG  ); }
                            
                            if c.enable_control_flow { tio.input_flags.insert( InputFlags::IXON  ); }
                            else { tio.input_flags.remove( InputFlags::IXON  ); }
                            
                            tio.control_chars[VMIN as usize] = 0;
                            tio.control_chars[VTIME as usize] = 0;

                            tcsetattraw( ::mem::transmute( self.term.in_fd ), SetArg::TCSANOW, &tio ).map_err( nix_to_io )?;

                            if c.enable_keypad { if w.enable_keypad()? { state.restore_keypad = true; } }

                            w.flush()?;

                            let action = SigAction::new( SigHandler::Handler( handle_signal ), SaFlags::empty(), SigSet::all()  );
                                
                            state.old_sigcont = Some( react( NixSignal::SIGCONT, &action ).map_err( nix_to_io )?  );
                            state.old_sigwinch = Some( react( NixSignal::SIGWINCH, &action ).map_err( nix_to_io )?  );

                            if c.report_signals.contains( Signal::Interrupt )
                            { state.old_sigint = Some( react( NixSignal::SIGINT, &action ).map_err( nix_to_io )?  ); }

                            if c.report_signals.contains( Signal::Suspend )
                            { state.old_sigtstp = Some( react( NixSignal::SIGTSTP, &action ).map_err( nix_to_io )?  ); }

                            if c.report_signals.contains( Signal::Quit )
                            { state.old_sigquit = Some( react( NixSignal::SIGQUIT, &action ).map_err( nix_to_io )?  ); }

                            self.reader.report_signals = c.report_signals;
                            self.reader.resume = Some( Resume{ config:c }  );
                            Ok( state )
                        }
                    }

                    pub fn restore( &mut self, state: PrepareState ) -> io::Result<()>
                    {
                        let mut writer = self.term.lock_writer();
                        self.restore_with_lock( &mut writer, state )
                    }

                    pub fn restore_with_lock( &mut self, w:&mut TerminalWriteGuard, s:PrepareState ) -> io::Result<()>
                    {
                        unsafe
                        {
                            self.reader.resume = s.prev_resume;

                            if s.restore_mouse { w.disable_mouse()?; }

                            if s.restore_keypad { w.disable_keypad()?; }

                            w.flush()?;

                            tcsetattraw
                            ( 
                                self.term.in_fd,
                                SetArg::TCSANOW,
                                ::mem::transmute::<&Option<termios>, &Termios>( &s.old_tio )
                            ).map_err( nix_to_io )?;
                            
                            if let Some( ref old ) = s.old_sigcont
                            { react( NixSignal::SIGCONT, old ).map_err( nix_to_io )?; }

                            if let Some( ref old ) = s.old_sigint
                            { react( NixSignal::SIGINT, old ).map_err( nix_to_io )?; }

                            if let Some( ref old ) = s.old_sigtstp
                            { react( NixSignal::SIGTSTP, old ).map_err( nix_to_io )?; }
                            
                            if let Some( ref old ) = s.old_sigquit
                            { react( NixSignal::SIGQUIT, old ).map_err( nix_to_io )?; }

                            if let Some( ref old ) = s.old_sigwinch
                            { react( NixSignal::SIGWINCH, old ).map_err( nix_to_io )?; }
                            
                            Ok( () )
                        }
                    }

                    pub fn wait_event( &mut self, t:Option<Duration> ) -> io::Result<bool>
                    {

                        if get_signal().is_some() { return Ok( true  ); }
                        let mut t = t.map( to_timeval  );
                        
                        let n = loop
                        {
                            let in_fd = self.term.in_fd;

                            let mut r_fds = FdSet::new();
                            r_fds.insert( in_fd );
                            
                            let mut e_fds = FdSet::new();
                            e_fds.insert( in_fd );

                            match selects( in_fd + 1, Some( &mut r_fds ), None, Some( &mut e_fds ), t.as_mut() )
                            {
                                Ok( n ) => break n,
                                Err( Errno::EINTR ) =>
                                {
                                    if get_signal().is_some() { return Ok( true ); }
                                }
                                Err( e ) => return Err( nix_to_io( e ) )
                            }
                        };

                        Ok( n != 0 )
                        /*
                        if get_signal().is_some() { return Ok( true ); }

                        if peek_event( &self.reader.in_buffer, &self.term.sequences )?.is_some() { return Ok( true ); }

                        let mut timeout = timeout.map( to_timeval );

                        let n = loop
                        {
                            let in_fd = self.term.in_fd;

                            let mut r_fds = FdSet::new();
                            r_fds.insert( in_fd );
                            
                            let mut e_fds = FdSet::new();
                            e_fds.insert( in_fd );

                            match selects( in_fd + 1,
                                    Some( &mut r_fds ), None, Some( &mut e_fds ), timeout.as_mut() ) {
                                Ok( n ) => break n,
                                Err( Errno::EINTR ) =>
                                    if get_signal().is_some() {
                                        return Ok( true );
                                    }
                                
                                Err( e ) => return Err( nix_to_io( e ) )
                            }
                        };

                        Ok( n != 0 ) */
                    }

                    pub fn read_event( &mut self, timeout: Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        if let Some( ev ) = self.try_read()? { return Ok( Some( ev ) ); }

                        match self.read_into_buffer( timeout )?
                        {
                            Some( Event::Raw( _ ) ) => self.try_read(),
                            Some( Event::Signal( sig ) ) =>
                            {
                                if let Some( ev ) = self.handle_signal( sig )? {
                                    Ok( Some( ev ) )
                                } else {
                                    Ok( None )
                                }
                            }
                            r => Ok( r )
                        }
                    }

                    pub fn read_raw( &mut self, buf:&mut [u8], timeout: Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        if !self.reader.in_buffer.is_empty()
                        {
                            let n = buf.len().min( self.reader.in_buffer.len() );
                            buf[..n].copy_from_slice( &self.reader.in_buffer[..n] );

                            let _ = self.reader.in_buffer.drain( ..n );

                            return Ok( Some( Event::Raw( n ) ) );
                        }

                        match self.read_input( buf, timeout )?
                        {
                            Some( Event::Signal( sig ) ) => {
                                if let Some( event ) = self.handle_signal( sig )? {
                                    Ok( Some( event ) )
                                } else {
                                    Ok( None )
                                }
                            }
                            r => Ok( r )
                        }
                    }

                    fn read_into_buffer( &mut self, timeout: Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        let mut buf = replace( &mut self.reader.in_buffer, Vec::new() );

                        buf.reserve( 128 );

                        let len = buf.len();
                        let cap = buf.capacity();
                        let r;

                        unsafe {
                            buf.set_len( cap );

                            r = self.read_input( &mut buf[len..], timeout );

                            match r {
                                Ok( Some( Event::Raw( n ) ) ) => buf.set_len( len + n ),
                                _ => buf.set_len( len )
                            }
                        }
                        
                        self.reader.in_buffer = buf;
                        r
                    }

                    fn read_input( &mut self, buf:&mut [u8], timeout: Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        if let Some( sig ) = take_signal()
                        { return Ok( Some( Event::Signal( sig ) )  ); }

                        if !self.wait_event( timeout )? { return Ok( None  ); }
                        
                        if let Some( sig ) = take_signal() {
                            return Ok( Some( Event::Signal( sig ) ) );
                        }

                        loop {
                            match read( self.term.in_fd, buf ) {
                                Ok( n ) => break Ok( Some( Event::Raw( n ) ) ),
                                Err( Errno::EINTR ) => {
                                    if let Some( sig ) = take_signal() {
                                        return Ok( Some( Event::Signal( sig ) ) );
                                    }
                                }
                                Err( e ) => return Err( nix_to_io( e ) )
                            }
                        }
                    }

                    fn try_read( &mut self ) -> io::Result<Option<Event>>
                    {
                        Ok( None )
                        /*
                        let in_buffer = &mut self.reader.in_buffer;

                        if in_buffer.is_empty() {
                            Ok( None )
                        } else {
                            match peek_event( &in_buffer, &self.term.sequences ) {
                                Ok( Some( ( ev, n ) ) ) => {
                                    let _ = in_buffer.drain( ..n );
                                    Ok( Some( ev ) )
                                }
                                Ok( None ) => Ok( None ),
                                Err( e ) => Err( e )
                            }
                        } */
                    }

                    fn handle_signal( &mut self, sig: Signal ) -> io::Result<Option<Event>>
                    {
                        match sig {
                            Signal::Continue => {
                                self.resume()?;
                            }
                            Signal::Resize => {
                                let size = self.term.size()?;
                                return Ok( Some( Event::Resize( size ) ) );
                            }
                            _ => ()
                        }

                        if self.reader.report_signals.contains( sig ) {
                            Ok( Some( Event::Signal( sig ) ) )
                        } else {
                            Ok( None )
                        }
                    }

                    fn resume( &mut self ) -> io::Result<()>
                    {
                        if let Some( resume ) = self.reader.resume {
                            let _ = self.prepare( resume.config )?;
                        }
                        Ok( () )
                    }
                }

                impl<'a> TerminalWriteGuard<'a> 
                {
                    fn new( term:&'a Terminus, writer: MutexGuard<'a, Writer> ) -> TerminalWriteGuard<'a> 
                    {
                        TerminalWriteGuard{term, writer}
                    }

                    pub fn size( &self ) -> io::Result<Size> 
                    {
                        get_winsize( self.term.out_fd )
                    }

                    fn disable_keypad( &mut self ) -> io::Result<()> 
                    {
                        /*
                        if let Some( local ) = self.term.info.get::<cap::KeypadLocal>() {
                            self.expand( local.expand() )?;
                        } */
                        Ok( () )
                    }

                    fn enable_keypad( &mut self ) -> io::Result<bool> 
                    {
                        /*
                        if let Some( xmit ) = self.term.info.get::<cap::KeypadXmit>() {
                            self.expand( xmit.expand() )?;
                            Ok( true )
                        } else {
                            Ok( false )
                        } */
                        Ok( true )
                    }

                    fn disable_mouse( &mut self ) -> io::Result<()> 
                    {
                        self.write_bytes( XTERM_DISABLE_MOUSE.as_bytes() )?;
                        self.write_bytes( XTERM_DISABLE_MOUSE_MOTION.as_bytes() )
                    }

                    fn enable_mouse( &mut self, track_motion: bool ) -> io::Result<bool> 
                    {
                        if self.term.is_xterm() {
                            self.write_bytes( XTERM_ENABLE_MOUSE.as_bytes() )?;
                            if track_motion {
                                self.write_bytes( XTERM_ENABLE_MOUSE_MOTION.as_bytes() )?;
                            }
                            Ok( true )
                        } else {
                            Ok( false )
                        }
                    }

                    fn enter_screen( &mut self ) -> io::Result<()> 
                    {
                        /*
                        match ( self.term.info.get::<cap::EnterCaMode>(),
                                self.term.info.get::<cap::ChangeScrollRegion>(),
                                self.term.info.get::<cap::CursorHome>() ) {
                            ( enter, Some( scroll ), Some( home ) ) => {
                                let size = self.size()?;

                                if let Some( enter ) = enter {
                                    self.expand( enter.expand() )?;
                                }

                                self.expand( scroll.expand()
                                    .parameters( 0, to_u32( size.lines - 1 ) ) )?;
                                self.expand( home.expand() )?;
                            }
                            ( _, None, _ ) => return Err( not_supported( "change_scroll_region" ) ),
                            ( _, _, None ) => return Err( not_supported( "cursor_home" ) ),
                        }

                        self.clear_attributes()?;
                        self.clear_screen()?; */
                        Ok( () )
                    }

                    fn exit_screen( &mut self ) -> io::Result<()> 
                    {
                        /*
                        if let Some( exit ) = self.term.info.get::<cap::ExitCaMode>() {
                            self.expand( exit.expand() )?;
                            self.flush()?;
                        } */
                        Ok( () )
                    }

                    pub fn clear_attributes( &mut self ) -> io::Result<()> 
                    {
                        /*
                        if self.writer.fg.is_some() || self.writer.bg.is_some() ||
                                !self.writer.cur_style.is_empty() {
                            self.writer.fg = None;
                            self.writer.bg = None;
                            self.writer.cur_style = Style::empty();
                            expand_opt!( self, cap::ExitAttributeMode )?;
                        } */

                        Ok( () )
                    }

                    pub fn set_fg( &mut self, fg: Option<Color> ) -> io::Result<()> 
                    {
                        if self.writer.fg == fg {
                            Ok( () )
                        } else {
                            if let Some( fg ) = fg {
                                self.set_fg_color( fg )?;
                            } else {
                                self.clear_fg()?;
                            }

                            self.writer.fg = fg;
                            Ok( () )
                        }
                    }

                    pub fn set_bg( &mut self, bg: Option<Color> ) -> io::Result<()> 
                    {
                        if self.writer.bg == bg {
                            Ok( () )
                        } else {
                            if let Some( bg ) = bg {
                                self.set_bg_color( bg )?;
                            } else {
                                self.clear_bg()?;
                            }

                            self.writer.bg = bg;
                            Ok( () )
                        }
                    }

                    pub fn add_style( &mut self, style: Style ) -> io::Result<()> 
                    {
                        let add = style - self.writer.cur_style;
                        /*
                        let add = style - self.writer.cur_style;

                        if add.contains( Style::BOLD ) {
                            expand_opt!( self, cap::EnterBoldMode )?;
                        }
                        if add.contains( Style::ITALIC ) {
                            expand_opt!( self, cap::EnterItalicsMode )?;
                        }
                        if add.contains( Style::REVERSE ) {
                            expand_opt!( self, cap::EnterReverseMode )?;
                        }
                        if add.contains( Style::UNDERLINE ) {
                            expand_opt!( self, cap::EnterUnderlineMode )?;
                        }

                        self.writer.cur_style |= add; */

                        Ok( () )
                    }

                    pub fn remove_style( &mut self, style: Style ) -> io::Result<()> 
                    {
                        /*
                        let remove = style & self.writer.cur_style;

                        if remove.intersects( Style::BOLD | Style::REVERSE ) {
                            let new_style = self.writer.cur_style - remove;
                            let fg = self.writer.fg;
                            let bg = self.writer.bg;
                            self.clear_attributes()?;
                            self.add_style( new_style )?;
                            self.set_fg( fg )?;
                            self.set_bg( bg )?;
                        } else {
                            if remove.contains( Style::ITALIC ) {
                                expand_opt!( self, cap::ExitItalicsMode )?;
                            }
                            if remove.contains( Style::UNDERLINE ) {
                                expand_opt!( self, cap::ExitUnderlineMode )?;
                            }

                            self.writer.cur_style -= remove;
                        } */

                        Ok( () )
                    }

                    pub fn set_style( &mut self, style: Style ) -> io::Result<()> 
                    {
                        let add = style - self.writer.cur_style;
                        let remove = self.writer.cur_style - style;

                        if remove.intersects( Style::BOLD | Style::REVERSE ) {
                            let fg = self.writer.fg;
                            let bg = self.writer.bg;
                            self.clear_attributes()?;
                            self.set_fg( fg )?;
                            self.set_bg( bg )?;
                            self.add_style( style )?;
                        } else {
                            self.add_style( add )?;
                            self.remove_style( remove )?;
                        }

                        Ok( () )
                    }

                    pub fn set_theme( &mut self, theme: Theme ) -> io::Result<()> 
                    {
                        self.set_attrs( theme.fg, theme.bg, theme.style )
                    }

                    pub fn set_attrs( &mut self, fg: Option<Color>, bg: Option<Color>, style: Style ) -> io::Result<()>
                    {
                        if ( self.writer.fg.is_some() && fg.is_none() ) ||
                                ( self.writer.bg.is_some() && bg.is_none() ) {
                            self.clear_attributes()?;
                        }

                        self.set_style( style )?;
                        self.set_fg( fg )?;
                        self.set_bg( bg )?;

                        Ok( () )
                    }

                    fn clear_fg( &mut self ) -> io::Result<()> 
                    {
                        let bg = self.writer.bg;
                        let style = self.writer.cur_style;

                        self.clear_attributes()?;
                        self.set_bg( bg )?;
                        self.set_style( style )
                    }

                    fn clear_bg( &mut self ) -> io::Result<()> 
                    {
                        let fg = self.writer.fg;
                        let style = self.writer.cur_style;

                        self.clear_attributes()?;
                        self.set_fg( fg )?;
                        self.set_style( style )
                    }

                    fn set_fg_color( &mut self, fg: Color ) -> io::Result<()> 
                    {
                        //expand_opt!( self, cap::SetAForeground, |ex| ex.parameters( color_code( fg ) ) )
                        Ok( () )
                    }

                    fn set_bg_color( &mut self, bg: Color ) -> io::Result<()> 
                    {
                        //expand_opt!( self, cap::SetABackground, |ex| ex.parameters( color_code( bg ) ) )
                        Ok( () )
                    }

                    pub fn clear_screen( &mut self ) -> io::Result<()> 
                    {
                        //expand_req!( self, cap::ClearScreen, "clear_screen" )
                        Ok( () )
                    }

                    pub fn clear_to_line_end( &mut self ) -> io::Result<()> 
                    {
                        /*expand_req!( self, cap::ClrEol, "clr_eol" ) */
                        Ok( () )
                    }

                    pub fn clear_to_screen_end( &mut self ) -> io::Result<()> 
                    {
                        /* expand_req!( self, cap::ClrEos, "clr_eos" ) */
                        Ok( () )
                    }

                    pub fn move_up( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n == 1 {
                            expand_req!( self, cap::CursorUp, "cursor_up" )?;
                        } else if n != 0 {
                            expand_req!( self, cap::ParmUpCursor, "parm_cursor_up",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */
                        Ok( () )
                    }

                    pub fn move_down( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n != 0 {
                            expand_req!( self, cap::ParmDownCursor, "parm_cursor_down",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */

                        Ok( () )
                    }

                    pub fn move_left( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n == 1 {
                            expand_req!( self, cap::CursorLeft, "cursor_left" )?;
                        } else if n != 0 {
                            expand_req!( self, cap::ParmLeftCursor, "parm_cursor_left",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */

                        Ok( () )
                    }

                    pub fn move_right( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n == 1 {
                            expand_req!( self, cap::CursorRight, "cursor_right" )?;
                        } else if n != 0 {
                            expand_req!( self, cap::ParmRightCursor, "parm_cursor_right",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */
                        Ok( () )
                    }

                    pub fn move_to_first_column( &mut self ) -> io::Result<()> 
                    {
                        self.write_bytes( b"\r" )
                    }

                    pub fn move_cursor( &mut self, pos: Cursor ) -> io::Result<()> 
                    {
                        /*
                        match ( self.term.info.get::<cap::CursorAddress>(),
                                self.term.info.get::<cap::CursorHome>() ) {
                            ( _, Some( ref home ) ) if pos == Cursor::default() => {
                                self.expand( home.expand() )?;
                            }
                            ( Some( addr ), _ ) => {
                                self.expand( addr.expand()
                                    .parameters( to_u32( pos.line ), to_u32( pos.column ) ) )?;
                            }
                            ( None, _ ) => return Err( not_supported( "cursor_address" ) )
                        } */

                        Ok( () )
                    }

                    pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> 
                    {
                        /* match mode
                        {
                            CursorMode::Normal | CursorMode::Overwrite =>
                            { expand_opt!( self, cap::CursorNormal )?; }
                            
                            CursorMode::Invisible =>
                            { expand_opt!( self, cap::CursorInvisible )?; }
                        } v */
                        Ok( () )
                    }

                    pub fn write_char( &mut self, ch:char ) -> io::Result<()> 
                    {
                        self.write_str( ch.encode_utf8( &mut [0; 4] ) )
                    }

                    pub fn write_str( &mut self, s:&str ) -> io::Result<()> 
                    {
                        self.write_bytes( s.as_bytes() )
                    }

                    pub fn write_styled( &mut self,
                            fg: Option<Color>, bg: Option<Color>, style: Style, text:&str )
                            -> io::Result<()> {
                        self.set_attrs( fg, bg, style )?;

                        self.write_str( text )?;
                        self.clear_attributes()
                    }

                    fn write_bytes( &mut self, buf:&[u8] ) -> io::Result<()> 
                    {
                        if buf.len() + self.writer.out_buffer.len() > self.writer.out_buffer.capacity() {
                            self.flush()?;
                        }

                        if buf.len() > self.writer.out_buffer.capacity() {
                            self.write_data( buf ).1
                        } else {
                            self.writer.out_buffer.extend( buf );
                            Ok( () )
                        }
                    }

                    pub fn flush( &mut self ) -> io::Result<()> 
                    {
                        let ( n, res ) = self.write_data( &self.writer.out_buffer );
                        self.writer.out_buffer.drain( ..n );
                        res
                    }

                    fn write_data( &self, buf:&[u8] ) -> ( usize, io::Result<()> ) 
                    {
                        ( 0, Ok( () ) )
                        /*
                        let mut offset = 0;

                        let r = loop {
                            if offset == buf.len() {
                                break Ok( () );
                            }

                            match write( self.term.out_fd, buf ) 
                            {
                                Ok( 0 ) => break Err( io::Error::from( io::ErrorKind::WriteZero ) ),
                                Ok( n ) => offset += n,
                                Err( Errno::EINTR ) => continue,
                                Err( e ) => break Err( nix_to_io( e ) )
                            }
                        };

                        ( offset, r ) */
                    }
                    /*
                    fn expand<T: AsRef<[u8]>>( &mut self, exp: Expansion<T> ) -> io::Result<()> {
                        let writer = &mut *self.writer;
                        exp
                            .with( &mut writer.context )
                            .to( &mut writer.out_buffer )
                            .map_err( ti_to_io )
                    } */
                }

                impl<'a> Drop for TerminalWriteGuard<'a> 
                {
                    fn drop( &mut self ) {
                        if let Err( e ) = self.flush() {
                            eprintln!( "failed to flush terminal: {}", e );
                        }
                    }
                }

                impl Writer 
                {
                    fn new() -> Writer 
                    {
                        Writer{
                            //context: Context::default(),
                            out_buffer: Vec::with_capacity( OUT_BUFFER_SIZE ),
                            fg: None,
                            bg: None,
                            cur_style: Style::empty(),
                        }
                    }
                }
                /*
                fn sequences( info:&Database ) -> SeqMap 
                {
                    let mut sequences = SequenceMap::new();

                    macro_rules! add {
                        ( $seq:ty , $key:expr ) => { {
                            if let Some( seq ) = info.get::<$seq>() {
                                if let Some( s ) = ascii_str( seq.as_ref() ) {
                                    sequences.insert( s.into(), SeqData::Key( $key ) );
                                }
                            }
                        } }
                    }

                    add!( cap::KeyUp,        Key::Up );
                    add!( cap::KeyDown,      Key::Down );
                    add!( cap::KeyLeft,      Key::Left );
                    add!( cap::KeyRight,     Key::Right );
                    add!( cap::KeyHome,      Key::Home );
                    add!( cap::KeyEnd,       Key::End );
                    add!( cap::KeyNPage,     Key::PageDown );
                    add!( cap::KeyPPage,     Key::PageUp );
                    add!( cap::KeyDc,        Key::Delete );
                    add!( cap::KeyIc,        Key::Insert );
                    add!( cap::KeyF1,        Key::F( 1 ) );
                    add!( cap::KeyF2,        Key::F( 2 ) );
                    add!( cap::KeyF3,        Key::F( 3 ) );
                    add!( cap::KeyF4,        Key::F( 4 ) );
                    add!( cap::KeyF5,        Key::F( 5 ) );
                    add!( cap::KeyF6,        Key::F( 6 ) );
                    add!( cap::KeyF7,        Key::F( 7 ) );
                    add!( cap::KeyF8,        Key::F( 8 ) );
                    add!( cap::KeyF9,        Key::F( 9 ) );
                    add!( cap::KeyF10,       Key::F( 10 ) );
                    add!( cap::KeyF11,       Key::F( 11 ) );
                    add!( cap::KeyF12,       Key::F( 12 ) );

                    if is_xterm( info.name() ) {
                        sequences.insert( XTERM_MOUSE_INTRO.into(), SeqData::XTermMouse );
                    }

                    sequences
                } */

                pub struct PrepareState 
                {
                    old_tio: Option<termios>,
                    old_sigcont: Option<SigAction>,
                    old_sigint: Option<SigAction>,
                    old_sigtstp: Option<SigAction>,
                    old_sigquit: Option<SigAction>,
                    old_sigwinch: Option<SigAction>,
                    restore_keypad: bool,
                    restore_mouse: bool,
                    prev_resume: Option<Resume>,
                }

                impl PrepareState
                {
                    pub const fn new() -> Self
                    {
                        Self
                        {
                            old_tio: None,
                            old_sigcont: None,
                            old_sigint: None,
                            old_sigtstp: None,
                            old_sigquit: None,
                            old_sigwinch: None,
                            restore_keypad: false,
                            restore_mouse: false,
                            prev_resume: None,
                        }
                    }
                }

                #[derive( Copy, Clone, Debug )]
                struct Resume 
                {
                    config: PrepareConfig,
                }

                unsafe fn close_fd( fd: RawFd ) 
                {
                    drop( File::from_raw_fd( fd ) );
                }

                fn open_rw<P: AsRef<Path>>( path: P ) -> io::Result<RawFd> 
                {
                    use ::fs::OpenOptions;

                    let file = OpenOptions::new()
                        .read( true )
                        .write( true )
                        .open( path )?;

                    Ok( file.into_raw_fd() )
                }

                #[repr( C )]
                struct Winsize 
                {
                    ws_row: c_ushort,
                    ws_col: c_ushort,
                    ws_xpixel: c_ushort,
                    ws_ypixel: c_ushort,
                }

                fn get_winsize( fd: c_int ) -> io::Result<Size> 
                {
                    let mut winsz: Winsize = unsafe { zeroed() };
                    let res = unsafe { ioctl( fd, TIOCGWINSZ.into(), &mut winsz ) };

                    if res == -1 {
                        Err( io::Error::last_os_error() )
                    } else {
                        let size = Size{
                            lines: winsz.ws_row as usize,
                            columns: winsz.ws_col as usize,
                        };

                        Ok( size )
                    }
                }

                fn nix_to_io( e:api::Error ) -> io::Error 
                {
                    io::Error::from_raw_os_error( e as i32 )
                }
                /*
                fn ti_to_io( e: terminfo::Error ) -> io::Error 
                {
                    match e {
                        terminfo::Error::Io( e ) => e,
                        terminfo::Error::NotFound => io::Error::new( 
                            io::ErrorKind::NotFound, "terminfo entry not found" ),
                        terminfo::Error::Parse => io::Error::new( 
                            io::ErrorKind::Other, "failed to parse terminfo entry" ),
                        terminfo::Error::Expand( _ ) => io::Error::new( 
                            io::ErrorKind::Other, "failed to expand terminfo entry" ),
                    }
                } */

                fn to_timeval( d: Duration ) -> TimeVal 
                {
                    const MAX_SECS: i64 = i64::max_value() / 1_000;

                    let secs = match d.as_secs() {
                        n if n > MAX_SECS as u64 => MAX_SECS,
                        n => n as i64,
                    };

                    let millis = d.subsec_millis() as i64;

                    TimeVal::milliseconds( secs * 1_000 + millis )
                }
                /*
                fn peek_event( buf:&[u8], sequences:&SeqMap )
                        -> io::Result<Option<( Event, usize )>> {
                    let ( res, n ) = {
                        let s = utf8_prefix( buf )?;

                        if s.is_empty() {
                            return Ok( None );
                        }

                        let mut last_match = None;

                        for pfx in prefixes( s ) {
                            match sequences.find( pfx ) {
                                FindResult::NotFound => break,
                                FindResult::Found( value ) => {
                                    last_match = Some( ( pfx, *value ) );
                                    break;
                                }
                                FindResult::Incomplete => (),
                                FindResult::Undecided( value ) => {
                                    last_match = Some( ( pfx, *value ) );
                                }
                            }
                        }

                        let res = last_match.and_then( |( seq, value )| {
                            match value {
                                SeqData::Key( key ) => Some( ( Event::Key( key ), seq.len() ) ),
                                SeqData::XTermMouse => {
                                    if let Some( ( data, len ) ) = parse_mouse_data( &buf[seq.len()..] ) {
                                        Some( ( Event::Mouse( data ), seq.len() + len ) )
                                    } else {
                                        None
                                    }
                                }
                            }
                        } );

                        if let Some( res ) = res {
                            res
                        } else {
                            let ch = s.chars().next().unwrap();
                            ( Event::Key( ch.into() ), ch.len_utf8() )
                        }
                    };

                    Ok( Some( ( res, n ) ) )
                } */

                fn parse_mouse_data( mut buf:&[u8] ) -> Option<( MouseEvent, usize )> {
                    let orig_len = buf.len();

                    let ( mut input, end ) = parse_integer( &mut buf )?;

                    if end != b';' {
                        return None;
                    }

                    let ( column, end ) = parse_integer( &mut buf )?;

                    if end != b';' {
                        return None;
                    }

                    let ( line, end ) = parse_integer( &mut buf )?;

                    let is_pressed = match end {
                        b'M' => true,
                        b'm' => false,
                        _ => return None
                    };

                    let mut mods = ModifierState::empty();

                    if ( input & XTERM_SHIFT_MASK ) != 0 {
                        mods |= ModifierState::SHIFT;
                    }
                    if ( input & XTERM_META_MASK ) != 0 {
                        mods |= ModifierState::ALT;
                    }
                    if ( input & XTERM_CTRL_MASK ) != 0 {
                        mods |= ModifierState::CTRL;
                    }

                    input &= !XTERM_MODIFIER_MASK;

                    let input = match input {
                        0 ..= 3 => mouse_button_event( input, is_pressed ),
                        64 => MouseInput::WheelUp,
                        65 => MouseInput::WheelDown,
                        _ => MouseInput::Motion,
                    };

                    let position = Cursor{
                        line: ( line - 1 ) as usize,
                        column: ( column - 1 ) as usize,
                    };

                    Some( ( MouseEvent{
                        position,
                        input,
                        modifiers: mods,
                    }, orig_len - buf.len() ) )
                }

                fn parse_integer( buf:&mut &[u8] ) -> Option<( u32, u8 )> {
                    let mut n = 0u32;
                    let mut iter = buf.iter();

                    while let Some( &b ) = iter.next() {
                        match b {
                            b'0' ..= b'9' => {
                                n = n.checked_mul( 10 )?
                                    .checked_add( ( b - b'0' ) as u32 )?;
                            }
                            _ => {
                                *buf = iter.as_slice();
                                return Some( ( n, b ) );
                            }
                        }
                    }

                    None
                }

                fn mouse_button_event( input: u32, is_pressed: bool ) -> MouseInput {
                    let button = match input {
                        0 => MouseButton::Left,
                        1 => MouseButton::Middle,
                        2 => MouseButton::Right,
                        _ => MouseButton::Other( input )
                    };

                    if is_pressed {
                        MouseInput::ButtonPressed( button )
                    } else {
                        MouseInput::ButtonReleased( button )
                    }
                }

                fn utf8_prefix( buf:&[u8] ) -> io::Result<&str> {
                    match from_utf8( buf ) {
                        Ok( s ) => Ok( s ),
                        Err( e ) => {
                            if e.valid_up_to() != 0 {
                                from_utf8( &buf[..e.valid_up_to()] )
                                    .map_err( |_| unreachable!() )
                            } else if e.error_len().is_some() {
                                Err( io::Error::new( io::ErrorKind::Other,
                                    "read invalid utf-8 data from terminal" ) )
                            } else {
                                Ok( "" )
                            }
                        }
                    }
                }

                static LAST_SIGNAL: AtomicUsize = AtomicUsize::new( 0 );

                extern "C" fn handle_signal( signum: c_int ) 
                {
                    LAST_SIGNAL.store( signum as usize, Ordering::Relaxed );
                }

                fn conv_signal( sig: c_int ) -> Option<Signal> 
                {
                    match NixSignal::try_from( sig ).ok() 
                    {
                        Some( NixSignal::SIGCONT )  => Some( Signal::Continue ),
                        Some( NixSignal::SIGINT )   => Some( Signal::Interrupt ),
                        Some( NixSignal::SIGQUIT )  => Some( Signal::Quit ),
                        Some( NixSignal::SIGTSTP )  => Some( Signal::Suspend ),
                        Some( NixSignal::SIGWINCH ) => Some( Signal::Resize ),
                        _ => None
                    }
                }

                fn get_signal() -> Option<Signal> 
                {
                    conv_signal( LAST_SIGNAL.load( Ordering::Relaxed ) as c_int )
                }

                fn take_signal() -> Option<Signal> { conv_signal( LAST_SIGNAL.swap( 0, Ordering::Relaxed ) as c_int ) }

                fn ascii_str( s:&[u8] ) -> Option<&str>
                {
                    use ::str::from_utf8_unchecked;

                    if s.is_ascii() { Some( unsafe { from_utf8_unchecked( s ) } ) }
                    
                    else { None }
                }

                fn color_code( color: Color ) -> u8
                {
                    match color
                    {
                        Color::Black =>     0,
                        Color::Red =>       1,
                        Color::Green =>     2,
                        Color::Yellow =>    3,
                        Color::Blue =>      4,
                        Color::Magenta =>   5,
                        Color::Cyan =>      6,
                        Color::White =>     7,
                    }
                }

                fn not_supported( op:&str ) -> io::Error
                { io::Error::new( io::ErrorKind::Other, format!( "operation not supported: {}", op ) ) }

                #[cfg( target_pointer_width = "64" )]
                fn to_u32( u: usize ) -> u32
                {
                    if u > u32::max_value() as usize { u32::max_value() }
                    else { u as u32 }
                }

                #[cfg( any( target_pointer_width = "16", target_pointer_width = "32" ) )]
                fn to_u32( u: usize ) -> u32 { u as u32 }
            } pub use self::terminal::{ * };
        }

        pub mod windows
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
        }
        #[cfg( unix   )] pub use self::unix as sys;
        #[cfg( windows )] pub use self::windows as sys;
    }
    /*
    linefeed v0.0.0 */
    pub mod command
    {
        /*!
        Defines the set of line editing commands. */
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            *,
        };
        /*
        */
        macro_rules! define_commands
        {
            ( $( #[$meta:meta] $name:ident => $str:expr , )+ ) => 
            {
                /// Represents a command to modify `Reader` state
                #[derive( Clone, Debug, Eq, PartialEq )]
                pub enum Command {
                    $( #[$meta] $name , )+
                    /// Custom application-defined command
                    Custom( Cow<'static, str> ),
                    /// Execute a given key sequence
                    Macro( Cow<'static, str> ),
                }
                /// List of all command names
                pub static COMMANDS:&[&str] = &[ $( $str ),+ ];

                impl fmt::Display for Command {
                    fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
                        match *self {
                            $( Command::$name => f.write_str( $str ) , )+
                            Command::Custom( ref s ) => f.write_str( s ),
                            Command::Macro( ref s ) => write!( f, "\"{}\"",
                                char::escape_sequence( s ) )
                        }
                    }
                }

                impl Command {
                    /// Constructs a command from a `'static str` reference.
                    pub fn from_str( name:&'static str ) -> Command {
                        Command::opt_from_str( name )
                            .unwrap_or_else( || Command::Custom( Borrowed( name ) ) )
                    }
                    /// Constructs a command from a non-`'static` string-like type.
                    pub fn from_string<T>( name: T ) -> Command
                            where T: AsRef<str> + Into<String> {
                        Command::opt_from_str( name.as_ref() )
                            .unwrap_or_else( || Command::Custom( Owned( name.into() ) ) )
                    }

                    fn opt_from_str( s:&str ) -> Option<Command> {
                        match s {
                            $( $str => Some( Command::$name ), )+
                            _ => None
                        }
                    }
                }
            }
        }

        define_commands!
        {
            /// Abort history search
            Abort => "abort",
            /// Accepts the current input line
            AcceptLine => "accept-line",
            /// Perform completion
            Complete => "complete",
            /// Insert all completions into the input buffer
            InsertCompletions => "insert-completions",
            /// Show possible completions
            PossibleCompletions => "possible-completions",
            /// Insert the next possible completion
            MenuComplete => "menu-complete",
            /// Insert the previous possible completion
            MenuCompleteBackward => "menu-complete-backward",
            /// Begin numeric argument input
            DigitArgument => "digit-argument",
            /// Insert character or sequence at the cursor
            SelfInsert => "self-insert",
            /// Inserts a tab character
            TabInsert => "tab-insert",
            /// Toggles insert/overwrite mode
            OverwriteMode => "overwrite-mode",
            /// Insert a comment and accept input
            InsertComment => "insert-comment",
            /// Move the cursor backward one character
            BackwardChar => "backward-char",
            /// Move the cursor forward one character
            ForwardChar => "forward-char",
            /// Search for a given character
            CharacterSearch => "character-search",
            /// Search backward for a given character
            CharacterSearchBackward => "character-search-backward",
            /// Move the cursor backward one word
            BackwardWord => "backward-word",
            /// Move the cursor forward one word
            ForwardWord => "forward-word",
            /// Kill all characters before the cursor
            BackwardKillLine => "backward-kill-line",
            /// Kill all characters after the cursor
            KillLine => "kill-line",
            /// Kill a word before the cursor
            BackwardKillWord => "backward-kill-word",
            /// Kill a word after the cursor
            KillWord => "kill-word",
            /// Kill a word before the cursor, delimited by whitespace
            UnixWordRubout => "unix-word-rubout",
            /// Clear the screen
            ClearScreen => "clear-screen",
            /// Move the cursor to the beginning of the line
            BeginningOfLine => "beginning-of-line",
            /// Move the cursor to the end of the line
            EndOfLine => "end-of-line",
            /// Delete one character before the cursor
            BackwardDeleteChar => "backward-delete-char",
            /// Delete one character after the cursor
            DeleteChar => "delete-char",
            /// Drag the character before the cursor forward
            TransposeChars => "transpose-chars",
            /// Drag the word before the cursor forward
            TransposeWords => "transpose-words",
            /// Move to the first line of history
            BeginningOfHistory => "beginning-of-history",
            /// Move to the last line of history
            EndOfHistory => "end-of-history",
            /// Select next line in history
            NextHistory => "next-history",
            /// Select previous line in history
            PreviousHistory => "previous-history",
            /// Incremental search in history
            ForwardSearchHistory => "forward-search-history",
            /// Incremental reverse search in history
            ReverseSearchHistory => "reverse-search-history",
            /// Non-incremental forward history search using input up to the cursor
            HistorySearchForward => "history-search-forward",
            /// Non-incremental backward history search using input up to the cursor
            HistorySearchBackward => "history-search-backward",
            /// Insert literal character
            QuotedInsert => "quoted-insert",
            /// Insert text into buffer from the kill ring
            Yank => "yank",
            /// Rotate the kill ring and yank the new top
            YankPop => "yank-pop",
        }
        /// Describes the category of a command.
        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum Category
        {
            /// Completion command
            Complete,
            /// Kill command
            Kill,
            /// Non-incremental search command
            Search,
            /// Incremental search command
            IncrementalSearch,
            /// Yank command
            Yank,
            /// Digit argument command
            Digit,
            /// Other command
            Other,
        }

        impl Command
        {
            /// Returns the category of the command
            pub fn category( &self ) -> Category
            {
                use self::Command::*;

                match *self
                {
                    DigitArgument => Category::Digit, 
                    Complete | InsertCompletions | PossibleCompletions |
                    MenuComplete | MenuCompleteBackward => Category::Complete,
                    BackwardKillLine | KillLine | BackwardKillWord | KillWord | UnixWordRubout => Category::Kill,
                    ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                    HistorySearchForward | HistorySearchBackward => Category::Search,
                    Yank | YankPop => Category::Yank,
                    _ => Category::Other
                }
            }
        }
    }

    pub mod complete
    {
        /*!
        Provides utilities for implementing word completion. */
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            fs::{ read_dir },
            path::{ is_separator, MAIN_SEPARATOR },
            system::
            {
                prompter::{ Prompter },
                terminal::{ Terminal },
            },
            *,
        };
        /*
        use crate::prompter::Prompter;
        */
        /// Represents a single possible completion
        #[derive( Clone, Debug )]
        pub struct Completion
        {
            /// Whole completion text
            pub completion: String,
            /// Listing display string; `None` if matches completion
            pub display: Option<String>,
            /// Completion suffix; replaces append character
            pub suffix: Suffix,
        }
        /// Specifies an optional suffix to override the default value
        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum Suffix 
        {
            /// Use the default suffix
            Default,
            /// Use no suffix
            None,
            /// Use the given suffix
            Some( char ),
        }

        impl Completion
        {
            /// Returns a simple `Completion` value, with display string matching
            /// completion and using the default completion suffix.
            pub fn simple( s: String ) -> Completion 
            {
                Completion{
                    completion: s,
                    display: None,
                    suffix: Suffix::default(),
                }
            }
            /// Returns the full completion string, including suffix, using the given
            /// default suffix if one is not assigned to this completion.
            pub fn completion( &self, def_suffix: Option<char> ) -> Cow<str> 
            {
                let mut s = Borrowed( &self.completion[..] );

                if let Some( suffix ) = self.suffix.with_default( def_suffix ) {
                    s.to_mut().push( suffix );
                }

                s
            }
            /// Returns the display string, including suffix
            pub fn display( &self ) -> Cow<str> 
            {
                let mut s = Borrowed( self.display_str() );

                if let Suffix::Some( suffix ) = self.suffix {
                    s.to_mut().push( suffix );
                }

                s
            }
            /// Returns the number of characters displayed
            pub fn display_chars( &self ) -> usize 
            {
                let n = self.display_str().chars().count();
                n + if self.suffix.is_some() { 1 } else { 0 }
            }

            fn display_str( &self ) -> &str 
            {
                match self.display {
                    Some( ref dis ) => dis,
                    None => &self.completion
                }
            }
        }

        impl Suffix 
        {
            /// Returns whether the `Suffix` value is the `Default` variant.
            pub fn is_default( &self ) -> bool 
            {
                match *self {
                    Suffix::Default => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `Some( _ )` variant.
            pub fn is_some( &self ) -> bool 
            {
                match *self {
                    Suffix::Some( _ ) => true,
                    _ => false
                }
            }
            /// Returns whether the `Suffix` value is the `None` variant.
            pub fn is_none( &self ) -> bool 
            {
                match *self {
                    Suffix::None => true,
                    _ => false
                }
            }
            /// Returns an `Option<char>`, using the given value in place of `Default`.
            pub fn with_default( self, default: Option<char> ) -> Option<char> 
            {
                match self 
                {
                    Suffix::None => None,
                    Suffix::Some( ch ) => Some( ch ),
                    Suffix::Default => default
                }
            }
        }

        impl Default for Suffix 
        {
            fn default() -> Suffix 
            {
                Suffix::Default
            }
        }
        /// Performs completion for `Prompter` when triggered by a user input sequence
        pub trait Completer<Term: Terminal>: Send + Sync 
        {
            /// Returns the set of possible completions for the prefix `word`.
            fn complete( &self, word:&str, prompter:&Prompter<Term>, start:usize, end:usize ) -> Option<Vec<Completion>>;
            /// Returns the starting position of the word under the cursor.
            fn word_start( &self, line:&str, end: usize, prompter:&Prompter<Term> ) -> usize
            {
                word_break_start( &line[..end], prompter.word_break_chars() )
            }
            /// Quotes a possible completion for insertion into input.
            fn quote<'a>( &self, word:&'a str ) -> Cow<'a, str> { Borrowed( word ) }
            /// Unquotes a piece of user input before searching for completions.
            fn unquote<'a>( &self, word:&'a str ) -> Cow<'a, str> { Borrowed( word ) }
        }
        /// `Completer` type that performs no completion.
        pub struct DummyCompleter;

        impl<Term: Terminal> Completer<Term> for DummyCompleter
        {
            fn complete
            ( 
                &self,
                _word:&str,
                _reader:&Prompter<Term>,
                _start: usize,
                _end: usize
            ) -> Option<Vec<Completion>> { None }
        }
        /// Performs completion by searching for filenames matching the word prefix.
        pub struct PathCompleter;

        impl<Term: Terminal> Completer<Term> for PathCompleter 
        {
            fn complete( &self, word:&str, _reader:&Prompter<Term>, _start: usize, _end: usize )
                    -> Option<Vec<Completion>> {
                Some( complete_path( word ) )
            }

            fn word_start( &self, line:&str, end: usize, _reader:&Prompter<Term> ) -> usize {
                escaped_word_start( &line[..end] )
            }

            fn quote<'a>( &self, word:&'a str ) -> Cow<'a, str> {
                escape( word )
            }

            fn unquote<'a>( &self, word:&'a str ) -> Cow<'a, str> {
                unescape( word )
            }
        }
        /// Returns a sorted list of paths whose prefix matches the given path.
        pub fn complete_path( path:&str ) -> Vec<Completion> 
        {
            let ( base_dir, fname ) = split_path( path );
            let mut res = Vec::new();

            let lookup_dir = base_dir.unwrap_or( "." );

            if let Ok( list ) = read_dir( lookup_dir ) {
                for ent in list {
                    if let Ok( ent ) = ent {
                        let ent_name = ent.file_name();

                        if let Ok( path ) = ent_name.into_string() {
                            if path.starts_with( fname ) {
                                let ( name, display ) = if let Some( dir ) = base_dir {
                                    ( format!( "{}{}{}", dir, MAIN_SEPARATOR, path ),
                                        Some( path ) )
                                } else {
                                    ( path, None )
                                };

                                let is_dir = ent.metadata().ok()
                                    .map_or( false, |m| m.is_dir() );

                                let suffix = if is_dir {
                                    Suffix::Some( MAIN_SEPARATOR )
                                } else {
                                    Suffix::Default
                                };

                                res.push( Completion{
                                    completion: name,
                                    display: display,
                                    suffix: suffix,
                                } );
                            }
                        }
                    }
                }
            }

            res.sort_by( |a, b| a.display_str().cmp( b.display_str() ) );
            res
        }
        /// Returns the start position of the word that ends at the end of the string.
        pub fn word_break_start( s:&str, word_break:&str ) -> usize 
        {
            let mut start = s.len();

            for ( idx, ch ) in s.char_indices().rev() {
                if word_break.contains( ch ) {
                    break;
                }
                start = idx;
            }

            start
        }
        /// Returns the start position of a word with non-word characters escaped by
        /// backslash ( `\\` ).
        pub fn escaped_word_start( s:&str ) -> usize 
        {
            let mut chars = s.char_indices().rev();
            let mut start = s.len();

            while let Some( ( idx, ch ) ) = chars.next() {
                if needs_escape( ch ) {
                    let n = {
                        let mut n = 0;

                        loop {
                            let mut clone = chars.clone();

                            let ch = match clone.next() {
                                Some( ( _, ch ) ) => ch,
                                None => break
                            };

                            if ch == '\\' {
                                chars = clone;
                                n += 1;
                            } else {
                                break;
                            }
                        }

                        n
                    };

                    if n % 2 == 0 {
                        break;
                    }
                }

                start = idx;
            }

            start
        }
        /// Escapes a word by prefixing a backslash ( `\\` ) to non-word characters.
        pub fn escape( s:&str ) -> Cow<str> 
        {
            let n = s.chars().filter( |&ch| needs_escape( ch ) ).count();

            if n == 0 {
                Borrowed( s )
            } else {
                let mut res = String::with_capacity( s.len() + n );

                for ch in s.chars() {
                    if needs_escape( ch ) {
                        res.push( '\\' );
                    }
                    res.push( ch );
                }

                Owned( res )
            }
        }
        /// Unescapes a word by removing the backslash ( `\\` ) from escaped characters.
        pub fn unescape( s:&str ) -> Cow<str> 
        {
            if s.contains( '\\' ) {
                let mut res = String::with_capacity( s.len() );
                let mut chars = s.chars();

                while let Some( ch ) = chars.next() {
                    if ch == '\\' {
                        if let Some( ch ) = chars.next() {
                            res.push( ch );
                        }
                    } else {
                        res.push( ch );
                    }
                }

                Owned( res )
            } else {
                Borrowed( s )
            }
        }

        fn needs_escape( ch:char ) -> bool 
        {
            match ch {
                ' ' | '\t' | '\n' | '\\' => true,
                _ => false
            }
        }

        fn split_path( path:&str ) -> ( Option<&str>, &str ) 
        {
            match path.rfind( is_separator ) {
                Some( pos ) => ( Some( &path[..pos] ), &path[pos + 1..] ),
                None => ( None, path )
            }
        }
    }

    pub mod function
    {
        /*!
        Provides the `Function` trait for implementing custom `Prompter` commands. */
        use ::
        {
            system::
            {
                command::Category,
                prompter::Prompter,
                terminal::Terminal,
            },
            *,
        };
        /*
        */
        /// Implements custom functionality for a `Prompter` command
        pub trait Function<Term: Terminal>: Send + Sync
        {
            /// Executes the function.
            fn execute( &self, prompter:&mut Prompter<Term>, count: i32, ch:char ) -> io::Result<()>;
            /// Returns the command category.
            fn category( &self ) -> Category { Category::Other }
        }

        impl<F, Term: Terminal> Function<Term> for F where
        F: Send + Sync,
        F: Fn( &mut Prompter<Term>, i32, char ) -> io::Result<()>
        {
            fn execute( &self, prompter:&mut Prompter<Term>, count: i32, ch:char ) -> io::Result<()>
            { self( prompter, count, ch ) }
        }
    }

    pub mod input
    {
        /*!
        Parses configuration files in the format of GNU Readline `inputrc` */
        use ::
        {
            char::{ from_u32, ctrl, meta, parse_char_name },
            fs::File,
            io::{stderr, Read, Write},
            path::Path,
            str::{Chars, Lines},
            system::command::Command,
            *,
        };
        /*
        */
        /// Parsed configuration directive
        #[derive( Clone, Debug )]
        pub enum Directive 
        {
            /// Bind construct; `"input-sequence": command-or-macro`
            Bind( String, Command ),
            /// Conditional construct;
            Conditional{
                /// Value name; if `None`, value refers to application name
                name: Option<String>,
                /// Value to compare
                value: String,
                /// Group of directives evaluated when condition is true
                then_group: Vec<Directive>,
                /// Group of directives evaluated when condition is false
                else_group: Vec<Directive>,
            },
            /// Set variable; `set name value`
            SetVariable( String, String ),
        }
        /// Parses the named file and returns contained directives.
        pub fn parse_file<P: ?Sized>( filename:&P ) -> Option<Vec<Directive>> where
        P: AsRef<Path>
        {
            let filename = filename.as_ref();
            let mut f = match File::open( filename )
            {
                Ok( f ) => f,
                Err( e ) => {
                    let _ = writeln!( stderr(), "linefeed: {}: {}", filename.display(), e );
                    return None;
                }
            };

            let mut buf = String::new();

            if let Err( e ) = f.read_to_string( &mut buf ) 
            {
                let _ = writeln!( stderr(), "{}: {}", filename.display(), e );
                return None;
            }

            Some( parse_text( filename, &buf ) )
        }
        /// Parses some text and returns contained directives.
        pub fn parse_text<P: ?Sized>( name:&P, line:&str ) -> Vec<Directive> where
        P: AsRef<Path>
        {
            let mut p = Parser::new( name.as_ref(), line );
            p.parse()
        }

        struct Parser<'a> 
        {
            lines: Lines<'a>,
            filename:&'a Path,
            line_num: usize,
        }

        enum Token<'a> 
        {
            /// Colon; `:`
            Colon,
            /// Equal; `=`
            Equal,
            /// Conditional or other special directive; `$word`
            SpecialWord( &'a str ),
            /// Double-quoted string; `"foo"`
            String( String ),
            /// Bare word; `foo`
            Word( &'a str ),
            /// Invalid token
            Invalid,
        }

        impl<'a> Parser<'a>
        {
            pub fn new( filename:&'a Path, text:&'a str ) -> Parser<'a> 
            {
                Parser{
                    lines: text.lines(),
                    filename: filename,
                    line_num: 0,
                }
            }

            fn next_line( &mut self ) -> Option<&'a str> 
            {
                self.lines.next().map( |line| {
                    self.line_num += 1;
                    line.trim()
                } )
            }

            fn parse( &mut self ) -> Vec<Directive> 
            {
                let mut dirs = Vec::new();

                while let Some( line ) = self.next_line() {
                    if line.starts_with( '#' ) {
                        continue;
                    }

                    let mut tokens = Tokens::new( line );

                    if let Some( Token::SpecialWord( "include" ) ) = tokens.next() {
                        let path = tokens.line;

                        if let Some( d ) = parse_file( Path::new( path ) ) {
                            dirs.extend( d );
                        }

                        continue;
                    }

                    if let Some( dir ) = self.parse_line( line ) {
                        dirs.push( dir );
                    }
                }

                dirs
            }

            fn parse_conditional( &mut self ) -> ( Vec<Directive>, Vec<Directive> ) 
            {
                let mut then_group = Vec::new();
                let mut else_group = Vec::new();
                let mut parse_else = false;

                loop {
                    let line = match self.next_line() {
                        Some( line ) => line,
                        None => {
                            self.error( "missing $endif directive" );
                            break;
                        }
                    };

                    if line.starts_with( '#' ) {
                        continue;
                    }

                    let mut tokens = Tokens::new( line );

                    let start = match tokens.next() {
                        Some( tok ) => tok,
                        None => continue
                    };

                    match start {
                        Token::SpecialWord( "else" ) => {
                            if parse_else {
                                self.error( "duplicate $else directive" );
                            } else {
                                parse_else = true;
                            }
                        }
                        Token::SpecialWord( "endif" ) => {
                            break;
                        }
                        _ => {
                            if let Some( dir ) = self.parse_line( line ) {
                                if parse_else {
                                    else_group.push( dir );
                                } else {
                                    then_group.push( dir );
                                }
                            }
                        }
                    }
                }

                ( then_group, else_group )
            }

            fn parse_line( &mut self, line:&str ) -> Option<Directive> 
            {
                let mut tokens = Tokens::new( line );

                let start = tokens.next()?;

                let dir = match start {
                    Token::SpecialWord( "if" ) => {
                        let name = match tokens.next() {
                            Some( Token::Word( w ) ) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let ( name, value ) = match tokens.next() {
                            Some( Token::Equal ) => {
                                let value = match tokens.next() {
                                    Some( Token::Word( w ) ) => w,
                                    None => "",
                                    _ => {
                                        self.invalid();
                                        return None;
                                    }
                                };

                                ( Some( name ), value )
                            }
                            None => ( None, name ),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let ( then_group, else_group ) = self.parse_conditional();

                        Directive::Conditional{
                            name: name.map( |s| s.to_owned() ),
                            value: value.to_owned(),
                            then_group: then_group,
                            else_group: else_group,
                        }
                    }
                    Token::SpecialWord( "else" ) => {
                        self.error( "$else without matching $if directive" );
                        return None;
                    }
                    Token::SpecialWord( "endif" ) => {
                        self.error( "$endif without matching $if directive" );
                        return None;
                    }
                    Token::String( seq ) => {
                        match tokens.next() {
                            Some( Token::Colon ) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        match tokens.next() {
                            Some( Token::Word( value ) ) =>
                                Directive::Bind( seq, Command::from_string( value ) ),
                            Some( Token::String( out ) ) =>
                                Directive::Bind( seq, Command::Macro( out.to_owned().into() ) ),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    Token::Word( "set" ) => {
                        let name = match tokens.next() {
                            Some( Token::Word( w ) ) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let rest = tokens.line;

                        let value = match tokens.next() {
                            Some( Token::String( s ) ) => s,
                            Some( Token::Word( _ ) ) => rest.to_owned(),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        Directive::SetVariable( name.to_owned(), value )
                    }
                    Token::Word( name ) => {
                        match tokens.next() {
                            Some( Token::Colon ) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        let seq = match parse_char_name( name ) {
                            Some( seq ) => seq,
                            None => {
                                self.invalid();
                                return None;
                            }
                        };

                        match tokens.next() {
                            Some( Token::Word( value ) ) =>
                                Directive::Bind( seq, Command::from_string( value ) ),
                            Some( Token::String( macro_seq ) ) =>
                                Directive::Bind( seq, Command::Macro( macro_seq.to_owned().into() ) ),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    _ => {
                        self.invalid();
                        return None;
                    }
                };

                Some( dir )
            }

            fn error( &self, msg:&str ) 
            {
                let _ = writeln!( stderr(),
                    "linefeed: {} line {}: {}", self.filename.display(), self.line_num, msg );
            }

            fn invalid( &self  ) { self.error( "invalid directive" ); }
        }

        struct Tokens<'a>
        {
            line:&'a str,
        }

        impl<'a> Tokens<'a>
        {
            fn new( line:&str ) -> Tokens
            {
                Tokens
                {
                    line: line,
                }
            }
        }

        impl<'a> Iterator for Tokens<'a> 
        {
            type Item = Token<'a>;

            fn next( &mut self ) -> Option<Token<'a>> 
            {
                let ch = self.line.chars().next()?;

                let tok = match ch
                {
                    ':' => {
                        self.line = self.line[1..].trim_start();
                        Token::Colon
                    }

                    '=' => {
                        self.line = self.line[1..].trim_start();
                        Token::Equal
                    }

                    '$' => {
                        let ( word, rest ) = parse_word( &self.line[1..] );
                        self.line = rest.trim_start();
                        Token::SpecialWord( word )
                    }

                    '"' => {
                        let ( tok, rest ) = parse_string( self.line );
                        self.line = rest.trim_start();
                        tok
                    }

                    _ => {
                        let ( word, rest ) = parse_word( self.line );
                        self.line = rest.trim_start();
                        Token::Word( word )
                    }
                };

                Some( tok )
            }
        }

        fn parse_escape( chars:&mut Chars ) -> Option<String> 
        {
            let ch = chars.next()?;

            let esc = match ch {
                'C'  => {
                    match chars.next() {
                        Some( '-' ) => (),
                        _ => return None
                    }
                    ctrl( chars.next()? )
                }
                'M'  => {
                    match chars.next() {
                        Some( '-' ) => (),
                        _ => return None
                    }
                    return Some( meta( chars.next()? ) );
                }
                'e'  => '\x1b',
                '\\' => '\\',
                '"'  => '"',
                '\'' => '\'',
                'a'  => '\x07',
                'b'  => '\x08',
                'd'  => '\x7f',
                'f'  => '\x0c',
                'n'  => '\n',
                'r'  => '\r',
                't'  => '\t',
                'u'  => {
                    match chars.next() {
                        Some( '{' ) => (),
                        _ => return None
                    }

                    let mut n = 0;

                    for _ in 0..6 {
                        match chars.clone().next().and_then( |ch| ch.to_digit( 16 ) ) {
                            Some( digit ) => {
                                chars.next();
                                n *= 16;
                                n += digit;
                            }
                            None => break
                        }
                    }

                    match chars.next() {
                        Some( '}' ) => (),
                        _ => return None
                    }

                    from_u32( n )?
                }
                'v'  => '\x0b',
                'x'  => {
                    let mut n = 0;

                    for _ in 0..2 {
                        let digit = chars.clone().next()?.to_digit( 16 )? as u8;
                        chars.next();

                        n <<= 4;
                        n |= digit;
                    }

                    n as char
                }
                '0' ..= '3' => {
                    let mut n = ch as u8 - b'0';

                    for _ in 0..2 {
                        let digit = chars.clone().next()?.to_digit( 8 )? as u8;
                        chars.next();

                        n <<= 3;
                        n |= digit;
                    }

                    n as char
                }
                _ => return None
            };

            Some( esc.to_string() )
        }

        fn parse_string( s:&str ) -> ( Token, &str ) 
        {
            let mut chars = s.chars();
            let mut res = String::new();
            chars.next();

            while let Some( ch ) = chars.next() {
                match ch {
                    '"' => return ( Token::String( res ), chars.as_str() ),
                    '\\' => {
                        match parse_escape( &mut chars ) {
                            Some( esc ) => {
                                res.push_str( &esc );
                            }
                            None => break
                        }
                    }
                    ch => res.push( ch )
                }
            }

            ( Token::Invalid, "" )
        }

        fn parse_word( s:&str ) -> ( &str, &str ) 
        {
            let mut chars = s.char_indices();

            loop {
                let mut clone = chars.clone();

                match clone.next() {
                    Some( ( ind, ch ) ) if ch == ':' || ch == '"' || ch == '=' ||
                            ch.is_whitespace() => {
                        return ( &s[..ind], &s[ind..] );
                    }
                    None => {
                        return ( s, "" );
                    }
                    _ => ()
                }

                chars = clone;
            }
        }
    }

    pub mod interface
    {
        /*!
        Provides the main interface to interactive input reader */
        use ::
        {
            borrow::{ Cow },
            fs::{ File, OpenOptions },
            io::{ self, BufRead, BufReader, BufWriter, Read as _, Seek, SeekFrom, Write as _ },
            path::{ Path },
            sync::{ Arc, Mutex, MutexGuard },
            system::
            {
                command::{ Command },
                complete::{ Completer },
                function::{ Function },
                input::{ Directive },
                reader::{ Read, Reader, ReadLock, ReadResult },
                terminal::{ DefaultTerminal, Terminal },
                variables::{ Variable },
                writer::{ Write, Writer, WriteLock },
            },
            time::std::{ Duration },
            *,
        };
        /*
        */
        /// The main interface to input reading and other terminal operations.
        pub struct Interface<Term: Terminal> 
        {
            term: Term,
            write: Mutex<Write>,
            read: Mutex<Read<Term>>,
        }

        impl Interface<DefaultTerminal> 
        {
            /// Creates a new `Interface` with the given application name.
            pub fn new<T>( application: T ) -> io::Result<Interface<DefaultTerminal>> where
            T: Into<Cow<'static, str>>
            {
                let term = DefaultTerminal::new()?;
                Interface::with_term( application, term )
            }
        }

        impl<Term: Terminal> Interface<Term>
        {
            /// Creates a new `Interface` instance with a particular terminal implementation.
            pub fn with_term<T>( application: T, term: Term ) -> io::Result<Interface<Term>> where
            T: Into<Cow<'static, str>>
            {
                let size = term.lock_write().size()?;
                let read = Read::new( &term, application.into() );

                Ok( Interface{
                    term: term,
                    write: Mutex::new( Write::new( size ) ),
                    read: Mutex::new( read ),
                } )
            }
            /// Acquires the read lock and returns a `Reader` instance.
            pub fn lock_reader( &self ) -> Reader<Term> 
            {
                Reader::new( self, self.lock_read() )
            }
            /// Acquires the write lock and returns a `Writer` instance.
            pub fn lock_writer_append( &self ) -> io::Result<Writer<Term>> 
            {
                Writer::with_lock( self.lock_write(), false )
            }
            /// Acquires the write lock and returns a `Writer` instance.
            pub fn lock_writer_erase( &self ) -> io::Result<Writer<Term>> 
            {
                Writer::with_lock( self.lock_write(), true )
            }

            fn lock_read( &self ) -> ReadLock<Term> 
            {
                ReadLock::new
                ( 
                    self.term.lock_read(),
                    self.read.lock().expect( "Interface::lock_read" )
                )
            }

            pub fn lock_write( &self ) -> WriteLock<Term>
            {
                WriteLock::new
                ( 
                    self.term.lock_write(),
                    self.write.lock().expect( "Interface::lock_write" )
                )
            }

            pub fn lock_write_data( &self ) -> MutexGuard<Write>
            { self.write.lock().expect( "Interface::lock_write_data" ) }
            /// Interactively reads a line from the terminal device.
            pub fn read_line( &self ) -> io::Result<ReadResult> { self.lock_reader().read_line() }
            /// Performs one step of the interactive `read_line` loop.
            pub fn read_line_step( &self, timeout: Option<Duration> ) -> io::Result<Option<ReadResult>>
            { self.lock_reader().read_line_step( timeout ) }
            /// Cancels an in-progress `read_line` operation.
            pub fn cancel_read_line( &self ) -> io::Result<()> { self.lock_reader().cancel_read_line() }
            /// Returns a clone of the current completer instance.
            pub fn completer( &self ) -> Arc<dyn Completer<Term>> { self.lock_reader().completer().clone() }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer( &self, completer: Arc<dyn Completer<Term>> ) -> Arc<dyn Completer<Term>>
            { self.lock_reader().set_completer( completer ) }
            /// Returns the value of the named variable or `None` if no such variable exists.
            pub fn get_variable( &self, name:&str ) -> Option<Variable> { self.lock_reader().get_variable( name ) }
            /// Sets the value of the named variable and returns the previous value.
            pub fn set_variable( &self, name:&str, value:&str ) -> Option<Variable>
            { self.lock_reader().set_variable( name, value ) }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal( &self, signal: system::terminal::Signal ) -> bool { self.lock_reader().ignore_signal( signal ) }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal( &self, signal: system::terminal::Signal, set: bool )
            { self.lock_reader().set_ignore_signal( signal, set ) }
            /// Returns whether the given `Signal` is reported.
            pub fn report_signal( &self, signal: system::terminal::Signal ) -> bool { self.lock_reader().report_signal( signal ) }
            /// Sets whether the given `Signal` is reported.
            pub fn set_report_signal( &self, signal: system::terminal::Signal, set: bool )
            { self.lock_reader().set_report_signal( signal, set ) }
            /// Binds a sequence to a command.
            pub fn bind_sequence<T>( &self, seq: T, cmd: Command ) -> Option<Command> where
            T: Into<Cow<'static, str>>
            { self.lock_reader().bind_sequence( seq, cmd ) }
            /// Binds a sequence to a command, if and only if the given sequence is not already bound to a command.
            pub fn bind_sequence_if_unbound<T>( &self, seq: T, cmd: Command ) -> bool where
            T: Into<Cow<'static, str>>
            { self.lock_reader().bind_sequence_if_unbound( seq, cmd ) }
            /// Removes a binding for the given sequence.
            pub fn unbind_sequence( &self, seq:&str ) -> Option<Command> { self.lock_reader().unbind_sequence( seq ) }
            /// Defines a named function to which sequences may be bound.
            pub fn define_function<T>( &self, t:T, c:Arc<dyn Function<Term>> ) -> Option<Arc<dyn Function<Term>>> where
            T: Into<Cow<'static, str>>
            { self.lock_reader().define_function( t, c ) }
            /// Removes a function defined with the given name.
            pub fn remove_function( &self, name:&str ) -> Option<Arc<dyn Function<Term>>>
            { self.lock_reader().remove_function( name ) }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives( &self, dirs: Vec<Directive> )
            { self.lock_reader().evaluate_directives( &self.term, dirs ) }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive( &self, d:Directive  ) { self.lock_reader().evaluate_directive( &self.term, d ) }
            /// Returns the current input buffer.
            pub fn buffer( &self ) -> String { self.lock_write().buffer.to_owned() }
            /// Returns the current number of history entries.
            pub fn history_len( &self ) -> usize { self.lock_write().history_len() }
            /// Returns the maximum number of history entries.
            pub fn history_size( &self ) -> usize { self.lock_write().history_size() }
            /// Save history entries to the specified file.
            pub fn save_history<P: AsRef<Path>>( &self, path: P ) -> io::Result<()>
            {
                let path = path.as_ref();
                let mut w = self.lock_write();

                if !path.exists() || w.history_size() == !0
                {
                    self.append_history( path, &w )?;
                }

                else
                {
                    self.rewrite_history( path, &w )?;
                }

                w.reset_new_history();
                Ok( () )
            }

            fn append_history<P: AsRef<Path>>( &self, path: P, w:&WriteLock<Term> ) -> io::Result<()>
            {
                let file = OpenOptions::new()
                .append( true )
                .create( true )
                .open( path.as_ref() )?;

                self.append_history_to( &file, w )
            }

            fn append_history_to( &self, file:&File, w:&WriteLock<Term> ) -> io::Result<()>
            {
                let mut wtr = BufWriter::new( file );

                for entry in w.new_history() {
                    wtr.write_all( entry.as_bytes() )?;
                    wtr.write_all( b"\n" )?;
                }

                wtr.flush()
            }

            fn rewrite_history<P: AsRef<Path>>( &self, path: P, w:&WriteLock<Term> ) -> io::Result<()>
            {
                fn nth_line( s:&str, n: usize ) -> Option<usize> {
                    let start = s.as_ptr() as usize;

                    s.lines().nth( n )
                        .map( |s| s.as_ptr() as usize - start )
                }

                let mut file = OpenOptions::new()
                    .create( true )
                    .read( true )
                    .write( true )
                    .open( path.as_ref() )?;

                let mut hist = String::new();

                file.read_to_string( &mut hist )?;

                let n_lines = hist.lines().count();
                let n = n_lines.saturating_sub( 
                    w.history_size() - w.new_history_entries() );

                if n != 0 {
                    if let Some( pos ) = nth_line( &hist, n ) {
                        file.seek( SeekFrom::Start( 0 ) )?;
                        file.write_all( hist[pos..].as_bytes() )?;

                        let n = file.seek( SeekFrom::Current( 0 ) )?;
                        file.set_len( n )?;
                    }
                }

                self.append_history_to( &file, w )
            }
            /// Load history entries from the specified file.
            pub fn load_history<P: AsRef<Path>>( &self, path: P ) -> io::Result<()>
            {
                let mut writer = self.lock_write();

                let file = File::open( &path )?;
                let rdr = BufReader::new( file );

                for line in rdr.lines() {
                    writer.add_history( line? );
                }

                writer.reset_new_history();

                Ok( () )
            }
            /// Writes formatted text to the terminal display.
            pub fn write_fmt( &self, args: fmt::Arguments ) -> io::Result<()>
            {
                let s = args.to_string();
                self.write_str( &s )
            }

            fn write_str( &self, line:&str ) -> io::Result<()> { self.lock_writer_erase()?.write_str( line ) }
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt( &self, prompt:&str ) -> io::Result<()>
            { self.lock_reader().set_prompt( prompt ) }
            /// Sets the input buffer to the given string.
            pub fn set_buffer( &self, buf:&str ) -> io::Result<()> { self.lock_reader().set_buffer( buf ) }
            /// Sets the cursor position in the input buffer.
            pub fn set_cursor( &self, pos: usize ) -> io::Result<()> { self.lock_reader().set_cursor( pos ) }
            /// Adds a line to history.
            pub fn add_history( &self, line: String ) { self.lock_reader().add_history( line ); }
            /// Adds a line to history, unless it is identical to the most recent entry.
            pub fn add_history_unique( &self, line: String ) { self.lock_reader().add_history_unique( line ); }
            /// Removes all history entries.
            pub fn clear_history( &self  ) { self.lock_reader().clear_history(); }
            /// Removes the history entry at the given index.
            pub fn remove_history( &self, idx: usize ) { self.lock_reader().remove_history( idx ); }
            /// Sets the maximum number of history entries.
            pub fn set_history_size( &self, n: usize ) { self.lock_reader().set_history_size( n ); }
            /// Truncates history to the only the most recent `n` entries.
            pub fn truncate_history( &self, n: usize ) { self.lock_reader().truncate_history( n ); }
        }
    }

    pub mod memory
    {
        /*!
        Implements an in-memory `Terminal` interface */
        use ::
        {
            cmp::{ min },
            iter::{ repeat },
            sync::{ Arc, Mutex, MutexGuard },
            system::
            {
                terminal::{ CursorMode, RawRead, SignalSet, Size, Terminal, TerminalReader, TerminalWriter },
            },
            time::std::{ Duration },
            *,
        };
        /*
        *//// Default size of a `MemoryTerminal` buffer
        pub const DEFAULT_SIZE: Size = Size
        {
            columns: 80,
            lines: 24,
        };
        /// Implements an in-memory `Terminal` interface.
        #[derive( Clone, Debug )]
        pub struct MemoryTerminal 
        {
            write: Arc<Mutex<Writer>>,
            read: Arc<Mutex<Reader>>,
        }

        #[derive( Debug )]
        struct Writer 
        {
            memory: Vec<char>,
            input: Vec<u8>,
            col: usize,
            line: usize,
            cursor_mode: CursorMode,
            size: Size,
        }

        #[derive( Debug )]
        struct Reader 
        {
            input: Vec<u8>,
            resize: Option<Size>,
        }
        /// Holds the lock on read operations of a `MemoryTerminal`.
        pub struct MemoryReadGuard<'a>( MutexGuard<'a, Reader> );
        /// Holds the lock on write operations of a `MemoryTerminal`.
        pub struct MemoryWriteGuard<'a>( MutexGuard<'a, Writer> );

        impl MemoryTerminal
        {
            /// Returns a new `MemoryTerminal` with the default buffer size.
            pub fn new() -> MemoryTerminal { MemoryTerminal::default() }
            /// Returns a new `MemoryTerminal` with the given buffer size.
            pub fn with_size( size: Size ) -> MemoryTerminal
            {
                MemoryTerminal
                {
                    read: Arc::new( Mutex::new( Reader::new() ) ),
                    write: Arc::new( Mutex::new( Writer::new( size ) ) ),
                }
            }
            /// Clears the terminal buffer and places the cursor at `( 0, 0 )`.
            pub fn clear_all( &self  ) { self.lock_writer().clear_all(); }
            /// Clears all characters beginning at the cursor and ending at buffer end.
            pub fn clear_to_end( &self  ) { self.lock_writer().clear_to_end(); }
            /// Clears the input buffer.
            pub fn clear_input( &self  ) { self.lock_reader().clear_input(); }
            /// Returns whether any input remains to be read.
            pub fn has_input( &self ) -> bool { self.lock_reader().has_input() }
            /// Returns an iterator over lines in the buffer.
            pub fn lines( &self ) -> Lines 
            {
                Lines
                {
                    writer: self.lock_writer(),
                    line: 0,
                }
            }
            /// Moves the cursor up `n` cells.
            pub fn move_up( &self, n: usize ) { self.lock_writer().move_up( n ); }
            /// Moves the cursor down `n` cells.
            pub fn move_down( &self, n: usize ) { self.lock_writer().move_down( n ); }
            /// Moves the cursor left `n` cells.
            pub fn move_left( &self, n: usize ) { self.lock_writer().move_left( n ); }
            /// Moves the cursor right `n` cells.
            pub fn move_right( &self, n: usize ) { self.lock_writer().move_right( n ); }
            /// Moves the cursor to the first column of the current line.
            pub fn move_to_first_column( &self  ) { self.lock_writer().move_to_first_column() }
            /// Pushes a character sequence to the back of the input queue.
            pub fn push_input( &self, s:&str ) { self.lock_reader().push_input( s.as_bytes() ); }
            /// Reads some input from the input buffer.
            pub fn read_input( &self, buf:&mut [u8] ) -> usize { self.lock_reader().read_input( buf ) }
            /// Changes the size of the terminal buffer.
            pub fn resize( &self, new_size: Size ) 
            {
                self.lock_writer().resize( new_size );
                self.lock_reader().resize( new_size );
            }
            /// Moves the contents of the buffer up `n` lines.
            pub fn scroll_up( &self, n: usize ) { self.lock_writer().scroll_up( n ); }
            /// Returns the `( line, column )` position of the cursor.
            pub fn cursor( &self ) -> ( usize, usize ) 
            {
                let r = self.lock_writer();
                ( r.line, r.col )
            }
            /// Sets the cursor mode.
            pub fn set_cursor_mode( &self, mode: CursorMode ) { self.lock_writer().set_cursor_mode( mode ); }
            /// Returns the cursor mode.
            pub fn cursor_mode( &self ) -> CursorMode { self.lock_writer().cursor_mode() }
            /// Returns the size of the terminal buffer.
            pub fn size( &self ) -> Size { self.lock_writer().size }
            /// Writes some text into the buffer.
            pub fn write( &self, s:&str ) { self.lock_writer().write( s ); }

            fn lock_reader( &self ) -> MutexGuard<Reader> { self.read.lock().unwrap() }

            fn lock_writer( &self ) -> MutexGuard<Writer> { self.write.lock().unwrap() }
        }

        impl Default for MemoryTerminal
        {
            fn default() -> MemoryTerminal
            {
                MemoryTerminal::with_size( DEFAULT_SIZE )
            }
        }

        impl Reader
        {
            fn new() -> Reader
            {
                Reader
                {
                    input: Vec::new(),
                    resize: None,
                }
            }

            fn has_input( &mut self ) -> bool { self.resize.is_some() || !self.input.is_empty() }

            fn clear_input( &mut self ) { self.input.clear(); }

            fn push_input( &mut self, bytes:&[u8] ) { self.input.extend( bytes ); }

            fn read_input( &mut self, buf:&mut [u8] ) -> usize {
                let n = min( buf.len(), self.input.len() );

                buf[..n].copy_from_slice( &self.input[..n] );
                let _ = self.input.drain( ..n );
                n
            }

            fn resize( &mut self, size: Size ) { self.resize = Some( size ); }
        }

        impl Writer 
        {
            fn new( size: Size ) -> Writer {
                assert!( size.lines != 0 && size.columns != 0,
                    "zero-area terminal buffer: {:?}", size );

                let n_chars = size.lines * size.columns;

                Writer{
                    memory: vec![' '; n_chars],
                    input: Vec::new(),
                    col: 0,
                    line: 0,
                    cursor_mode: CursorMode::Normal,
                    size: size,
                }
            }

            fn clear_all( &mut self ) {
                for ch in &mut self.memory {
                    *ch = ' ';
                }
                self.col = 0;
                self.line = 0;
            }

            fn clear_to_end( &mut self ) {
                let idx = self.index();

                for ch in &mut self.memory[idx..] {
                    *ch = ' ';
                }
            }

            fn move_up( &mut self, n: usize ) {
                self.line = self.line.saturating_sub( n );
            }

            fn move_down( &mut self, n: usize ) {
                self.line = min( self.size.lines - 1, self.line + n );
            }

            fn move_left( &mut self, n: usize ) {
                self.col = self.col.saturating_sub( n );
            }

            fn move_right( &mut self, n: usize ) {
                self.col = min( self.size.columns - 1, self.col + n );
            }

            fn move_to_first_column( &mut self ) {
                self.col = 0;
            }

            fn resize( &mut self, new_size: Size ) {
                if self.size != new_size {
                    let n_chars = new_size.lines.checked_mul( new_size.columns )
                        .unwrap_or_else( || panic!( "terminal size too large: {:?}", new_size ) );

                    assert!( n_chars != 0, "zero-area terminal buffer: {:?}", new_size );

                    let mut new_buf = Vec::with_capacity( n_chars );

                    let ( n_copy, n_extra ) = if new_size.columns > self.size.columns {
                        ( self.size.columns, new_size.columns - self.size.columns )
                    } else {
                        ( new_size.columns, 0 )
                    };

                    for line in self.memory.chunks( self.size.columns ).take( new_size.lines ) {
                        new_buf.extend( &line[..n_copy] );
                        new_buf.extend( repeat( ' ' ).take( n_extra ) );
                    }

                    if new_size.lines > self.size.lines {
                        let n_lines = new_size.lines - self.size.lines;
                        new_buf.extend( repeat( ' ' ).take( n_lines * new_size.columns ) );
                    }

                    debug_assert_eq!( new_buf.len(), n_chars );

                    self.col = min( self.col, new_size.columns );
                    self.line = min( self.line, new_size.lines );
                    self.size = new_size;
                    self.memory = new_buf;
                }
            }

            fn scroll_up( &mut self, n: usize ) {
                let chars = min( self.memory.len(), self.size.columns * n );
                self.memory.drain( ..chars );
                self.memory.extend( repeat( ' ' ).take( chars ) );
                self.line = self.line.saturating_sub( n );
            }

            fn set_cursor_mode( &mut self, mode: CursorMode ) {
                self.cursor_mode = mode;
            }

            fn cursor_mode( &self ) -> CursorMode {
                self.cursor_mode
            }

            fn write( &mut self, s:&str ) {
                for ch in s.chars() {
                    if ch == '\n' {
                        self.advance_line();
                    } else if ch == '\r' {
                        self.col = 0;
                    } else {
                        self.write_char( ch );
                    }
                }
            }

            fn advance_line( &mut self ) {
                self.line += 1;
                self.col = 0;
                if self.line == self.size.lines {
                    self.scroll_up( 1 );
                }
            }

            fn write_char( &mut self, ch:char ) {
                if self.col >= self.size.columns {
                    self.advance_line();
                }

                let idx = self.index();
                self.memory[idx] = ch;
                self.col += 1;
            }

            fn index( &self ) -> usize {
                self.line * self.size.columns + self.col
            }
        }
        /// Iterator over lines in a `MemoryTerminal` buffer.
        pub struct Lines<'a>
        {
            writer: MutexGuard<'a, Writer>,
            line: usize,
        }

        impl<'a> Lines<'a>
        {
            /// Returns the next line in the buffer.
            pub fn next( &mut self ) -> Option<&[char]> {
                if self.line >= self.writer.size.lines {
                    None
                } else {
                    let start = self.writer.size.columns * self.line;
                    self.line += 1;
                    let end = self.writer.size.columns * self.line;

                    Some( &self.writer.memory[start..end] )
                }
            }
            /// Returns the number of lines remaining in the iterator.
            pub fn lines_remaining( &self ) -> usize {
                self.writer.size.lines - self.line
            }
        }

        impl Terminal for MemoryTerminal
        {
            type PrepareState = ();
            //type Reader = MemoryReadGuard;
            //type Writer = MemoryWriteGuard;

            fn name( &self ) -> &str { "memory-terminal" }

            fn lock_read<'a>( &'a self ) -> Box<dyn TerminalReader<Self> + 'a> 
            {
                Box::new( MemoryReadGuard( self.lock_reader() ) )
            }

            fn lock_write<'a>( &'a self ) -> Box<dyn TerminalWriter<Self> + 'a> 
            {
                Box::new( MemoryWriteGuard( self.lock_writer() ) )
            }
        }

        impl<'a> TerminalReader<MemoryTerminal> for MemoryReadGuard<'a>
        {
            fn wait_for_input( &mut self, _timeout: Option<Duration> ) -> io::Result<bool> {
                Ok( !self.0.input.is_empty() )
            }

            fn prepare( &mut self, _block_signals: bool, _report_signals: SignalSet )
                    -> io::Result<()> { Ok( () ) }

            unsafe fn prepare_with_lock( &mut self,
                    _lock:&mut dyn TerminalWriter<MemoryTerminal>,
                    _block_signals: bool, _report_signals: SignalSet )
                    -> io::Result<()> { Ok( () ) }

            fn restore( &mut self, _state: () ) -> io::Result<()> { Ok( () ) }

            unsafe fn restore_with_lock( &mut self,
                    _lock:&mut dyn TerminalWriter<MemoryTerminal>, _state: () )
                    -> io::Result<()> { Ok( () ) }

            fn read( &mut self, buf:&mut Vec<u8> ) -> io::Result<Option<RawRead>>
            {
                Ok( None )
                /*
                if let Some( size ) = self.0.resize.take() {
                    return Ok( RawRead::Resize( size ) );
                }

                buf.reserve( 16 );

                let cap = buf.capacity();
                let len = buf.len();
                let n;

                unsafe {
                    buf.set_len( cap );
                    n = self.0.read_input( &mut buf[len..] );
                    buf.set_len( len + n );
                }

                Ok( RawRead::Bytes( n ) ) */
            }
        }

        impl<'a> TerminalWriter<MemoryTerminal> for MemoryWriteGuard<'a>
        {
            fn size( &self ) -> io::Result<Size> {
                Ok( self.0.size )
            }

            fn clear_screen( &mut self ) -> io::Result<()> {
                self.0.clear_all();
                Ok( () )
            }

            fn clear_to_screen_end( &mut self ) -> io::Result<()> {
                self.0.clear_to_end();
                Ok( () )
            }

            fn move_up( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_up( n );
                Ok( () )
            }

            fn move_down( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_down( n );
                Ok( () )
            }

            fn move_left( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_left( n );
                Ok( () )
            }

            fn move_right( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_right( n );
                Ok( () )
            }

            fn move_to_first_column( &mut self ) -> io::Result<()> {
                self.0.move_to_first_column();
                Ok( () )
            }

            fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> {
                self.0.set_cursor_mode( mode );
                Ok( () )
            }

            fn write( &mut self, s:&str ) -> io::Result<()> {
                self.0.write( s );
                Ok( () )
            }

            fn flush( &mut self ) -> io::Result<()> { Ok( () ) }
        }
    }

    pub mod prompter
    {
        /*!
        Provides access to prompt input state. */
        use ::
        {
            char::{is_ctrl, is_printable, DELETE, EOF},
            mem::replace,
            ops::Range,
            sync::Arc,
            system::
            {
                command::{Category, Command},
                complete::{ Completion },
                function::{ Function },
                reader::{BindingIter, InputState, ReadLock, ReadResult},
                table::{format_columns, Line, Table},
                terminal::{CursorMode, Signal, Size, Terminal},
                variables::{ VariableIter },
                writer::
                {
                    BLINK_DURATION, display_str,
                    Digit, Display, HistoryIter, PromptType, Writer, WriteLock,
                },
            },
            time::Instant,
            *,
        };
        /*
        */
        /// Provides access to the current state of input while a `read_line` call is in progress.
        pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminal> {
            pub read:&'a mut ReadLock<'b, Term>,
            write: WriteLock<'b, Term>,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Prompter<'a, 'b, Term>
        {
            pub fn new( read:&'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term> )
                    -> Prompter<'a, 'b, Term> {
                Prompter{read, write}
            }
            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_append<'c>( &'c mut self ) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref( &mut self.write, false )
            }
            /// Returns a `Writer` instance using the currently held write lock.
            pub fn writer_erase<'c>( &'c mut self ) -> io::Result<Writer<'c, 'b, Term>> {
                Writer::with_ref( &mut self.write, true )
            }
            /// Resets input state at the start of `read_line`
            fn reset_input( &mut self ) {
                self.read.reset_data();
                self.write.reset_data();
            }

            pub fn start_read_line( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.is_prompt_drawn = true;
                self.write.update_size()?;
                self.write.draw_prompt()
            }

            pub fn end_read_line( &mut self ) -> io::Result<()> {
                self.write.expire_blink()?;

                if self.read.overwrite_mode {
                    self.write.set_cursor_mode( CursorMode::Normal )?;
                }
                if self.write.is_prompt_drawn {
                    self.write.move_to_end()?;
                    self.write.write_str( "\n" )?;
                    self.write.is_prompt_drawn = false;
                }

                self.reset_input();
                self.read.state = InputState::Inactive;

                Ok( () )
            }

            pub fn handle_input( &mut self, ch:char ) -> io::Result<Option<ReadResult>> {
                self.write.expire_blink()?;

                match self.read.state {
                    InputState::Inactive => panic!( "input received in inactive state" ),
                    InputState::NewSequence => {
                        if ch == EOF && self.write.buffer.is_empty() {
                            self.write.write_str( "\n" )?;
                            self.write.is_prompt_drawn = false;
                            return Ok( Some( ReadResult::Eof ) );
                        } else {
                            self.read.sequence.push( ch );
                            self.execute_sequence()?;

                            if self.read.input_accepted {
                                let s = replace( &mut self.write.buffer, String::new() );
                                return Ok( Some( ReadResult::Input( s ) ) );
                            }
                        }
                    }
                    InputState::ContinueSequence{expiry: _} => {
                        self.read.sequence.push( ch );

                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace( &mut self.write.buffer, String::new() );
                            return Ok( Some( ReadResult::Input( s ) ) );
                        }
                    }
                    InputState::Number => {
                        if let Some( digit ) = ch.to_digit( 10 ) {
                            self.write.input_arg.input( digit as i32 );

                            if self.write.input_arg.is_out_of_bounds() {
                                self.read.state = InputState::NewSequence;
                                self.write.input_arg = Digit::None;
                                self.write.explicit_arg = false;
                                self.write.redraw_prompt( PromptType::Normal )?;
                            } else {
                                self.write.redraw_prompt( PromptType::Number )?;
                            }
                        } else {
                            self.read.state = InputState::NewSequence;
                            self.write.redraw_prompt( PromptType::Normal )?;
                            self.read.macro_buffer.insert( 0, ch );
                        }
                    }
                    InputState::CharSearch{n, backward} => {
                        if n != 0 {
                            if backward {
                                self.write.backward_search_char( n, ch )?;
                            } else {
                                self.write.forward_search_char( n, ch )?;
                            }
                        }
                        self.read.state = InputState::NewSequence;
                    }
                    InputState::TextSearch => {
                        if ch == DELETE {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.pop();
                                write.last_search.clone_from( &write.search_buffer );
                            }
                            self.write.search_history_update()?;
                        }
                        /*
                        else if self.is_abort( ch ) {
                            self.abort_search_history()?;
                        } */
                        
                        else if is::control( ch ) {
                            self.end_search_history()?;
                            self.read.macro_buffer.insert( 0, ch );
                        } else {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.push( ch );
                                write.last_search.clone_from( &write.search_buffer );
                            }
                            self.write.search_history_update()?;
                        }
                    }
                    InputState::CompleteIntro => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.write_str( "\n" )?;
                                self.show_completions_page( 0 )?;
                            }
                            '\r' | '\n' => {
                                self.write.write_str( "\n" )?;
                                self.show_completions_line( 0 )?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.write_str( "\n" )?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::CompleteMore( offset ) => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.clear_prompt()?;
                                self.show_completions_page( offset )?;
                            }
                            '\r' | '\n' => {
                                self.write.clear_prompt()?;
                                self.show_completions_line( offset )?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.clear_prompt()?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::QuotedInsert( n ) => {
                        if n != 0 {
                            self.insert( n, ch )?;
                        }
                        self.read.state = InputState::NewSequence;
                    }
                }

                Ok( None )
            }
            /// Returns the current buffer.
            pub fn buffer( &self ) -> &str {
                &self.write.buffer
            }
            /// Returns the "backup" buffer.
            pub fn backup_buffer( &self ) -> &str {
                &self.write.backup_buffer
            }
            /// Returns the command `Category` of the most recently executed command.
            pub fn last_command_category( &self ) -> Category {
                self.read.last_cmd
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars( &self ) -> &str {
                &self.read.word_break
            }
            /// Sets the buffer to the given value.
            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> {
                self.write.set_buffer( buf )
            }
            /// Returns the current position of the cursor.
            pub fn cursor( &self ) -> usize {
                self.write.cursor
            }
            /// Sets the cursor to the given position within the buffer.
            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> {
                self.write.set_cursor( pos )
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> {
                self.write.set_prompt( prompt )
            }
            /// Returns the size of the terminal at the last draw operation.
            pub fn screen_size( &self ) -> Size {
                self.write.screen_size
            }
            /// Returns whether a numerical argument was explicitly supplied by the user.
            pub fn explicit_arg( &self ) -> bool {
                self.write.explicit_arg
            }
            /// Returns the current input sequence.
            pub fn sequence( &self ) -> &str {
                &self.read.sequence
            }
            /// Returns an iterator over bound sequences
            /*pub fn bindings( &self ) -> BindingIter {
                self.read.bindings()
            }*/
            /// Returns an iterator over variable values.
            pub fn variables( &self ) -> VariableIter {
                self.read.variables()
            }
            /// Returns an iterator over history entries
            pub fn history( &self ) -> HistoryIter {
                self.write.history()
            }
            /// Returns the index into history currently being edited.
            pub fn history_index( &self ) -> Option<usize> {
                self.write.history_index
            }
            /// Returns the current number of history entries.
            pub fn history_len( &self ) -> usize {
                self.write.history.len()
            }

            fn next_history( &mut self, n: usize ) -> io::Result<()> {
                self.write.next_history( n )
            }

            fn prev_history( &mut self, n: usize ) -> io::Result<()> {
                self.write.prev_history( n )
            }
            /// Selects the history entry currently being edited by the user.
            pub fn select_history_entry( &mut self, new: Option<usize> ) -> io::Result<()> {
                self.write.select_history_entry( new )
            }
            /// Returns the current set of completions.
            pub fn completions( &self ) -> Option<&[Completion]> {
                self.read.completions.as_ref().map( |v| &v[..] )
            }
            /// Sets the current set of completions.
            pub fn set_completions( &mut self, completions: Option<Vec<Completion>> ) {
                self.read.completions = completions;
            }
            /// Attempts to execute the current sequence.
            fn execute_sequence( &mut self ) -> io::Result<()>
            {
                /*
                match self.find_binding( &self.read.sequence ) {
                    FindResult::Found( cmd ) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.read.state = InputState::NewSequence;
                        self.execute_command( cmd, n, ch )?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.read.state = InputState::NewSequence;
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => {
                        let expiry = None;
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                    FindResult::Undecided( _ ) => {
                        let expiry = self.keyseq_expiry();
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                } */

                Ok( () )
            }

            fn force_execute_sequence( &mut self ) -> io::Result<()>
            {
                /*
                self.read.state = InputState::NewSequence;

                match self.find_binding( &self.read.sequence ) {
                    FindResult::Found( cmd ) |
                    FindResult::Undecided( cmd ) => {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.execute_command( cmd, n, ch )?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete => unreachable!(),
                } */

                Ok( () )
            }
            /// Execute the command `SelfInsert` on the first character in the input sequence, if it is printable.
            fn insert_first_char( &mut self ) -> io::Result<()> {
                let ( first, rest ) = {
                    let mut chars = self.read.sequence.chars();

                    ( chars.next().unwrap(), chars.as_str().to_owned() )
                };

                self.read.sequence.clear();

                if is_printable( first ) {
                    let n = self.write.input_arg.to_i32();
                    self.execute_command( Command::SelfInsert, n, first )?;
                }

                if !rest.is_empty() {
                    self.read.queue_input( &rest );
                }

                Ok( () )
            }
            /*
            fn find_binding( &self, seq:&str ) -> FindResult<Command> {
                self.read.bindings.find( seq ).cloned()
            } */

            fn get_function( &self, name:&str ) -> Option<&Arc<dyn Function<Term>>> {
                self.read.functions.get( name )
            }
            /*
            fn is_abort( &self, ch:char ) -> bool {
                let mut buf = [0; 4];
                let s = ch.encode_utf8( &mut buf );

                self.find_binding( &s ) == FindResult::Found( Command::Abort )
            } */
            fn execute_command( &mut self, cmd: Command, n: i32, ch:char ) -> io::Result<()> 
            {
                use system::command::Command::*;

                let mut category = cmd.category();

                if self.read.overwrite_mode {
                    match cmd {
                        DigitArgument | SelfInsert => (),
                        BackwardDeleteChar if n >= 0 => (),
                        _ => self.read.overwritten_chars.clear()
                    }
                }

                match cmd {
                    Abort => (),
                    AcceptLine => {
                        self.accept_input()?;
                    }
                    Complete => {
                        if !self.read.disable_completion {
                            self.complete_word()?;
                        } else if is_printable( ch ) {
                            self.execute_command( SelfInsert, n, ch )?;
                        }
                    }
                    InsertCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some( completions ) = self.read.completions.take() {
                            self.insert_completions( &completions )?;
                            self.read.completions = Some( completions );
                        }
                    }
                    PossibleCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some( completions ) = self.read.completions.take() {
                            self.show_completions( &completions )?;
                            self.read.completions = Some( completions );
                        }
                    }
                    MenuComplete => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.next_completion( n as usize )?;
                        } else {
                            self.prev_completion( ( -n ) as usize )?;
                        }
                    }
                    MenuCompleteBackward => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.prev_completion( n as usize )?;
                        } else {
                            self.next_completion( ( -n ) as usize )?;
                        }
                    }
                    DigitArgument => {
                        self.read.state = InputState::Number;
                        self.write.set_digit_from_char( ch );
                        self.write.redraw_prompt( PromptType::Number )?;
                    }
                    SelfInsert => {
                        if n > 0 {
                            let n = n as usize;

                            if self.read.overwrite_mode {
                                self.overwrite( n, ch )?;
                            } else {
                                self.insert( n, ch )?;
                            }

                            if self.read.blink_matching_paren {
                                if let Some( open ) = get::open_parenthesis( ch ) {
                                    if let Some( pos ) = regex::find_matching_parenthesis( 
                                            &self.write.buffer[..self.write.cursor],
                                            &self.read.string_chars, open, ch ) {
                                        self.blink( pos )?;
                                    }
                                }
                            }
                        }
                    }
                    TabInsert => {
                        if n > 0 {
                            self.insert( n as usize, '\t' )?;
                        }
                    }
                    InsertComment => {
                        if self.explicit_arg() &&
                                self.write.buffer.starts_with( &self.read.comment_begin[..] ) {
                            self.write.move_to( 0 )?;
                            let n = self.read.comment_begin.len();

                            self.delete_range( ..n )?;
                            self.accept_input()?;
                        } else {
                            self.write.move_to( 0 )?;
                            let s = self.read.comment_begin.clone();
                            self.insert_str( &s )?;
                            self.accept_input()?;
                        }
                    }
                    BackwardChar => {
                        if n > 0 {
                            self.write.backward_char( n as usize )?;
                        } else if n < 0 {
                            self.write.forward_char( ( -n ) as usize )?;
                        }
                    }
                    ForwardChar => {
                        if n > 0 {
                            self.write.forward_char( n as usize )?;
                        } else if n < 0 {
                            self.write.backward_char( ( -n ) as usize )?;
                        }
                    }
                    CharacterSearch => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: false,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: ( -n ) as usize,
                                backward: true,
                            };
                        }
                    }
                    CharacterSearchBackward => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: true,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: ( -n ) as usize,
                                backward: false,
                            };
                        }
                    }
                    BackwardWord => {
                        if n > 0 {
                            self.backward_word( n as usize )?;
                        } else if n < 0 {
                            self.forward_word( ( -n ) as usize )?;
                        }
                    }
                    ForwardWord => {
                        if n > 0 {
                            let pos = regex::forward_word( n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            self.write.move_to( pos )?;
                        } else if n < 0 {
                            let pos = regex::forward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            self.write.move_to( pos )?;
                        }
                    }
                    BackwardKillLine => {
                        let r = ..self.write.cursor;
                        self.kill_range( r )?;
                    }
                    KillLine => {
                        let r = self.write.cursor..;
                        self.kill_range( r )?;
                    }
                    BackwardKillWord => {
                        if n > 0 {
                            let pos = regex::backward_word( n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        } else if n < 0 {
                            let pos = regex::forward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        }
                    }
                    KillWord => {
                        if n > 0 {
                            let pos = regex::forward_word( n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        } else if n < 0 {
                            let pos = regex::backward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        }
                    }
                    UnixWordRubout => {
                        if n > 0 {
                            let pos = regex::backward_word( n as usize,
                                &self.write.buffer, self.write.cursor, " \t\n" );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        } else if n < 0 {
                            let pos = regex::forward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, " \t\n" );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        }
                    }
                    ClearScreen => {
                        self.write.clear_screen()?;
                    }
                    BeginningOfLine => self.write.move_to( 0 )?,
                    EndOfLine => self.write.move_to_end()?,
                    BackwardDeleteChar => {
                        if n > 0 {
                            if self.read.overwrite_mode {
                                self.overwrite_back( n as usize )?;
                            } else {
                                let pos = char::backward( n as usize,
                                    &self.write.buffer, self.write.cursor );
                                let r = pos..self.write.cursor;
                                self.delete_range( r )?;
                            }
                        } else if n < 0 {
                            let pos = char::forward( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor );
                            let r = self.write.cursor..pos;
                            self.delete_range( r )?;
                        }
                    }
                    DeleteChar => {
                        if n > 0 {
                            let pos = char::forward( n as usize,
                                &self.write.buffer, self.write.cursor );
                            let r = self.write.cursor..pos;
                            self.delete_range( r )?;
                        } else if n < 0 {
                            let pos = char::backward( n as usize,
                                &self.write.buffer, self.write.cursor );
                            let r = pos..self.write.cursor;
                            self.delete_range( r )?;
                        }
                    }
                    TransposeChars => {
                        if n != 0 && self.write.cursor != 0 {
                            let ( src, dest );

                            if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                                let end = char::backward( 1, &self.write.buffer, self.write.cursor );
                                let start = char::backward( 1, &self.write.buffer, end );

                                src = start..end;
                                dest = end..self.write.cursor;
                            } else {
                                let start = char::backward( 1, &self.write.buffer, self.write.cursor );
                                let end = self.write.cursor;

                                src = start..end;

                                dest = if n < 0 {
                                    let back = char::backward( ( -n ) as usize, &self.write.buffer, start );
                                    back..start
                                } else {
                                    let fwd = char::forward( n as usize + 1, &self.write.buffer, start );
                                    end..fwd
                                };
                            }

                            self.transpose_range( src, dest )?;
                        }
                    }
                    TransposeWords => {
                        if n != 0 {
                            if let Some( first ) = regex::first_word( &self.write.buffer[..self.write.cursor], &self.read.word_break ) {
                                let start = regex::word_start( &self.write.buffer, self.write.cursor, &self.read.word_break );

                                if first != start {
                                    let ( src, dest );

                                    if !self.explicit_arg() && start == self.write.buffer.len() {
                                        let dest_start = regex::backward_word( 1, &self.write.buffer, start, &self.read.word_break );
                                        let dest_end = regex::word_end( &self.write.buffer, dest_start, &self.read.word_break );

                                        let src_start = regex::backward_word( 1, &self.write.buffer, dest_start, &self.read.word_break );
                                        let src_end = regex::word_end( &self.write.buffer, src_start, &self.read.word_break );

                                        src = src_start..src_end;
                                        dest = dest_start..dest_end;
                                    } else {
                                        let src_start = regex::backward_word( 1, &self.write.buffer, start, &self.read.word_break );
                                        let src_end = regex::word_end( &self.write.buffer, src_start, &self.read.word_break );

                                        src = src_start..src_end;

                                        dest = if n < 0 {
                                            regex::back_n_words( ( -n ) as usize, &self.write.buffer, src_start, &self.read.word_break )
                                        } else {
                                            regex::forward_n_words( n as usize, &self.write.buffer, src_start, &self.read.word_break )
                                        };
                                    }

                                    self.transpose_range( src, dest )?;
                                }
                            }
                        }
                    }
                    BeginningOfHistory => {
                        self.select_history_entry( Some( 0 ) )?;
                    }
                    EndOfHistory => {
                        self.select_history_entry( None )?;
                    }
                    NextHistory => {
                        if n > 0 {
                            self.next_history( n as usize )?;
                        } else if n < 0 {
                            self.prev_history( ( -n ) as usize )?;
                        }
                    }
                    PreviousHistory => {
                        if n > 0 {
                            self.prev_history( n as usize )?;
                        } else if n < 0 {
                            self.next_history( ( -n ) as usize )?;
                        }
                    }
                    ForwardSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history( false )?;
                        } else {
                            self.write.start_search_history( false )?;
                        }
                    }
                    ReverseSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history( true )?;
                        } else {
                            self.write.start_search_history( true )?;
                        }
                    }
                    HistorySearchForward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search( false )?;
                        } else {
                            self.write.start_history_search( false )?;
                        }
                    }
                    HistorySearchBackward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search( true )?;
                        } else {
                            self.write.start_history_search( true )?;
                        }
                    }
                    QuotedInsert => {
                        self.read.state = InputState::QuotedInsert( 
                            if n >= 0 { n as usize } else { 0 } );
                    }
                    OverwriteMode => {
                        self.read.overwrite_mode = !self.read.overwrite_mode;

                        if !self.read.overwrite_mode {
                            self.read.overwritten_append = 0;
                            self.read.overwritten_chars.clear();
                        }

                        let mode = if self.read.overwrite_mode {
                            CursorMode::Overwrite
                        } else {
                            CursorMode::Normal
                        };

                        self.write.set_cursor_mode( mode )?;
                    }
                    Yank => {
                        self.yank()?;
                    }
                    YankPop => {
                        self.yank_pop()?;
                    }
                    Custom( ref name ) => {
                        if let Some( fun ) = self.get_function( name ).cloned() {
                            fun.execute( self, n, ch )?;

                            category = fun.category();
                        }
                    }
                    Macro( ref seq ) => {
                        self.read.queue_input( seq );
                    }
                }

                if category != Category::Digit {
                    self.write.input_arg = Digit::None;
                    self.write.explicit_arg = false;

                    self.read.last_cmd = category;

                    if category != Category::Complete {
                        self.read.completions = None;
                    }

                    if category != Category::Yank {
                        self.read.last_yank = None;
                    }
                }

                Ok( () )
            }
            /// Accepts the current input buffer as user input.
            pub fn accept_input( &mut self ) -> io::Result<()> {
                self.write.move_to_end()?;
                self.write.write_str( "\n" )?;
                self.read.input_accepted = true;
                self.write.is_prompt_drawn = false;
                Ok( () )
            }
            /// Moves cursor to the position, waits for 500ms, user input, then restores the original cursor position.
            pub fn blink( &mut self, pos: usize ) -> io::Result<()> {
                self.write.blink( pos )?;

                self.read.max_wait_duration = Some( BLINK_DURATION );

                Ok( () )
            }

            fn check_expire_blink( &mut self, now: Instant ) -> io::Result<()>
            {
                /*if self.write.check_expire_blink( now )? {
                    self.read.max_wait_duration = None;
                }*/

                Ok( () )
            }

            fn check_expire_sequence( &mut self, now: Instant ) -> io::Result<()> {
                if let InputState::ContinueSequence{expiry: Some( expiry )} = self.read.state {
                    if now >= expiry {
                        self.read.max_wait_duration = None;
                        self.force_execute_sequence()?;
                    }
                }

                Ok( () )
            }

            fn keyseq_expiry( &mut self ) -> Option<Instant> {
                if let Some( t ) = self.read.keyseq_timeout {
                    self.read.max_wait_duration = Some( t );
                    Some( Instant::now() + t )
                } else {
                    None
                }
            }

            pub fn check_expire_timeout( &mut self ) -> io::Result<()> {
                let now = Instant::now();

                self.check_expire_blink( now )?;
                self.check_expire_sequence( now )
            }

            fn expire_blink( &mut self ) -> io::Result<()> {
                self.read.max_wait_duration = None;
                self.write.expire_blink()
            }

            fn build_completions( &mut self ) {
                let compl = self.read.completer.clone();
                let end = self.write.cursor;
                let start = compl.word_start( &self.write.buffer, end, self );

                if start > end {
                    panic!( "Completer::word_start returned invalid index; \
                        start > end ( {} > {} )", start, end );
                }

                let unquoted = compl.unquote( &self.write.buffer[start..end] ).into_owned();

                let completions = compl.complete( &unquoted, self, start, end );
                let n_completions = completions.as_ref().map_or( 0, |c| c.len() );

                self.read.completions = completions;
                self.read.completion_index = n_completions;
                self.read.completion_start = start;
                self.read.completion_prefix = end;
            }

            fn complete_word( &mut self ) -> io::Result<()> {
                if let Some( completions ) = self.read.completions.take() {
                    if completions.len() == 1 {
                        self.substitute_completion( &completions[0] )?;
                    } else {
                        self.show_completions( &completions )?;
                        self.read.completions = Some( completions );
                    }
                } else {
                    self.build_completions();
                    let completions = self.read.completions.take().unwrap_or_default();

                    if completions.len() == 1 {
                        self.substitute_completion( &completions[0] )?;
                    } else if !completions.is_empty() {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;

                        {
                            let pfx = regex::longest_common_prefix( completions.iter()
                                .map( |compl| &compl.completion[..] ) )
                                .unwrap_or_default();
                            self.replace_str_forward( start..end, &pfx )?;
                        }

                        self.read.completions = Some( completions );
                    }
                }

                Ok( () )
            }

            fn substitute_completion( &mut self, compl:&Completion ) -> io::Result<()> {
                let mut s = self.read.completer.quote( &compl.completion );

                if let Some( suffix ) = compl.suffix.with_default( self.read.completion_append_character ) {
                    s.to_mut().push( suffix );
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward( start..end, &s )
            }

            fn insert_completions( &mut self, completions:&[Completion] ) -> io::Result<()> {
                let mut words = String::new();

                for compl in completions {
                    words.push_str( &self.read.completer.unquote( &compl.completion ) );
                    words.push( ' ' );
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;

                self.replace_str_forward( start..end, &words )
            }

            fn show_completions( &mut self, completions:&[Completion] ) -> io::Result<()> {
                if completions.is_empty() {
                    return Ok( () );
                }

                let eff_width = self.write.screen_size.columns
                    .min( self.read.completion_display_width );

                let completions = completions.iter()
                    .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                    .collect::<Vec<_>>();

                let cols = format_columns( &completions, eff_width,
                    self.read.print_completions_horizontally );
                let table = Table::new( &completions, cols.as_ref().map( |c| &c[..] ),
                    self.read.print_completions_horizontally );

                self.write.write_str( "\n" )?;

                let n_completions = completions.len();

                if self.read.page_completions &&
                        n_completions >= self.read.completion_query_items {
                    self.start_page_completions( n_completions )
                } else {
                    self.show_list_completions( table )?;
                    self.write.draw_prompt()
                }
            }

            fn start_page_completions( &mut self, n_completions: usize ) -> io::Result<()> {
                self.read.state = InputState::CompleteIntro;
                self.write.redraw_prompt( PromptType::CompleteIntro( n_completions ) )
            }

            fn end_page_completions( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.prompt_type = PromptType::Normal;
                self.write.draw_prompt()
            }

            fn is_paging_completions( &self ) -> bool {
                match self.read.state {
                    InputState::CompleteMore( _ ) => true,
                    _ => false
                }
            }

            fn show_completions_page( &mut self, offset: usize ) -> io::Result<()> {
                if let Some( compl ) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min( self.read.completion_display_width );
                    let n_lines = self.write.screen_size.lines - 1;

                    let completions = compl.iter()
                        .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                        .collect::<Vec<_>>();

                    let cols = format_columns( &completions, width,
                        self.read.print_completions_horizontally );
                    let mut table = Table::new( &completions, cols.as_ref().map( |c| &c[..] ),
                        self.read.print_completions_horizontally );

                    for row in table.by_ref().skip( offset ).take( n_lines ) {
                        self.show_completion_line( row )?;
                    }

                    if table.has_more() {
                        self.read.completions = Some( compl );
                        self.read.state = InputState::CompleteMore( offset + n_lines );
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok( () )
            }

            fn show_completions_line( &mut self, offset: usize ) -> io::Result<()> {
                if let Some( compl ) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min( self.read.completion_display_width );
                    let completions = compl.iter()
                        .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                        .collect::<Vec<_>>();

                    let cols = format_columns( &completions, width,
                        self.read.print_completions_horizontally );
                    let mut table = Table::new( &completions, cols.as_ref().map( |c| &c[..] ),
                        self.read.print_completions_horizontally );

                    if let Some( row ) = table.by_ref().skip( offset ).next() {
                        self.show_completion_line( row )?;
                    }

                    if table.has_more() {
                        self.read.completions = Some( compl );
                        self.read.state = InputState::CompleteMore( offset + 1 );
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok( () )
            }

            fn show_completion_line<S: AsRef<str>>( &mut self, line: Line<S> ) -> io::Result<()> {
                let mut space = 0;

                for ( width, name ) in line {
                    self.write.move_right( space )?;
                    self.write.write_str( name )?;
                    space = width - name.chars().count();
                }

                self.write.write_str( "\n" )
            }

            fn show_list_completions<S: AsRef<str>>( &mut self, table: Table<S> ) -> io::Result<()> {
                for line in table {
                    let mut space = 0;

                    for ( width, name ) in line {
                        self.write.move_right( space )?;
                        self.write.write_str( name )?;
                        space = width - name.chars().count();
                    }
                    self.write.write_str( "\n" )?;
                }

                Ok( () )
            }

            fn next_completion( &mut self, n: usize ) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let max = len + 1;

                let old = self.read.completion_index;
                let new = ( old + n ) % max;

                if old != new {
                    self.set_completion( new )?;
                }

                Ok( () )
            }

            fn prev_completion( &mut self, n: usize ) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let max = len + 1;

                let old = self.read.completion_index;
                let new = if n <= old {
                    max - old - n
                } else {
                    old - n
                };

                self.set_completion( new )
            }

            fn set_completion( &mut self, new: usize ) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let old = self.read.completion_index;

                if old != new {
                    self.read.completion_index = new;

                    if new == len {
                        let start = self.read.completion_prefix;
                        let end = self.write.cursor;

                        self.delete_range( start..end )?;
                    } else {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let s = self.read.completions.as_ref().unwrap()[new]
                            .completion( self.read.completion_append_character ).into_owned();

                        self.replace_str_forward( start..end, &s )?;
                    }
                }

                Ok( () )
            }

            fn abort_search_history( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.read.last_cmd = Category::Other;
                self.write.abort_search_history()
            }

            fn end_search_history( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.end_search_history()
            }

            pub fn handle_resize( &mut self, size: Size ) -> io::Result<()> {
                self.expire_blink()?;

                if self.is_paging_completions() {
                    self.end_page_completions()?;
                }

                self.write.screen_size = size;

                let p = self.write.prompt_type;
                self.write.redraw_prompt( p )
            }

            pub fn handle_signal( &mut self, signal: Signal ) -> io::Result<()> {
                self.expire_blink()?;

                match signal {
                    Signal::Continue => {
                        self.write.draw_prompt()?;
                    }
                    Signal::Interrupt => {
                        self.read.macro_buffer.clear();
                        self.write.move_to_end()?;

                        if self.read.echo_control_characters {
                            self.write.write_str( "^C" )?;
                        }

                        self.write.write_str( "\n" )?;
                        self.reset_input();
                        self.write.draw_prompt()?;
                    }
                    _ => ()
                }

                Ok( () )
            }

            fn backward_word( &mut self, n: usize ) -> io::Result<()> {
                let pos = regex::backward_word( n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break );
                self.write.move_to( pos )
            }

            fn forward_word( &mut self, n: usize ) -> io::Result<()> {
                let pos = regex::forward_word( n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break );
                self.write.move_to( pos )
            }
            /// Deletes a range of text from the input buffer.
            pub fn delete_range<R: ops::RangeArgument<usize>>( &mut self, range: R ) -> io::Result<()> {
                self.write.delete_range( range )
            }
            /// Deletes a range from the buffer and adds the removed text to the
            /// kill ring.
            pub fn kill_range<R: ops::RangeArgument<usize>>( &mut self, range: R ) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or( 0 );
                let end = range.end().cloned().unwrap_or_else( || self.write.buffer.len() );
                let len = end - start;

                if len != 0 {
                    let buf = self.write.buffer[start..end].to_owned();

                    if self.read.last_cmd != Category::Kill {
                        self.push_kill_ring( buf );
                    } else if end == self.write.cursor {
                        self.prepend_kill_ring( buf );
                    } else {
                        self.append_kill_ring( buf );
                    }

                    self.delete_range( start..end )?;
                }

                Ok( () )
            }

            fn push_kill_ring( &mut self, s: String ) {
                if self.read.kill_ring.len() == self.read.kill_ring.capacity() {
                    self.read.kill_ring.pop_back();
                }
                self.read.kill_ring.push_front( s );
            }

            fn rotate_kill_ring( &mut self ) {
                if let Some( kill ) = self.read.kill_ring.pop_front() {
                    self.read.kill_ring.push_back( kill );
                }
            }

            fn append_kill_ring( &mut self, s: String ) {
                if let Some( kill ) = self.read.kill_ring.front_mut() {
                    kill.push_str( &s );
                    return;
                }
                self.push_kill_ring( s );
            }

            fn prepend_kill_ring( &mut self, s: String ) {
                if let Some( kill ) = self.read.kill_ring.front_mut() {
                    kill.insert_str( 0, &s );
                    return;
                }
                self.push_kill_ring( s );
            }
            /// Transposes two regions of the buffer, `src` and `dest`.
            pub fn transpose_range( &mut self, src: Range<usize>, dest: Range<usize> )
                    -> io::Result<()> {
                self.write.transpose_range( src, dest )
            }
            /// Insert text from the front of the kill ring at the current cursor position.
            pub fn yank( &mut self ) -> io::Result<()> {
                if let Some( kill ) = self.read.kill_ring.front().cloned() {
                    let start = self.write.cursor;
                    self.read.last_yank = Some( ( start, start + kill.len() ) );

                    self.insert_str( &kill )?;
                }

                Ok( () )
            }
            /// Rotates the kill ring and replaces yanked text with the new front.
            pub fn yank_pop( &mut self ) -> io::Result<()> {
                if let Some( ( start, end ) ) = self.read.last_yank {
                    self.rotate_kill_ring();

                    if let Some( kill ) = self.read.kill_ring.front().cloned() {
                        self.read.last_yank = Some( ( start, start + kill.len() ) );

                        self.write.move_to( start )?;
                        self.replace_str_forward( start..end, &kill )?;
                    }
                }

                Ok( () )
            }
            /// Overwrite `n` characters; assumes `n >= 1`
            fn overwrite( &mut self, n: usize, ch:char ) -> io::Result<()> {
                let start = self.write.cursor;
                let end = char::forward( n, &self.write.buffer, start );

                {
                    let over = &self.write.buffer[start..end];
                    let n_chars = over.chars().count();

                    if n > n_chars {
                        self.read.overwritten_append += n - n_chars;
                    }

                    if !over.is_empty() {
                        self.read.overwritten_chars.push_str( &over );
                    }
                }

                let s = char::repeat( ch, n );
                self.replace_str_forward( start..end, &s )
            }

            fn overwrite_back( &mut self, mut n: usize ) -> io::Result<()> {
                if self.read.overwritten_append != 0 {
                    let n_del = n.min( self.read.overwritten_append );

                    let pos = char::backward( n_del, &self.write.buffer, self.write.cursor );
                    let r = pos..self.write.cursor;
                    self.delete_range( r )?;

                    self.read.overwritten_append -= n_del;
                    n -= n_del;
                }

                if n != 0 && !self.read.overwritten_chars.is_empty() {
                    let n_repl = n.min( self.read.overwritten_chars.chars().count() );

                    let pos = char::backward( n_repl, &self.write.buffer, self.write.cursor );

                    let over_pos = char::backward( n_repl,
                        &self.read.overwritten_chars, self.read.overwritten_chars.len() );

                    let over = self.read.overwritten_chars.drain( over_pos.. ).collect::<String>();

                    let r = pos..self.write.cursor;
                    self.replace_str_backward( r, &over )?;

                    n -= n_repl;
                }

                if n != 0 {
                    self.write.backward_char( n )?;
                }

                Ok( () )
            }
            /// Insert a given character at the current cursor position `n` times.
            pub fn insert( &mut self, n: usize, ch:char ) -> io::Result<()> {
                if n != 0 {
                    let s = char::repeat( ch, n );
                    self.insert_str( &s )?;
                }

                Ok( () )
            }
            /// Insert a string at the current cursor position.
            pub fn insert_str( &mut self, s:&str ) -> io::Result<()> {
                self.write.insert_str( s )
            }
            /// Replaces a range in the buffer and redraws.
            pub fn replace_str_backward<R: ops::RangeArgument<usize>>( &mut self,
                    range: R, s:&str ) -> io::Result<()> {
                self.replace_str_impl( range, s )?;
                let len = self.write.buffer.len();
                self.write.move_from( len )
            }
            /// Replaces a range in the buffer and redraws.
            pub fn replace_str_forward<R: ops::RangeArgument<usize>>( &mut self,
                    range: R, s:&str ) -> io::Result<()> {
                self.replace_str_impl( range, s )?;
                self.write.cursor += s.len();
                let len = self.write.buffer.len();
                self.write.move_from( len )
            }
            /// Replaces a range in the buffer and redraws.
            fn replace_str_impl<R: ops::RangeArgument<usize>>( &mut self,
                    range: R, s:&str ) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or( 0 );
                let end = range.end().cloned().unwrap_or_else( || self.write.buffer.len() );
                self.write.move_to( start )?;

                let _ = self.write.buffer.drain( start..end );
                let cursor = self.write.cursor;
                self.write.buffer.insert_str( cursor, s );

                self.write.draw_buffer( cursor )?;
                self.write.clear_to_screen_end()
            }
        }
    }

    pub mod reader
    {
        /*!
        */
        use ::
        {
            borrow::{ Cow },
            collections::{ HashMap, VecDeque },
            mem::{ replace },
            ops::{ Deref, DerefMut },
            path::{ Path, PathBuf },
            regex::{ match_name },
            sync::{ Arc, MutexGuard },
            system::
            {
                self,
                command::{ Category, Command },
                common::sys::{ user_init_file, env_init_file, system_init_file },
                complete::{ Completer, Completion, DummyCompleter },
                function::{ Function },
                input::{parse_file, Directive},
                interface::{ Interface },
                prompter::{ Prompter },
                terminal::
                {
                    RawRead, Terminal, TerminalReader,
                },
                variables::{ Variable, Variables, VariableIter },
            },
            time::std::{ Duration, Instant },
            *,
        };
        /*
            use mortal::SequenceMap;
            use crate::util::{first_char, match_name};
        */
        /// Default set of string characters
        pub const STRING_CHARS:&str = "\"'";
        /// Default set of word break characters
        pub const WORD_BREAK_CHARS:&str = " \t\n\"\\'`@$><=;|&{( ";
        /// Indicates the start of a series of invisible characters in the prompt
        pub const START_INVISIBLE:char = '\x01';
        /// Indicates the end of a series of invisible characters in the prompt
        pub const END_INVISIBLE:char = '\x02';
        /// Maximum size of kill ring
        const MAX_KILLS: usize = 10;
        /// Provides access to data related to reading and processing user input.
        pub struct Reader<'a, Term: 'a + Terminal>
        {
            iface:&'a Interface<Term>,
            lock: ReadLock<'a, Term>,
        }

        pub struct Read<Term: Terminal> 
        {
            /// Application name
            pub application: Cow<'static, str>,
            /// Pending input
            pub input_buffer: Vec<u8>,
            /// Pending macro sequence
            pub macro_buffer: String,
            //pub bindings: Option<SequenceMap<Cow<'static, str>, Command>>,
            pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,
            /// Current input sequence
            pub sequence: String,
            /// Whether newline has been received
            pub input_accepted: bool,
            /// Whether overwrite mode is currently active
            pub overwrite_mode: bool,
            /// Characters appended while in overwrite mode
            pub overwritten_append: usize,
            /// Characters overwritten in overwrite mode
            pub overwritten_chars: String,
            /// Configured completer
            pub completer: Arc<dyn Completer<Term>>,
            /// Character appended to completions
            pub completion_append_character: Option<char>,
            /// Current set of possible completions
            pub completions: Option<Vec<Completion>>,
            /// Current "menu-complete" entry being viewed:
            pub completion_index: usize,
            /// Start of the completed word
            pub completion_start: usize,
            /// Start of the inserted prefix of a completed word
            pub completion_prefix: usize,

            pub string_chars: Cow<'static, str>,
            pub word_break: Cow<'static, str>,

            pub last_cmd: Category,
            pub last_yank: Option<( usize, usize )>,
            pub kill_ring: VecDeque<String>,

            pub catch_signals: bool,
            pub ignore_signals: system::terminal::SignalSet,
            pub report_signals: system::terminal::SignalSet,
            pub last_resize: Option<system::terminal::Size>,
            pub last_signal: Option<system::terminal::Signal>,

            variables: Variables,

            pub state: InputState,
            pub max_wait_duration: Option<Duration>,
        }

        pub struct ReadLock<'a, Term: 'a + Terminal>
        {
            term: Box<dyn TerminalReader<Term> + 'a>,
            data: MutexGuard<'a, Read<Term>>,
        }
        /// Returned from [`read_line`] to indicate user input
        #[derive( Debug )]
        pub enum ReadResult
        {
            /// User issued end-of-file.
            Eof,
            /// User input received.
            Input( String ),
            /// Reported signal was received.
            Signal( system::terminal::Signal ),
        }

        #[derive( Copy, Clone, Debug )]
        pub enum InputState {
            Inactive,
            NewSequence,
            ContinueSequence{
                expiry: Option<Instant>,
            },
            Number,
            CharSearch{
                n: usize,
                backward: bool,
            },
            TextSearch,
            CompleteIntro,
            CompleteMore( usize ),
            QuotedInsert( usize ),
        }

        impl<'a, Term: 'a + Terminal> Reader<'a, Term> {
            pub fn new( iface:&'a Interface<Term>, lock: ReadLock<'a, Term> )
                    -> Reader<'a, Term> {
                Reader{iface, lock}
            }
            /// Interactively reads a line from the terminal device.
            pub fn read_line( &mut self ) -> io::Result<ReadResult> {
                loop {
                    if let Some( res ) = self.read_line_step( None )? {
                        return Ok( res );
                    }
                }
            }
            /// Performs one step of the interactive `read_line` loop.
            pub fn read_line_step( &mut self, timeout: Option<Duration> )
                    -> io::Result<Option<ReadResult>> {
                self.initialize_read_line()?;

                let state = self.prepare_term()?;
                let res = self.read_line_step_impl( timeout );
                self.lock.term.restore( state )?;

                res
            }
            /// Cancels an in-progress `read_line` operation.
            pub fn cancel_read_line( &mut self ) -> io::Result<()> {
                self.end_read_line()
            }

            fn initialize_read_line( &mut self ) -> io::Result<()> {
                if !self.lock.is_active() {
                    self.prompter().start_read_line()?;
                }
                Ok( () )
            }

            fn read_line_step_impl( &mut self, timeout: Option<Duration> ) -> io::Result<Option<ReadResult>> 
            {
                let do_read = if self.lock.is_input_available()
                {
                    self.lock.term.wait_for_input( Some( Duration::from_secs( 0 ) ) )?
                } 
                
                else 
                {
                    let timeout = limit_duration( timeout, self.lock.max_wait_duration );
                    self.lock.term.wait_for_input( timeout )?
                };

                if do_read 
                {
                    self.lock.read_input()?;
                }

                if let Some( size ) = self.lock.take_resize() 
                {
                    self.handle_resize( size )?;
                }

                if let Some( sig ) = self.lock.take_signal() 
                {
                    if self.lock.report_signals.contains( sig ) {
                        return Ok( Some( ReadResult::Signal( sig ) ) );
                    }
                    if !self.lock.ignore_signals.contains( sig ) {
                        self.handle_signal( sig )?;
                    }
                }
                
                {
                    let mut prompter = self.prompter();

                    prompter.check_expire_timeout()?;
                    
                    let mut macro_len = prompter.read.data.macro_buffer.len();

                    while prompter.read.is_input_available() {
                        if let Some( ch ) = prompter.read.read_char()? {
                            if let Some( r ) = prompter.handle_input( ch )? {
                                prompter.end_read_line()?;
                                return Ok( Some( r ) );
                            }
                        }

                        let new_macro_len = prompter.read.data.macro_buffer.len();

                        if new_macro_len != 0 && new_macro_len >= macro_len {
                            break;
                        }

                        macro_len = new_macro_len;
                    }
                }

                Ok( None )
            }

            fn end_read_line( &mut self ) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().end_read_line()?;
                }
                Ok( () )
            }

            fn prepare_term( &mut self ) -> io::Result<Term::PrepareState> {
                if self.read_next_raw() {
                    self.lock.term.prepare( true, system::terminal::SignalSet::new() )
                } else {
                    let mut signals = self.lock.report_signals.union( self.lock.ignore_signals );

                    if self.lock.catch_signals {
                        signals.insert( system::terminal::Signal::Interrupt  );
                    }

                    let block_signals = !self.lock.catch_signals;

                    self.lock.term.prepare( block_signals, signals )
                }
            }

            fn read_next_raw( &self ) -> bool {
                match self.lock.state {
                    InputState::QuotedInsert( _ ) => true,
                    _ => false
                }
            }
            /// Sets the input buffer to the given string.
            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_buffer( buf )
                } else {
                    self.iface.lock_write_data().set_buffer( buf );
                    Ok( () )
                }
            }
            /// Sets the cursor position in the input buffer.
            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_cursor( pos )
                } else {
                    self.iface.lock_write_data().set_cursor( pos );
                    Ok( () )
                }
            }
            /// Sets the prompt that will be displayed when `read_line` is called.
            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> {
                self.prompter().set_prompt( prompt )
            }
            /// Adds a line to history.
            pub fn add_history( &self, line: String ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history( line );
                }
            }
            /// Adds a line to history, unless it is identical to the most recent entry.
            pub fn add_history_unique( &self, line: String ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history_unique( line );
                }
            }
            /// Removes all history entries.
            pub fn clear_history( &self ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().clear_history();
                }
            }
            /// Removes the history entry at the given index.
            pub fn remove_history( &self, idx: usize ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().remove_history( idx );
                }
            }
            /// Sets the maximum number of history entries.
            pub fn set_history_size( &self, n: usize ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().set_history_size( n );
                }
            }
            /// Truncates history to the only the most recent `n` entries.
            pub fn truncate_history( &self, n: usize ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().truncate_history( n );
                }
            }
            /// Returns the application name
            pub fn application( &self ) -> &str {
                &self.lock.application
            }
            /// Sets the application name
            pub fn set_application<T>( &mut self, application: T )
                    where T: Into<Cow<'static, str>> {
                self.lock.application = application.into();
            }
            /// Returns a reference to the current completer instance.
            pub fn completer( &self ) -> &Arc<dyn Completer<Term>> {
                &self.lock.completer
            }
            /// Replaces the current completer, returning the previous instance.
            pub fn set_completer( &mut self, completer: Arc<dyn Completer<Term>> )
                    -> Arc<dyn Completer<Term>> {
                replace( &mut self.lock.completer, completer )
            }
            /// Returns the value of the named variable or `None`
            /// if no such variable exists.
            pub fn get_variable( &self, name:&str ) -> Option<Variable> {
                self.lock.get_variable( name )
            }
            /// Sets the value of the named variable and returns the previous
            /// value.
            pub fn set_variable( &mut self, name:&str, value:&str ) -> Option<Variable> {
                self.lock.set_variable( name, value )
            }
            /// Returns an iterator over stored variables.
            pub fn variables( &self ) -> VariableIter {
                self.lock.variables.iter()
            }
            /// Returns whether to "blink" matching opening parenthesis character
            /// when a closing parenthesis character is entered.
            pub fn blink_matching_paren( &self ) -> bool {
                self.lock.blink_matching_paren
            }
            /// Sets the `blink-matching-paren` variable.
            pub fn set_blink_matching_paren( &mut self, set: bool ) {
                self.lock.blink_matching_paren = set;
            }
            /// Returns whether `linefeed` will catch certain signals.
            pub fn catch_signals( &self ) -> bool {
                self.lock.catch_signals
            }
            /// Sets whether `linefeed` will catch certain signals.
            pub fn set_catch_signals( &mut self, enabled: bool ) {
                self.lock.catch_signals = enabled;
            }
            /// Returns whether the given `Signal` is ignored.
            pub fn ignore_signal( &self, signal: system::terminal::Signal ) -> bool {
                self.lock.ignore_signals.contains( signal )
            }
            /// Sets whether the given `Signal` will be ignored.
            pub fn set_ignore_signal( &mut self, signal: system::terminal::Signal, set: bool ) {
                if set {
                    self.lock.ignore_signals.insert( signal );
                    self.lock.report_signals.remove( signal );
                } else {
                    self.lock.ignore_signals.remove( signal );
                }
            }
            /// Returns whether the given `Signal` is to be reported.
            pub fn report_signal( &self, signal: system::terminal::Signal ) -> bool {
                self.lock.report_signals.contains( signal )
            }
            /// Sets whether to report the given `Signal`.
            pub fn set_report_signal( &mut self, signal: system::terminal::Signal, set: bool ) {
                if set {
                    self.lock.report_signals.insert( signal );
                    self.lock.ignore_signals.remove( signal );
                } else {
                    self.lock.report_signals.remove( signal );
                }
            }
            /// Returns whether Tab completion is disabled.
            pub fn disable_completion( &self ) -> bool {
                self.lock.disable_completion
            }
            /// Sets the `disable-completion` variable.
            pub fn set_disable_completion( &mut self, disable: bool ) {
                self.lock.disable_completion = disable;
            }
            /// When certain control characters are pressed, a character sequence
            /// equivalent to this character will be echoed.
            pub fn echo_control_characters( &self ) -> bool {
                self.lock.echo_control_characters
            }
            /// Sets the `echo-control-characters` variable.
            pub fn set_echo_control_characters( &mut self, echo: bool ) {
                self.lock.echo_control_characters = echo;
            }
            /// Returns the character, if any, that is appended to a successful completion.
            pub fn completion_append_character( &self ) -> Option<char> {
                self.lock.completion_append_character
            }
            /// Sets the character, if any, that is appended to a successful completion.
            pub fn set_completion_append_character( &mut self, ch: Option<char> ) {
                self.lock.completion_append_character = ch;
            }
            /// Returns the width of completion listing display.
            pub fn completion_display_width( &self ) -> usize {
                self.lock.completion_display_width
            }
            /// Sets the `completion-display-width` variable.
            pub fn set_completion_display_width( &mut self, n: usize ) {
                self.lock.completion_display_width = n;
            }
            /// Returns the minimum number of completion items that require user
            /// confirmation before listing.
            pub fn completion_query_items( &self ) -> usize {
                self.lock.completion_query_items
            }
            /// Sets the `completion-query-items` variable.
            pub fn set_completion_query_items( &mut self, n: usize ) {
                self.lock.completion_query_items = n;
            }
            /// Returns timeout to wait for user input when an ambiguous sequence has been entered.
            pub fn keyseq_timeout( &self ) -> Option<Duration> {
                self.lock.keyseq_timeout
            }
            /// Sets the `keyseq-timeout` variable.
            pub fn set_keyseq_timeout( &mut self, timeout: Option<Duration> ) {
                self.lock.keyseq_timeout = timeout;
            }
            /// Returns whether to list possible completions one page at a time.
            pub fn page_completions( &self ) -> bool {
                self.lock.page_completions
            }
            /// Sets the `page-completions` variable.
            pub fn set_page_completions( &mut self, set: bool ) {
                self.lock.page_completions = set;
            }
            /// Returns whether to list completions horizontally, rather than down
            /// the screen.
            pub fn print_completions_horizontally( &self ) -> bool {
                self.lock.print_completions_horizontally
            }
            /// Sets the `print-completions-horizontally` variable.
            pub fn set_print_completions_horizontally( &mut self, set: bool ) {
                self.lock.print_completions_horizontally = set;
            }
            /// Returns the set of characters that delimit strings.
            pub fn string_chars( &self ) -> &str {
                &self.lock.string_chars
            }
            /// Sets the set of characters that delimit strings.
            pub fn set_string_chars<T>( &mut self, chars: T )
                    where T: Into<Cow<'static, str>> {
                self.lock.string_chars = chars.into();
            }
            /// Returns the set of characters that indicate a word break.
            pub fn word_break_chars( &self ) -> &str {
                &self.lock.word_break
            }
            /// Sets the set of characters that indicate a word break.
            pub fn set_word_break_chars<T>( &mut self, chars: T )
                    where T: Into<Cow<'static, str>> {
                self.lock.word_break = chars.into();
            }
            /// Returns an iterator over bound sequences
            /* pub fn bindings( &self ) -> BindingIter {
                self.lock.bindings()
            } */
            /// Binds a sequence to a command.
            pub fn bind_sequence<T>( &mut self, seq: T, cmd: Command ) -> Option<Command>
                    where T: Into<Cow<'static, str>> {
                self.lock.bind_sequence( seq, cmd )
            }
            /// Binds a sequence to a command, if and only if the given sequence
            /// is not already bound to a command.
            pub fn bind_sequence_if_unbound<T>( &mut self, seq: T, cmd: Command ) -> bool where
            T:Into<Cow<'static, str>>
            { self.lock.bind_sequence_if_unbound( seq, cmd ) }
            /// Removes a binding for the given sequence.
            pub fn unbind_sequence( &mut self, seq:&str ) -> Option<Command> {
                self.lock.unbind_sequence( seq )
            }
            /// Defines a named function to which sequences may be bound.
            pub fn define_function<T>( &mut self, name: T, cmd: Arc<dyn Function<Term>> )
                    -> Option<Arc<dyn Function<Term>>> where T: Into<Cow<'static, str>> {
                self.lock.define_function( name, cmd )
            }
            /// Removes a function defined with the given name.
            pub fn remove_function( &mut self, name:&str ) -> Option<Arc<dyn Function<Term>>> {
                self.lock.remove_function( name )
            }

            pub fn evaluate_directives( &mut self, term:&Term, dirs: Vec<Directive> ) {
                self.lock.data.evaluate_directives( term, dirs )
            }

            pub fn evaluate_directive( &mut self, term:&Term, dir: Directive ) {
                self.lock.data.evaluate_directive( term, dir )
            }

            fn prompter<'b>( &'b mut self ) -> Prompter<'b, 'a, Term> {
                Prompter::new( 
                    &mut self.lock,
                    self.iface.lock_write() )
            }

            fn handle_resize( &mut self, size: system::terminal::Size ) -> io::Result<()> {
                self.prompter().handle_resize( size )
            }

            fn handle_signal( &mut self, sig: system::terminal::Signal ) -> io::Result<()> {
                self.prompter().handle_signal( sig )
            }
        }

        impl<'a, Term: 'a + Terminal> ReadLock<'a, Term> {
            pub fn new( term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>> )
                    -> ReadLock<'a, Term> {
                ReadLock{term, data}
            }
            /// Reads the next character of input.
            pub fn read_char( &mut self ) -> io::Result<Option<char>> {
                if let Some( ch ) = self.macro_pop() {
                    Ok( Some( ch ) )
                } else if let Some( ch ) = self.decode_input()? {
                    Ok( Some( ch ) )
                } else {
                    Ok( None )
                }
            }

            fn read_input( &mut self ) -> io::Result<()>
            {
                /*
                match self.term.read( &mut self.data.input_buffer )?
                {
                    RawRead::Bytes( _ ) => (),
                    RawRead::Resize( new_size ) => {
                        self.last_resize = Some( new_size );
                    }
                    RawRead::Signal( sig ) => {
                        self.last_signal = Some( sig );
                    }
                } */

                Ok( () )
            }

            fn is_input_available( &self ) -> bool {
                !self.data.macro_buffer.is_empty() || match self.peek_input() {
                    Ok( Some( _ ) ) | Err( _ ) => true,
                    Ok( None ) => false
                }
            }

            fn macro_pop( &mut self ) -> Option<char> {
                if self.data.macro_buffer.is_empty() {
                    None
                } else {
                    Some( self.data.macro_buffer.remove( 0 ) )
                }
            }

            fn decode_input( &mut self ) -> io::Result<Option<char>> {
                let res = self.peek_input();

                if let Ok( Some( ch ) ) = res {
                    self.data.input_buffer.drain( ..ch.len_utf8() );
                }

                res
            }

            fn peek_input( &self ) -> io::Result<Option<char>> {
                if self.data.input_buffer.is_empty() {
                    Ok( None )
                } else {
                    char::first( &self.data.input_buffer )
                }
            }

            pub fn reset_data( &mut self ) {
                self.data.reset_data();
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for ReadLock<'a, Term> {
            type Target = Read<Term>;

            fn deref( &self ) -> &Read<Term> {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for ReadLock<'a, Term> 
        {
            fn deref_mut( &mut self ) -> &mut Read<Term> {
                &mut self.data
            }
        }

        impl<Term: Terminal> Deref for Read<Term> {
            type Target = Variables;

            fn deref( &self ) -> &Variables {
                &self.variables
            }
        }

        impl<Term: Terminal> DerefMut for Read<Term> 
        {
            fn deref_mut( &mut self ) -> &mut Variables {
                &mut self.variables
            }
        }

        impl<Term: Terminal> Read<Term>
        {
            pub fn new( term:&Term, application: Cow<'static, str> ) -> Read<Term>
            {
                let mut r = Read{
                    application,

                    //bindings: default_bindings(),
                    functions: HashMap::new(),

                    input_buffer: Vec::new(),
                    macro_buffer: String::new(),

                    sequence: String::new(),
                    input_accepted: false,

                    overwrite_mode: false,
                    overwritten_append: 0,
                    overwritten_chars: String::new(),

                    completer: Arc::new( DummyCompleter ),
                    completion_append_character: Some( ' ' ),
                    completions: None,
                    completion_index: 0,
                    completion_start: 0,
                    completion_prefix: 0,

                    string_chars: STRING_CHARS.into(),
                    word_break: WORD_BREAK_CHARS.into(),

                    last_cmd: Category::Other,
                    last_yank: None,
                    kill_ring: VecDeque::with_capacity( MAX_KILLS ),

                    catch_signals: true,
                    ignore_signals: system::terminal::SignalSet::new(),
                    report_signals: system::terminal::SignalSet::new(),
                    last_resize: None,
                    last_signal: None,

                    variables: Variables::default(),

                    state: InputState::Inactive,
                    max_wait_duration: None,
                };

                r.read_init( term );
                r
            }

            /* pub fn bindings( &self ) -> BindingIter { BindingIter( self.bindings.sequences().iter() ) } */

            pub fn variables( &self ) -> VariableIter { self.variables.iter() }

            fn take_resize( &mut self ) -> Option<system::terminal::Size> { self.last_resize.take() }

            fn take_signal( &mut self ) -> Option<system::terminal::Signal> { self.last_signal.take() }

            pub fn queue_input( &mut self, seq:&str ) { self.macro_buffer.insert_str( 0, seq ); }

            pub fn is_active( &self ) -> bool
            {
                match self.state {
                    InputState::Inactive => false,
                    _ => true
                }
            }

            pub fn reset_data( &mut self )
            {
                self.state = InputState::NewSequence;
                self.input_accepted = false;
                self.overwrite_mode = false;
                self.overwritten_append = 0;
                self.overwritten_chars.clear();
                self.sequence.clear();

                self.completions = None;

                self.last_cmd = Category::Other;
                self.last_yank = None;

                self.last_resize = None;
                self.last_signal = None;
            }

            pub fn bind_sequence<T>( &mut self, seq: T, cmd: Command ) -> Option<Command>
            where T: Into<Cow<'static, str>>
            { 
                None
                /*self.bindings.insert( seq.into(), cmd ) */
            }

            pub fn bind_sequence_if_unbound<T>( &mut self, seq: T, cmd: Command ) -> bool where
            T: Into<Cow<'static, str>>
            {
                false
                /*
                //use mortal::sequence::Entry;

                match self.bindings.entry( seq.into() ) {
                    Entry::Occupied( _ ) => false,
                    Entry::Vacant( ent ) => {
                        ent.insert( cmd );
                        true
                    }
                } */
            }

            pub fn unbind_sequence( &mut self, seq:&str ) -> Option<Command>
            {
                None
                /*self.bindings.remove( seq ).map( |( _, cmd )| cmd ) */
            }

            pub fn define_function<T>( &mut self, name: T, cmd: Arc<dyn Function<Term>> ) 
            -> Option<Arc<dyn Function<Term>>> 
            where 
            T: Into<Cow<'static, str>>
            { self.functions.insert( name.into(), cmd ) }

            pub fn remove_function( &mut self, name:&str ) -> Option<Arc<dyn Function<Term>>>
            { self.functions.remove( name ) }

            fn read_init( &mut self, term:&Term )
            {
                if let Some( path ) = env_init_file()
                {
                    self.read_init_file_if_exists( term, Some( path ) );
                } else {
                    if !self.read_init_file_if_exists( term, user_init_file() ) {
                        self.read_init_file_if_exists( term, system_init_file() );
                    }
                }
            }

            fn read_init_file_if_exists( &mut self, term:&Term, path: Option<PathBuf> ) -> bool
            {
                match path {
                    Some( ref path ) if path.exists() => {
                        self.read_init_file( term, path );
                        true
                    }
                    _ => false
                }
            }

            fn read_init_file( &mut self, term:&Term, path:&Path )
            {
                if let Some( dirs ) = parse_file( path ) {
                    self.evaluate_directives( term, dirs );
                }
            }
            /// Evaluates a series of configuration directives.
            pub fn evaluate_directives( &mut self, term:&Term, dirs: Vec<Directive> )
            {
                for dir in dirs {
                    self.evaluate_directive( term, dir );
                }
            }
            /// Evaluates a single configuration directive.
            pub fn evaluate_directive( &mut self, term:&Term, dir: Directive )
            {
                match dir 
                {
                    Directive::Bind( seq, cmd ) => {
                        self.bind_sequence( seq, cmd );
                    }
                    Directive::Conditional{name, value, then_group, else_group} => {
                        let name = name.as_ref().map( |s| &s[..] );

                        if self.eval_condition( term, name, &value ) {
                            self.evaluate_directives( term, then_group );
                        } else {
                            self.evaluate_directives( term, else_group );
                        }
                    }
                    Directive::SetVariable( name, value ) => {
                        self.set_variable( &name, &value );
                    }
                }
            }

            fn eval_condition( &self, term:&Term, name: Option<&str>, value:&str ) -> bool
            {
                match name
                {
                    None => self.application == value,
                    Some( "lib" ) => value == "linefeed",
                    Some( "mode" ) => value == "emacs",
                    Some( "term" ) => self.term_matches( term, value ),
                    _ => false
                }
            }

            fn term_matches( &self, term:&Term, value:&str ) -> bool
            { match_name( term.name(), value ) }
        }
        /// Iterator over `Reader` bindings
        pub struct BindingIter<'a>( slice::Iter<'a, ( Cow<'static, str>, Command )> );

        impl<'a> ExactSizeIterator for BindingIter<'a> {}

        impl<'a> Iterator for BindingIter<'a> 
        {
            type Item = ( &'a str, &'a Command );

            #[inline] fn next( &mut self ) -> Option<Self::Item> { self.0.next().map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }
            #[inline] fn nth( &mut self, n: usize ) -> Option<Self::Item> { self.0.nth( n ).map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }
            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.0.size_hint() }
        }

        impl<'a> DoubleEndedIterator for BindingIter<'a>
        {
            #[inline] fn next_back( &mut self ) -> Option<Self::Item>
            { self.0.next_back().map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }
        }
        /*
        fn default_bindings() -> Option<SequenceMap<Cow<'static, str>, Command>>
        {
            None
            /*
            use super::command::Command::*;
            SequenceMap::from( vec![
                // Carriage return and line feed
                ( "\r".into(), AcceptLine ),
                ( "\n".into(), AcceptLine ),

                // Possible sequences for arrow keys, Home, End
                ( "\x1b[A".into(), PreviousHistory ),
                ( "\x1b[B".into(), NextHistory ),
                ( "\x1b[C".into(), ForwardChar ),
                ( "\x1b[D".into(), BackwardChar ),
                ( "\x1b[H".into(), BeginningOfLine ),
                ( "\x1b[F".into(), EndOfLine ),

                // More possible sequences for arrow keys, Home, End
                ( "\x1bOA".into(), PreviousHistory ),
                ( "\x1bOB".into(), NextHistory ),
                ( "\x1bOC".into(), ForwardChar ),
                ( "\x1bOD".into(), BackwardChar ),
                ( "\x1bOH".into(), BeginningOfLine ),
                ( "\x1bOF".into(), EndOfLine ),

                // Possible sequences for Insert, Delete
                ( "\x1b[2~".into(), OverwriteMode ),
                ( "\x1b[3~".into(), DeleteChar ),

                // Basic commands
                ( "\x01"    .into(), BeginningOfLine ),           // Ctrl-A
                ( "\x02"    .into(), BackwardChar ),              // Ctrl-B
                ( "\x04"    .into(), DeleteChar ),                // Ctrl-D
                ( "\x05"    .into(), EndOfLine ),                 // Ctrl-E
                ( "\x06"    .into(), ForwardChar ),               // Ctrl-F
                ( "\x07"    .into(), Abort ),                     // Ctrl-G
                ( "\x08"    .into(), BackwardDeleteChar ),        // Ctrl-H
                ( "\x0b"    .into(), KillLine ),                  // Ctrl-K
                ( "\x0c"    .into(), ClearScreen ),               // Ctrl-L
                ( "\x0e"    .into(), NextHistory ),               // Ctrl-N
                ( "\x10"    .into(), PreviousHistory ),           // Ctrl-P
                ( "\x12"    .into(), ReverseSearchHistory ),      // Ctrl-R
                ( "\x14"    .into(), TransposeChars ),            // Ctrl-T
                ( "\x15"    .into(), BackwardKillLine ),          // Ctrl-U
                ( "\x16"    .into(), QuotedInsert ),              // Ctrl-V
                ( "\x17"    .into(), UnixWordRubout ),            // Ctrl-W
                ( "\x19"    .into(), Yank ),                      // Ctrl-Y
                ( "\x1d"    .into(), CharacterSearch ),           // Ctrl-]
                ( "\x7f"    .into(), BackwardDeleteChar ),        // Rubout
                ( "\x1b\x08".into(), BackwardKillWord ),          // Escape, Ctrl-H
                ( "\x1b\x1d".into(), CharacterSearchBackward ),   // Escape, Ctrl-]
                ( "\x1b\x7f".into(), BackwardKillWord ),          // Escape, Rubout
                ( "\x1bb"   .into(), BackwardWord ),              // Escape, b
                ( "\x1bd"   .into(), KillWord ),                  // Escape, d
                ( "\x1bf"   .into(), ForwardWord ),               // Escape, f
                ( "\x1bt"   .into(), TransposeWords ),            // Escape, t
                ( "\x1by"   .into(), YankPop ),                   // Escape, y
                ( "\x1b#"   .into(), InsertComment ),             // Escape, #
                ( "\x1b<"   .into(), BeginningOfHistory ),        // Escape, <
                ( "\x1b>"   .into(), EndOfHistory ),              // Escape, >

                // Completion commands
                ( "\t"   .into(), Complete ),             // Tab
                ( "\x1b?".into(), PossibleCompletions ),  // Escape, ?
                ( "\x1b*".into(), InsertCompletions ),    // Escape, *

                // Digit commands
                ( "\x1b-".into(), DigitArgument ),    // Escape, -
                ( "\x1b0".into(), DigitArgument ),    // Escape, 0
                ( "\x1b1".into(), DigitArgument ),    // Escape, 1
                ( "\x1b2".into(), DigitArgument ),    // Escape, 2
                ( "\x1b3".into(), DigitArgument ),    // Escape, 3
                ( "\x1b4".into(), DigitArgument ),    // Escape, 4
                ( "\x1b5".into(), DigitArgument ),    // Escape, 5
                ( "\x1b6".into(), DigitArgument ),    // Escape, 6
                ( "\x1b7".into(), DigitArgument ),    // Escape, 7
                ( "\x1b8".into(), DigitArgument ),    // Escape, 8
                ( "\x1b9".into(), DigitArgument ),    // Escape, 9
            ] ) */
        } */
        fn limit_duration( dur: Option<Duration>, max: Option<Duration> ) -> Option<Duration>
        {
            match ( dur, max )
            {
                ( dur, None ) | ( None, dur ) => dur,
                ( Some( dur ), Some( max ) ) => Some( dur.min( max ) ),
            }
        }
    }

    pub mod table
    {
        /*!
        Provides utilities for formatting strings in a table */
        use ::
        {
            *,
        };
        /*
        */
        const COL_SPACE: usize = 2;
        /// Represents a table of strings, formatted into rows and columns.
        pub struct Table<'a, S: 'a> {
            strings:&'a [S],
            sizes: Option<&'a [usize]>,
            offset: usize,
            per_col: usize,
            rows: usize,
            horizontal: bool,
        }

        impl<'a, S: 'a + AsRef<str>> Table<'a, S> {
            /// Constructs a new table from the given set of strings, using the given column sizes.
            pub fn new( strs:&'a [S], mut sizes: Option<&'a [usize]>,
                    horizontal: bool ) -> Table<'a, S> {
                if let Some( sz ) = sizes {
                    if sz.is_empty() {
                        sizes = None;
                    }
                }

                let n_strs = strs.len();
                let n_cols = sizes.map_or( 1, |sz| sz.len() );

                let rows = n_strs / n_cols + ( n_strs % n_cols != 0 ) as usize;

                Table{
                    strings: strs,
                    sizes: sizes,
                    offset: 0,
                    per_col: ( strs.len() + ( n_cols - 1 ) ) / n_cols,
                    rows: rows,
                    horizontal: horizontal,
                }
            }
            /// Returns whether more lines are present in the table.
            pub fn has_more( &self ) -> bool {
                self.offset < self.rows
            }

            fn num_cols( &self ) -> usize {
                self.sizes.map_or( 1, |sz| sz.len() )
            }
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Table<'a, S> {
            type Item = Line<'a, S>;

            fn next( &mut self ) -> Option<Line<'a, S>> {
                if self.offset == self.rows {
                    return None;
                }

                let n = self.num_cols();

                let ( start, end, stride ) = if self.horizontal {
                    let start = self.offset * n;
                    let end = cmp::min( self.strings.len(), start + n );
                    ( start, end, 1 )
                } else {
                    let start = self.offset;
                    let end = cmp::min( self.strings.len(), start + self.per_col * n );
                    ( start, end, self.per_col )
                };

                self.offset += 1;

                Some( Line{
                    strings:&self.strings[start..end],
                    sizes: self.sizes,
                    stride: stride,
                    offset: 0,
                } )
            }
        }
        /// Represents a single line of the table.
        pub struct Line<'a, S: 'a> 
        {
            strings:&'a [S],
            sizes: Option<&'a [usize]>,
            stride: usize,
            offset: usize,
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Line<'a, S> 
        {
            type Item = ( usize, &'a str );

            fn next( &mut self ) -> Option<( usize, &'a str )> {
                let s = self.strings.get( self.offset * self.stride )?.as_ref();

                let width = self.sizes.and_then( |sz| sz.get( self.offset ).cloned() )
                    .unwrap_or_else( || s.chars().count() );

                self.offset += 1;

                Some( ( width, s ) )
            }
        }
        /// Formats a series of strings into columns, fitting within a given screen width.
        pub fn format_columns<S: AsRef<str>>( strs:&[S], screen_width: usize, horizontal: bool )
        -> Option<Vec<usize>>
        {
            if strs.is_empty() {
                return None;
            }

            let n_strs = strs.len();

            let ( mut min_len, mut max_len ) = min_max( strs.iter().map( |s| s.as_ref().chars().count() ) );

            if min_len == 0 { min_len = 1; }
            if max_len == 0 { max_len = 1; }

            let mut min_cols = cmp::min( n_strs, screen_width / max_len );
            let max_cols = cmp::min( n_strs, screen_width / min_len );

            if min_cols <= 1 {
                min_cols = 2;
            }

            if max_cols <= 1 {
                return None;
            }

            let mut col_sizes = if min_cols == max_cols {
                vec![vec![0; max_cols]]
            } else {
                ( min_cols..max_cols + 1 )
                    .map( |n| vec![0; n] ).collect::<Vec<_>>()
            };

            for ( i, s ) in strs.iter().enumerate() {
                let len = s.as_ref().chars().count();

                for cols in &mut col_sizes {
                    let n_cols = cols.len();

                    let col = if horizontal {
                        i % n_cols
                    } else {
                        let per_col = ( n_strs + ( n_cols - 1 ) ) / n_cols;
                        i / per_col
                    };

                    let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                    if real_len > cols[col] {
                        cols[col] = real_len;
                    }
                }
            }

            for cols in col_sizes.into_iter().rev() {
                if cols.iter().fold( 0, |a, b| a + b ) <= screen_width {
                    return Some( cols );
                }
            }

            None
        }

        fn min_max<I>( iter: I ) -> ( usize, usize ) where I: Iterator<Item=usize> {
            let mut min = usize::max_value();
            let mut max = 0;

            for n in iter {
                if n < min {
                    min = n;
                }
                if n + COL_SPACE > max {
                    max = n + COL_SPACE;
                }
            }

            ( min, max )
        }

    }

    pub mod terminal
    {
        /*!
        */
        use ::
        {
            mem::{ zeroed },
            system::
            {
                api::{ * },
                common::{ unix::terminal_read },
            },
            time::std::{ Duration },
            *,
        };
        pub use system::common::{ * };
        /*
        // via: https://github.com/clap-rs/term_size-rs/blob/644f28c3a8811e56edcf42036b5e754dbb24a0d7/src/platform/unix.rs
        use libc::{c_int, c_ulong, winsize, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO};
        use std::mem::zeroed;
        */
        /// Default `Terminal` interface
        pub struct DefaultTerminal( system::common::Terminal  );
        /// Represents the result of a `Terminal` read operation
        pub enum RawRead
        {
            /// `n` bytes were read from the device
            Bytes( usize ),
            /// The terminal window was resized
            Resize( Size ),
            /// A signal was received while waiting for input
            Signal( Signal ),
        }
        /// Defines a low-level interface to the terminal
        pub trait Terminal: Sized + Send + Sync
        {
            /// Returned by `prepare`; passed to `restore` to restore state.
            type PrepareState;
            /*
            /// Holds an exclusive read lock and provides read operations
            type Reader: TerminalReader;
            /// Holds an exclusive write lock and provides write operations
            type Writer: TerminalWriter;
            */
            /// Returns the name of the terminal.
            fn name( &self ) -> &str;
            /// Acquires a lock on terminal read operations and returns a value holding
            /// that lock and granting access to such operations.
            fn lock_read<'a>( &'a self ) -> Box<dyn TerminalReader<Self> + 'a>;
            /// Acquires a lock on terminal write operations and returns a value holding
            /// that lock and granting access to such operations.
            fn lock_write<'a>( &'a self ) -> Box<dyn TerminalWriter<Self> + 'a>;
        }
        /// Holds a lock on `Terminal` read operations
        pub trait TerminalReader<Term: Terminal>
        {
            /// Prepares the terminal for line reading and editing operations.
            fn prepare( &mut self, block_signals: bool, report_signals: SignalSet ) -> io::Result<Term::PrepareState>;
            /// Like `prepare`, but called when the write lock is already held.
            unsafe fn prepare_with_lock
            ( 
                &mut self,
                lock:&mut dyn TerminalWriter<Term>,
                block_signals: bool,
                report_signals: SignalSet
            ) -> io::Result<Term::PrepareState>;
            /// Restores the terminal state using the given state data.
            fn restore( &mut self, state: Term::PrepareState ) -> io::Result<()>;
            /// Like `restore`, but called when the write lock is already held.
            unsafe fn restore_with_lock( &mut self, lock:&mut dyn TerminalWriter<Term>, state: Term::PrepareState )
            -> io::Result<()>;
            /// Reads some input from the terminal and appends it to the given buffer.
            fn read( &mut self, buf:&mut Vec<u8> ) -> io::Result<Option<RawRead>>;
            /// Waits `timeout` for user input. If `timeout` is `None`, waits indefinitely.
            fn wait_for_input( &mut self, timeout: Option<Duration> ) -> io::Result<bool>;
        }
        /// Holds a lock on `Terminal` write operations
        pub trait TerminalWriter<Term: Terminal>
        {
            /// Returns the size of the terminal window
            fn size( &self ) -> io::Result<Size>;
            /// Presents a clear terminal screen, with cursor at first row, first column.
            fn clear_screen( &mut self ) -> io::Result<()>;
            /// Clears characters on the line occupied by the cursor, beginning with the
            /// cursor and ending at the end of the line.
            fn clear_to_screen_end( &mut self ) -> io::Result<()>;
            /// Moves the cursor up `n` cells; `n` may be zero.
            fn move_up( &mut self, n: usize ) -> io::Result<()>;
            /// Moves the cursor down `n` cells; `n` may be zero.
            fn move_down( &mut self, n: usize ) -> io::Result<()>;
            /// Moves the cursor left `n` cells; `n` may be zero.
            fn move_left( &mut self, n: usize ) -> io::Result<()>;
            /// Moves the cursor right `n` cells; `n` may be zero.
            fn move_right( &mut self, n: usize ) -> io::Result<()>;
            /// Moves the cursor to the first column of the current line
            fn move_to_first_column( &mut self ) -> io::Result<()>;
            /// Set the current cursor mode
            fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()>;
            /// Writes output to the terminal.
            fn write( &mut self, s:&str ) -> io::Result<()>;
            /// Flushes any currently buffered output data.
            fn flush( &mut self ) -> io::Result<()>;
        }

        impl DefaultTerminal
        {
            /// Opens access to the terminal device associated with standard output.
            pub fn new() -> io::Result<DefaultTerminal> { system::common::Terminal::new().map( DefaultTerminal ) }
            /// Opens access to the terminal device associated with standard error.
            pub fn stderr() -> io::Result<DefaultTerminal>
            {
                system::common::Terminal::stderr().map( DefaultTerminal )
            }

            unsafe fn cast_writer<'a>( writer:&'a mut dyn TerminalWriter<Self> ) -> &'a mut TerminalWriteGuard<'a>
            {
                &mut *( writer as *mut _ as *mut TerminalWriteGuard )
            }
        }

        impl Terminal for DefaultTerminal
        {
            type PrepareState = PrepareState;

            fn name( &self ) -> &str { self.0.name() }

            fn lock_read<'a>( &'a self ) -> Box<dyn TerminalReader<Self> + 'a>
            {
                Box::new( self.0.lock_read().unwrap() )
            }

            fn lock_write<'a>( &'a self ) -> Box<dyn TerminalWriter<Self> + 'a>
            {
                Box::new( self.0.lock_write().unwrap() )
            }
        }

        impl<'a> TerminalReader<DefaultTerminal> for TerminalReadGuard<'a>
        {
            fn prepare( &mut self, block_signals: bool, report_signals: SignalSet ) -> io::Result<PrepareState>
            {
                self.prepare( PrepareConfig{
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                } )
            }

            unsafe fn prepare_with_lock
            ( 
                &mut self,
                lock:&mut dyn TerminalWriter<DefaultTerminal>,
                block_signals: bool, report_signals: SignalSet
            ) -> io::Result<PrepareState>
            {
                let lock = DefaultTerminal::cast_writer( lock );

                self.prepare_with_lock( lock, PrepareConfig
                {
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                } )
            }

            fn restore( &mut self, state: PrepareState ) -> io::Result<()> { self.restore( state ) }

            unsafe fn restore_with_lock
            ( 
                &mut self,
                lock:&mut dyn TerminalWriter<DefaultTerminal>,
                state: PrepareState
            ) -> io::Result<()>
            {
                let lock = DefaultTerminal::cast_writer( lock );
                self.restore_with_lock( lock, state )
            }

            fn read( &mut self, buf:&mut Vec<u8> ) -> io::Result<Option<RawRead>> 
            { 
                Ok( None )
                //terminal_read( self, buf )
            }

            fn wait_for_input( &mut self, timeout: Option<Duration> ) -> io::Result<bool> { self.wait_event( timeout ) }
        }

        impl<'a> TerminalWriter<DefaultTerminal> for TerminalWriteGuard<'a>
        {
            fn size( &self ) -> io::Result<Size> { self.size() }
            fn clear_screen( &mut self ) -> io::Result<()> { self.clear_screen() }
            fn clear_to_screen_end( &mut self ) -> io::Result<()> { self.clear_to_screen_end() }
            fn move_up( &mut self, n: usize ) -> io::Result<()> { self.move_up( n ) }
            fn move_down( &mut self, n: usize ) -> io::Result<()> { self.move_down( n ) }
            fn move_left( &mut self, n: usize ) -> io::Result<()> { self.move_left( n ) }
            fn move_right( &mut self, n: usize ) -> io::Result<()> { self.move_right( n ) }
            fn move_to_first_column( &mut self ) -> io::Result<()> { self.move_to_first_column() }
            fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> { self.set_cursor_mode( mode ) }
            fn write( &mut self, s:&str ) -> io::Result<()> { self.write_str( s ) }
            fn flush( &mut self ) -> io::Result<()> { self.flush() }
        }

        // Unfortunately the actual command is not standardised...
        #[cfg( any( target_os = "linux", target_os = "android" ) )]
        static TIOCGWINSZ: c_ulong = 0x5413;

        #[cfg( any(
            target_os = "macos",
            target_os = "ios",
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
         ) )]
        static TIOCGWINSZ: c_ulong = 0x40087468;

        #[cfg( target_os = "solaris" )]
        static TIOCGWINSZ: c_ulong = 0x5468;

        extern "C"
        {
            fn ioctl( fd: c_int, request: c_ulong, ...) -> c_int;
        }
        /// Runs the ioctl command.
        pub unsafe fn get_dimensions_any() -> winsize
        {
            let mut window: winsize = zeroed();
            let mut result = ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut window);

            if result == -1 {
                window = zeroed();
                result = ioctl(STDIN_FILENO, TIOCGWINSZ, &mut window);
                if result == -1 {
                    window = zeroed();
                    result = ioctl(STDERR_FILENO, TIOCGWINSZ, &mut window);
                    if result == -1 {
                        return zeroed();
                    }
                }
            }
            window
        }
        /// Query the current processes's output (`stdout`), input (`stdin`), and error (`stderr`) in
        /// that order, in the attempt to dtermine terminal width.
        pub fn dimensions() -> Option<(usize, usize )> {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 {
                None
            } else {
                Some((w.ws_col as usize, w.ws_row as usize  ) )
            }
        }
        // pub unsafe fn give_terminal_to(gid: i32) -> bool
        pub unsafe fn give_to(gid: i32) -> bool
        {
            let mut mask:SignalSet = mem::zeroed();
            let mut old_mask:SignalSet = mem::zeroed();

            sigemptyset( &mut mask );
            sigaddset( &mut mask, SIGTSTP );
            sigaddset( &mut mask, SIGTTIN );
            sigaddset( &mut mask, SIGTTOU );
            sigaddset( &mut mask, SIGCHLD );

            let rcode = pthread_sigmask(libc::SIG_BLOCK, &mask, &mut old_mask);
            
            if rcode != 0
            {
                //log!("failed to call pthread_sigmask");
            }
            
            let rcode = tcsetpgrp(1, gid);
            let given;

            if rcode == -1
            {
                given = false;
                let e = error::no::errno();
                let code = e.0;
                //log!("error in give_terminal_to() {}: {}", code, e);
            }            
            else { given = true; }
            
            let rcode = pthread_sigmask(libc::SIG_SETMASK, &old_mask, &mut mask);
            
            if rcode != 0
            {
                //log!("failed to call pthread_sigmask");
            }

            given
        }
    }

    pub mod variables
    {
        /*!
        Contains types associated with user-configurable variables. */
        use ::
        {
            borrow::{  Cow },
            mem::{ replace },
            time::std::{ Duration },
            *,
        };
        /*
        */
        /// Default `keyseq_timeout`, in milliseconds
        const KEYSEQ_TIMEOUT_MS: u64 = 500;
        /// Iterator over `Reader` variable values
        #[derive( Clone )]
        pub struct VariableIter<'a> {
            vars:&'a Variables,
            n: usize,
        }
        /// Represents a `Reader` variable of a given type
        #[derive( Clone, Debug )]
        pub enum Variable {
            /// Boolean variable
            Boolean( bool ),
            /// Integer variable
            Integer( i32 ),
            /// String variable
            String( Cow<'static, str> ),
        }

        impl From<bool> for Variable {
            fn from( b: bool ) -> Variable {
                Variable::Boolean( b )
            }
        }

        impl From<i32> for Variable {
            fn from( i: i32 ) -> Variable {
                Variable::Integer( i )
            }
        }

        impl From<&'static str> for Variable {
            fn from( s:&'static str ) -> Variable {
                Variable::String( s.into() )
            }
        }

        impl From<Cow<'static, str>> for Variable {
            fn from( s: Cow<'static, str> ) -> Variable {
                Variable::String( s )
            }
        }

        impl From<String> for Variable {
            fn from( s: String ) -> Variable {
                Variable::String( s.into() )
            }
        }

        impl fmt::Display for Variable {
            fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
                match *self {
                    Variable::Boolean( b ) => f.write_str( if b { "on" } else { "off" } ),
                    Variable::Integer( n ) => fmt::Display::fmt( &n, f ),
                    Variable::String( ref s ) => fmt::Display::fmt( &s[..], f ),
                }
            }
        }

        macro_rules! define_variables {
            ( $( $field:ident : $ty:ty => ( $name:expr , $conv:ident ,
                    |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr ) , )+ ) => {
                static VARIABLE_NAMES:&[&str] = &[ $( $name ),+ ];

                pub struct Variables {
                    $( pub $field : $ty ),*
                }

                impl Variables {
                    pub fn get_variable( &self, name:&str ) -> Option<Variable> {
                        match name {
                            $( $name => {
                                let $gr = self;
                                Some( Variable::from( $getter ) )
                            } )+
                            _ => None
                        }
                    }

                    pub fn set_variable( &mut self, name:&str, value:&str )
                            -> Option<Variable> {
                        match name {
                            $( $name => {
                                if let Some( $v ) = $conv( value ) {
                                    let $sr = self;
                                    Some( Variable::from( $setter ) )
                                } else {
                                    None
                                }
                            } )+
                            _ => None
                        }
                    }

                    pub fn iter( &self ) -> VariableIter {
                        VariableIter{vars: self, n: 0}
                    }
                }

                impl<'a> Iterator for VariableIter<'a> {
                    type Item = ( &'static str, Variable );

                    fn next( &mut self ) -> Option<Self::Item> {
                        let res = match VARIABLE_NAMES.get( self.n ).cloned() {
                            $( Some( $name ) => ( $name, {
                                let $gr = self.vars;
                                Variable::from( $getter )
                            } ) , )+
                            _ => return None
                        };

                        self.n += 1;
                        Some( res )
                    }
                }
            }
        }

        define_variables!{
            blink_matching_paren: bool => ( "blink-matching-paren", parse_bool,
                |r| r.blink_matching_paren,
                |r, v| replace( &mut r.blink_matching_paren, v ) ),
            comment_begin: Cow<'static, str> => ( "comment-begin", parse_string,
                |r| r.comment_begin.clone(),
                |r, v| replace( &mut r.comment_begin, v.into() ) ),
            completion_display_width: usize => ( "completion-display-width", parse_usize,
                |r| usize_as_i32( r.completion_display_width ),
                |r, v| usize_as_i32( replace( &mut r.completion_display_width, v ) ) ),
            completion_query_items: usize => ( "completion-query-items", parse_usize,
                |r| usize_as_i32( r.completion_query_items ),
                |r, v| usize_as_i32( replace( &mut r.completion_query_items, v ) ) ),
            disable_completion: bool => ( "disable-completion", parse_bool,
                |r| r.disable_completion,
                |r, v| replace( &mut r.disable_completion, v ) ),
            echo_control_characters: bool => ( "echo-control-characters", parse_bool,
                |r| r.echo_control_characters,
                |r, v| replace( &mut r.echo_control_characters, v ) ),
            keyseq_timeout: Option<Duration> => ( "keyseq-timeout", parse_duration,
                |r| as_millis( r.keyseq_timeout ),
                |r, v| as_millis( replace( &mut r.keyseq_timeout, v ) ) ),
            page_completions: bool => ( "page-completions", parse_bool,
                |r| r.page_completions,
                |r, v| replace( &mut r.page_completions, v ) ),
            print_completions_horizontally: bool => ( "print-completions-horizontally", parse_bool,
                |r| r.print_completions_horizontally,
                |r, v| replace( &mut r.print_completions_horizontally, v ) ),
        }

        impl Default for Variables {
            fn default() -> Variables {
                Variables{
                    blink_matching_paren: false,
                    comment_begin: "#".into(),
                    completion_display_width: usize::max_value(),
                    completion_query_items: 100,
                    disable_completion: false,
                    echo_control_characters: true,
                    keyseq_timeout: Some( Duration::from_millis( KEYSEQ_TIMEOUT_MS ) ),
                    page_completions: true,
                    print_completions_horizontally: false,
                }
            }
        }

        fn parse_bool( s:&str ) -> Option<bool> {
            match s {
                "0" => Some( false ),
                "1" => Some( true ),
                s if s.eq_ignore_ascii_case( "off" ) => Some( false ),
                s if s.eq_ignore_ascii_case( "on" ) => Some( true ),
                _ => None
            }
        }

        fn parse_string( s:&str ) -> Option<String> {
            Some( s.to_owned() )
        }

        fn as_millis( timeout: Option<Duration> ) -> i32 {
            match timeout {
                Some( t ) => {
                    let s = ( t.as_secs() * 1_000 ) as i32;
                    let ms = ( t.subsec_nanos() / 1_000_000 ) as i32;

                    s + ms
                }
                None => -1
            }
        }

        fn parse_duration( s:&str ) -> Option<Option<Duration>> {
            match s.parse::<i32>() {
                Ok( n ) if n <= 0 => Some( None ),
                Ok( n ) => Some( Some( Duration::from_millis( n as u64 ) ) ),
                Err( _ ) => Some( None )
            }
        }

        fn usize_as_i32( u: usize ) -> i32 {
            match u {
                u if u > i32::max_value() as usize => -1,
                u => u as i32
            }
        }

        fn parse_usize( s:&str ) -> Option<usize> {
            match s.parse::<i32>() {
                Ok( n ) if n < 0 => Some( usize::max_value() ),
                Ok( n ) => Some( n as usize ),
                Err( _ ) => None
            }
        }
    }

    pub mod writer
    {
        /*!
        Provides access to terminal write operations. */
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            char::{ unctrl, ESCAPE, RUBOUT },
            collections::{ vec_deque, VecDeque },
            iter::{ repeat, Skip },
            mem::{ swap },
            ops::{ Deref, DerefMut, Range },
            sync::{ MutexGuard },
            system::
            {
                reader::{START_INVISIBLE, END_INVISIBLE},
                terminal::{CursorMode, Size, Terminal, TerminalWriter},
            },
            time::std::{ Duration, Instant },
            *,
        };
        /*
        */
        /// Duration to wait for input when "blinking"
        pub const BLINK_DURATION: Duration = Duration::from_millis( 500 );

        const COMPLETE_MORE:&'static str = "--More--";
        /// Default maximum history size
        const MAX_HISTORY: usize = !0;
        /// Tab column interval
        const TAB_STOP: usize = 8;        
        const PROMPT_NUM_PREFIX: usize = 6;
        const PROMPT_NUM_SUFFIX: usize = 2;
        const PROMPT_SEARCH_PREFIX: usize = 11;
        const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
        const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
        const PROMPT_SEARCH_SUFFIX: usize = 3;
        /// Provides an interface to write line-by-line output to the terminal device.
        pub struct Writer<'a, 'b: 'a, Term: 'b + Terminal> 
        {
            write: WriterImpl<'a, 'b, Term>,
        }

        enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminal> 
        {
            Mutex( WriteLock<'b, Term> ),
            MutRef( &'a mut WriteLock<'b, Term> ),
        }

        pub struct Write 
        {
            /// Input buffer
            pub buffer: String,
            /// Original buffer entered before searching through history
            pub backup_buffer: String,
            /// Position of the cursor
            pub cursor: usize,
            /// Position of the cursor if currently performing a blink
            blink: Option<Blink>,

            /// Stored history entries
            pub history: VecDeque<String>,
            /// History entry currently being edited;.
            pub history_index: Option<usize>,
            /// Maximum size of history
            history_size: usize,
            /// Number of history entries added since last loading history
            history_new_entries: usize,

            /// Whether the prompt is drawn; i.e. a `read_line` operation is in progress
            pub is_prompt_drawn: bool,

            /// Portion of prompt up to and including the final newline
            pub prompt_prefix: String,
            prompt_prefix_len: usize,
            /// Portion of prompt after the final newline
            pub prompt_suffix: String,
            prompt_suffix_len: usize,

            /// Current type of prompt
            pub prompt_type: PromptType,

            /// Whether a search in progress is a reverse search
            pub reverse_search: bool,
            /// Whether a search in progress has failed to find a match
            pub search_failed: bool,
            /// Current search string
            pub search_buffer: String,
            /// Last search string
            pub last_search: String,
            /// Selected history entry prior to a history search
            pub prev_history: Option<usize>,
            /// Position of the cursor prior to a history search
            pub prev_cursor: usize,

            /// Numerical argument
            pub input_arg: Digit,
            /// Whether a numerical argument was supplied
            pub explicit_arg: bool,

            /// Terminal size as of last draw operation
            pub screen_size: Size,
        }

        pub struct WriteLock<'a, Term: 'a + Terminal> 
        {
            term: Box<dyn TerminalWriter<Term> + 'a>,
            data: MutexGuard<'a, Write>,
        }

        impl<'a, Term: Terminal> WriteLock<'a, Term> 
        {
            pub fn new( term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write> )
                    -> WriteLock<'a, Term> {
                WriteLock{term, data}
            }

            pub fn size( &self ) -> io::Result<Size> {
                self.term.size()
            }

            pub fn flush( &mut self ) -> io::Result<()> {
                self.term.flush()
            }

            pub fn update_size( &mut self ) -> io::Result<()> {
                let size = self.size()?;
                self.screen_size = size;
                Ok( () )
            }

            pub fn blink( &mut self, pos: usize ) -> io::Result<()> {
                self.expire_blink()?;

                let orig = self.cursor;
                self.move_to( pos )?;
                self.cursor = orig;

                let expiry = Instant::now() + BLINK_DURATION;

                self.blink = Some( Blink{
                    pos,
                    expiry,
                } );

                Ok( () )
            }

            pub fn check_expire_blink( &mut self, now: Instant ) -> io::Result<bool> {
                if let Some( blink ) = self.data.blink {
                    if now >= blink.expiry {
                        self.expire_blink()?;
                    }
                }

                Ok( self.blink.is_none() )
            }

            pub fn expire_blink( &mut self ) -> io::Result<()> {
                if let Some( blink ) = self.data.blink.take() {
                    self.move_from( blink.pos )?;
                }

                Ok( () )
            }

            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> {
                self.expire_blink()?;

                let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                if redraw {
                    self.clear_full_prompt()?;
                }

                self.data.set_prompt( prompt );

                if redraw {
                    self.draw_prompt()?;
                }

                Ok( () )
            }
            /// Draws the prompt and current input, assuming the cursor is at column 0
            pub fn draw_prompt( &mut self ) -> io::Result<()> {
                self.draw_prompt_prefix()?;
                self.draw_prompt_suffix()
            }

            pub fn draw_prompt_prefix( &mut self ) -> io::Result<()> {
                match self.prompt_type {
                    // Prefix is not drawn when completions are shown
                    PromptType::CompleteMore => Ok( () ),
                    _ => {
                        let pfx = self.prompt_prefix.clone();
                        self.draw_raw_prompt( &pfx )
                    }
                }
            }

            pub fn draw_prompt_suffix( &mut self ) -> io::Result<()> {
                match self.prompt_type {
                    PromptType::Normal => {
                        let sfx = self.prompt_suffix.clone();
                        self.draw_raw_prompt( &sfx )?;
                    }
                    PromptType::Number => {
                        let n = self.input_arg.to_i32();
                        let s = format!( "( arg: {} ) ", n );
                        self.draw_text( 0, &s )?;
                    }
                    PromptType::Search => {
                        let pre = match ( self.reverse_search, self.search_failed ) {
                            ( false, false ) => "( i-search )",
                            ( false, true )  => "( failed i-search )",
                            ( true,  false ) => "( reverse-i-search )",
                            ( true,  true )  => "( failed reverse-i-search )",
                        };

                        let ent = self.get_history( self.history_index ).to_owned();
                        let s = format!( "{}`{}': {}", pre, self.search_buffer, ent );

                        self.draw_text( 0, &s )?;
                        let pos = self.cursor;

                        let ( lines, cols ) = self.move_delta( ent.len(), pos, &ent );
                        return self.move_rel( lines, cols );
                    }
                    PromptType::CompleteIntro( n ) => {
                        return self.term.write( &complete_intro( n ) );
                    }
                    PromptType::CompleteMore => {
                        return self.term.write( COMPLETE_MORE );
                    }
                }

                self.draw_buffer( 0 )?;
                let len = self.buffer.len();
                self.move_from( len )
            }

            pub fn redraw_prompt( &mut self, new_prompt: PromptType ) -> io::Result<()> {
                self.clear_prompt()?;
                self.prompt_type = new_prompt;
                self.draw_prompt_suffix()
            }
            /// Draws a portion of the buffer, starting from the given cursor position
            pub fn draw_buffer( &mut self, pos: usize ) -> io::Result<()> {
                let ( _, col ) = self.line_col( pos );

                let buf = self.buffer[pos..].to_owned();
                self.draw_text( col, &buf )?;
                Ok( () )
            }
            /// Draw some text with the cursor beginning at the given column.
            fn draw_text( &mut self, start_col: usize, text:&str ) -> io::Result<()> {
                self.draw_text_impl( start_col, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                }, false )
            }

            fn draw_raw_prompt( &mut self, text:&str ) -> io::Result<()> {
                self.draw_text_impl( 0, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    allow_escape: true,
                }, true )
            }

            fn draw_text_impl( &mut self, start_col: usize, text:&str, disp: Display,
                    handle_invisible: bool ) -> io::Result<()> {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let mut out = String::with_capacity( text.len() );

                let mut clear = false;
                let mut hidden = false;

                for ch in text.chars() 
                {
                    if handle_invisible && ch == START_INVISIBLE { hidden = true; }
                    
                    else if handle_invisible && ch == END_INVISIBLE { hidden = false; }

                    else if hidden { out.push( ch ); }

                    else
                    {
                        for ch in display( ch, disp )
                        {
                            if ch == '\t'
                            {
                                let n = TAB_STOP - ( col % TAB_STOP );
                                
                                if col + n > width
                                {
                                    let pre = width - col;
                                    out.extend( repeat( ' ' ).take( pre ) );
                                    out.push_str( " \r" );
                                    out.extend( repeat( ' ' ).take( n - pre ) );
                                    col = n - pre;
                                }
                                
                                else
                                {
                                    out.extend( repeat( ' ' ).take( n ) );
                                    col += n;

                                    if col == width 
                                    {
                                        out.push_str( " \r" );
                                        col = 0;
                                    }
                                }
                            }
                            
                            else if ch == '\n' 
                            {
                                if !clear 
                                {
                                    self.term.write( &out )?;
                                    out.clear();
                                    self.term.clear_to_screen_end()?;
                                    clear = true;
                                }

                                out.push( '\n' );
                                col = 0;
                            }
                            
                            else if is::combining_mark( ch ) { out.push( ch ); }
                            
                            else if is::wide( ch ) 
                            {
                                if col == width - 1 
                                {
                                    out.push_str( "  \r" );
                                    out.push( ch );
                                    col = 2;
                                }

                                else 
                                {
                                    out.push( ch );
                                    col += 2;
                                }
                            }
                            
                            else 
                            {
                                out.push( ch );
                                col += 1;

                                if col == width 
                                {
                                    out.push_str( " \r" );
                                    col = 0;
                                }
                            }
                        }
                    }
                }

                if col == width {
                    out.push_str( " \r" );
                }

                self.term.write( &out )
            }

            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> {
                self.expire_blink()?;

                self.move_to( 0 )?;
                self.buffer.clear();
                self.buffer.push_str( buf );
                self.new_buffer()
            }

            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> {
                self.expire_blink()?;

                if !self.buffer.is_char_boundary( pos ) {
                    panic!( "invalid cursor position {} in buffer {:?}",
                        pos, self.buffer );
                }

                self.move_to( pos )
            }

            pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> {
                self.term.set_cursor_mode( mode )
            }

            pub fn history_len( &self ) -> usize {
                self.history.len()
            }

            pub fn history_size( &self ) -> usize {
                self.history_size
            }

            pub fn set_history_size( &mut self, n: usize ) {
                self.history_size = n;
                self.truncate_history( n );
            }

            pub fn write_str( &mut self, s:&str ) -> io::Result<()> {
                self.term.write( s )
            }

            pub fn start_history_search( &mut self, reverse: bool ) -> io::Result<()> {
                self.search_buffer = self.buffer[..self.cursor].to_owned();

                self.continue_history_search( reverse )
            }

            pub fn continue_history_search( &mut self, reverse: bool ) -> io::Result<()> {
                if let Some( idx ) = self.find_history_search( reverse ) {
                    self.set_history_entry( Some( idx ) );

                    let pos = self.cursor;
                    let end = self.buffer.len();

                    self.draw_buffer( pos )?;
                    self.clear_to_screen_end()?;
                    self.move_from( end )?;
                }

                Ok( () )
            }

            fn find_history_search( &self, reverse: bool ) -> Option<usize> {
                let len = self.history.len();
                let idx = self.history_index.unwrap_or( len );

                if reverse {
                    self.history.iter().rev().skip( len - idx )
                        .position( |ent| ent.starts_with( &self.search_buffer ) )
                        .map( |pos| idx - ( pos + 1 ) )
                } else {
                    self.history.iter().skip( idx + 1 )
                        .position( |ent| ent.starts_with( &self.search_buffer ) )
                        .map( |pos| idx + ( pos + 1 ) )
                }
            }

            pub fn start_search_history( &mut self, reverse: bool ) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;
                self.search_buffer.clear();
                self.prev_history = self.history_index;
                self.prev_cursor = self.cursor;

                self.redraw_prompt( PromptType::Search )
            }

            pub fn continue_search_history( &mut self, reverse: bool ) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;

                {
                    let data = &mut *self.data;
                    data.search_buffer.clone_from( &data.last_search );
                }

                self.search_history_step()
            }

            pub fn end_search_history( &mut self ) -> io::Result<()> {
                self.redraw_prompt( PromptType::Normal )
            }

            pub fn abort_search_history( &mut self ) -> io::Result<()> {
                self.clear_prompt()?;

                let ent = self.prev_history;
                self.set_history_entry( ent );
                self.cursor = self.prev_cursor;

                self.prompt_type = PromptType::Normal;
                self.draw_prompt_suffix()
            }

            fn show_search_match( &mut self, next_match: Option<( Option<usize>, usize )> )
                    -> io::Result<()> {
                self.clear_prompt()?;

                if let Some( ( idx, pos ) ) = next_match {
                    self.search_failed = false;
                    self.set_history_entry( idx );
                    self.cursor = pos;
                } else {
                    self.search_failed = true;
                }

                self.prompt_type = PromptType::Search;
                self.draw_prompt_suffix()
            }

            pub fn search_history_update( &mut self ) -> io::Result<()> {
                let next_match = if self.reverse_search {
                    self.search_history_backward( &self.search_buffer, true )
                } else {
                    self.search_history_forward( &self.search_buffer, true )
                };

                self.show_search_match( next_match )
            }

            fn search_history_step( &mut self ) -> io::Result<()> {
                if self.search_buffer.is_empty() {
                    return self.redraw_prompt( PromptType::Search );
                }
                
                let next_match = if self.reverse_search {
                    self.search_history_backward( &self.search_buffer, false )
                } else {
                    self.search_history_forward( &self.search_buffer, false )
                };

                self.show_search_match( next_match )
            }

            fn search_history_backward( &self, s:&str, include_cur: bool )
                    -> Option<( Option<usize>, usize )> {
                let mut idx = self.history_index;
                let mut pos = Some( self.cursor );

                if include_cur && !self.search_failed {
                    if let Some( p ) = pos {
                        if self.get_history( idx ).is_char_boundary( p + s.len() ) {
                            pos = Some( p + s.len() );
                        }
                    }
                }

                loop {
                    let line = self.get_history( idx );

                    match line[..pos.unwrap_or( line.len() )].rfind( s ) {
                        Some( found ) => {
                            pos = Some( found );
                            break;
                        }
                        None => {
                            match idx {
                                Some( 0 ) => return None,
                                Some( n ) => {
                                    idx = Some( n - 1 );
                                    pos = None;
                                }
                                None => {
                                    if self.history.is_empty() {
                                        return None;
                                    } else {
                                        idx = Some( self.history.len() - 1 );
                                        pos = None;
                                    }
                                }
                            }
                        }
                    }
                }

                pos.map( |pos| ( idx, pos ) )
            }

            fn search_history_forward( &self, s:&str, include_cur: bool )
                    -> Option<( Option<usize>, usize )> {
                let mut idx = self.history_index;
                let mut pos = Some( self.cursor );

                if !include_cur {
                    if let Some( p ) = pos {
                        pos = Some( char::forward( 1, self.get_history( idx ), p ) );
                    }
                }

                loop {
                    let line = self.get_history( idx );

                    match line[pos.unwrap_or( 0 )..].find( s ) {
                        Some( found ) => {
                            pos = pos.map( |n| n + found ).or( Some( found ) );
                            break;
                        }
                        None => {
                            if let Some( n ) = idx {
                                if n + 1 == self.history.len() {
                                    idx = None;
                                } else {
                                    idx = Some( n + 1 );
                                }
                                pos = None;
                            } else {
                                return None;
                            }
                        }
                    }
                }

                pos.map( |pos| ( idx, pos ) )
            }

            pub fn add_history( &mut self, line: String ) {
                if self.history.len() == self.history_size {
                    self.history.pop_front();
                }

                self.history.push_back( line );
                self.history_new_entries = self.history.len()
                    .min( self.history_new_entries + 1 );
            }

            pub fn add_history_unique( &mut self, line: String ) {
                let is_duplicate = self.history.back().map_or( false, |ent| *ent == line );

                if !is_duplicate {
                    self.add_history( line );
                }
            }

            pub fn clear_history( &mut self ) {
                self.truncate_history( 0 );
                self.history_new_entries = 0;
            }

            pub fn remove_history( &mut self, n: usize ) {
                if n < self.history.len() {
                    let first_new = self.history.len() - self.history_new_entries;

                    if n >= first_new {
                        self.history_new_entries -= 1;
                    }

                    self.history.remove( n );
                }
            }

            pub fn truncate_history( &mut self, n: usize ) {
                let len = self.history.len();

                if n < len {
                    let _ = self.history.drain( ..len - n );
                    self.history_new_entries = self.history_new_entries.max( n );
                }
            }

            pub fn next_history( &mut self, n: usize ) -> io::Result<()> {
                if let Some( old ) = self.history_index {
                    let new = old.saturating_add( n );

                    if new >= self.history.len() {
                        self.select_history_entry( None )?;
                    } else {
                        self.select_history_entry( Some( new ) )?;
                    }
                }

                Ok( () )
            }

            pub fn prev_history( &mut self, n: usize ) -> io::Result<()> {
                if !self.history.is_empty() && self.history_index != Some( 0 ) {
                    let new = if let Some( old ) = self.history_index {
                        old.saturating_sub( n )
                    } else {
                        self.history.len().saturating_sub( n )
                    };

                    self.select_history_entry( Some( new ) )?;
                }

                Ok( () )
            }

            pub fn select_history_entry( &mut self, new: Option<usize> ) -> io::Result<()> {
                if new != self.history_index {
                    self.move_to( 0 )?;
                    self.set_history_entry( new );
                    self.new_buffer()?;
                }

                Ok( () )
            }

            pub fn set_history_entry( &mut self, new: Option<usize> ) {
                let old = self.history_index;

                if old != new {
                    let data = &mut *self.data;
                    data.history_index = new;

                    if let Some( old ) = old {
                        data.history[old].clone_from( &data.buffer );
                    } else {
                        swap( &mut data.buffer, &mut data.backup_buffer );
                    }

                    if let Some( new ) = new {
                        data.buffer.clone_from( &data.history[new] );
                    } else {
                        data.buffer.clear();
                        swap( &mut data.buffer, &mut data.backup_buffer );
                    }
                }
            }

            fn get_history( &self, n: Option<usize> ) -> &str {
                if self.history_index == n {
                    &self.buffer
                } else if let Some( n ) = n {
                    &self.history[n]
                } else {
                    &self.backup_buffer
                }
            }

            pub fn backward_char( &mut self, n: usize ) -> io::Result<()> {
                let pos = char::backward( n, &self.buffer, self.cursor );
                self.move_to( pos )
            }

            pub fn forward_char( &mut self, n: usize ) -> io::Result<()> {
                let pos = char::forward( n, &self.buffer, self.cursor );
                self.move_to( pos )
            }

            pub fn backward_search_char( &mut self, n: usize, ch:char ) -> io::Result<()> {
                if let Some( pos ) = char::backward_search( n, &self.buffer, self.cursor, ch ) {
                    self.move_to( pos )?;
                }

                Ok( () )
            }

            pub fn forward_search_char( &mut self, n: usize, ch:char ) -> io::Result<()> {
                if let Some( pos ) = char::forward_search( n, &self.buffer, self.cursor, ch ) {
                    self.move_to( pos )?;
                }

                Ok( () )
            }
            /// Deletes a range from buffer; the cursor is moved to the end of the given range.
            pub fn delete_range<R:ops::RangeArgument<usize>>( &mut self, r: R ) -> io::Result<()>
            {
                let start = r.start().cloned().unwrap_or( 0 );
                let end = r.end().cloned().unwrap_or_else( || self.buffer.len() );

                self.move_to( start )?;

                let _ = self.buffer.drain( start..end );

                self.draw_buffer( start )?;
                self.term.clear_to_screen_end()?;
                let len = self.buffer.len();
                self.move_from( len )?;

                Ok( () )
            }

            pub fn insert_str( &mut self, s:&str ) -> io::Result<()> 
            {
                let moves_combining = match self.buffer[self.cursor..].chars().next() {
                    Some( ch ) if is::combining_mark( ch ) => true,
                    _ => false
                };

                let cursor = self.cursor;
                self.buffer.insert_str( cursor, s );

                if moves_combining && cursor != 0 {
                    let pos = char::backward( 1, &self.buffer, self.cursor );
                    let ( lines, cols ) = self.move_delta( cursor, pos, &self.buffer );
                    self.move_rel( lines, cols )?;
                    self.draw_buffer( pos )?;
                } else {
                    self.draw_buffer( cursor )?;
                }

                self.cursor += s.len();

                let len = self.buffer.len();
                self.move_from( len )
            }

            pub fn transpose_range( &mut self, src: Range<usize>, dest: Range<usize> )
            -> io::Result<()> 
            {
                assert!( src.end <= dest.start || src.start >= dest.end );
                
                let final_cur = if src.start < dest.start {
                    dest.end
                } else {
                    dest.start + ( src.end - src.start )
                };

                let ( left, right ) = if src.start < dest.start {
                    ( src, dest )
                } else {
                    ( dest, src )
                };

                self.move_to( left.start )?;

                let a = self.buffer[left.clone()].to_owned();
                let b = self.buffer[right.clone()].to_owned();

                let _ = self.buffer.drain( right.clone() );
                self.buffer.insert_str( right.start, &a );

                let _ = self.buffer.drain( left.clone() );
                self.buffer.insert_str( left.start, &b );

                let cursor = self.cursor;
                self.draw_buffer( cursor )?;
                self.term.clear_to_screen_end()?;

                self.cursor = final_cur;
                let len = self.buffer.len();
                self.move_from( len )
            }

            fn prompt_suffix_length( &self ) -> usize {
                match self.prompt_type {
                    PromptType::Normal => self.prompt_suffix_len,
                    PromptType::Number => {
                        let n = number_len( self.input_arg.to_i32() );
                        PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                    }
                    PromptType::Search => {
                        let mut prefix = PROMPT_SEARCH_PREFIX;

                        if self.reverse_search {
                            prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                        }
                        if self.search_failed {
                            prefix += PROMPT_SEARCH_FAILED_PREFIX;
                        }

                        let n = self.display_size( &self.search_buffer, prefix );
                        prefix + n + PROMPT_SEARCH_SUFFIX
                    }
                    PromptType::CompleteIntro( n ) => complete_intro( n ).len(),
                    PromptType::CompleteMore => COMPLETE_MORE.len(),
                }
            }

            fn line_col( &self, pos: usize ) -> ( usize, usize ) {
                let prompt_len = self.prompt_suffix_length();

                match self.prompt_type {
                    PromptType::CompleteIntro( _ ) |
                    PromptType::CompleteMore => {
                        let width = self.screen_size.columns;
                        ( prompt_len / width, prompt_len % width )
                    }
                    _ => self.line_col_with( pos, &self.buffer, prompt_len )
                }
            }

            fn line_col_with( &self, pos: usize, buf:&str, start_col: usize ) -> ( usize, usize ) {
                let width = self.screen_size.columns;
                if width == 0 {
                    return ( 0, 0 );
                }

                let n = start_col + self.display_size( &buf[..pos], start_col );

                ( n / width, n % width )
            }

            pub fn clear_screen( &mut self ) -> io::Result<()> {
                self.term.clear_screen()?;
                self.draw_prompt()?;

                Ok( () )
            }

            pub fn clear_to_screen_end( &mut self ) -> io::Result<()> {
                self.term.clear_to_screen_end()
            }
            /// Draws a new buffer on the screen. Cursor position is assumed to be `0`.
            pub fn new_buffer( &mut self ) -> io::Result<()> {
                self.draw_buffer( 0 )?;
                self.cursor = self.buffer.len();

                self.term.clear_to_screen_end()?;

                Ok( () )
            }

            pub fn clear_full_prompt( &mut self ) -> io::Result<()> {
                let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                let ( line, _ ) = self.line_col( self.cursor );
                self.term.move_up( prefix_lines + line )?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub fn clear_prompt( &mut self ) -> io::Result<()> {
                let ( line, _ ) = self.line_col( self.cursor );

                self.term.move_up( line )?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }
            /// Move back to true cursor position from some other position
            pub fn move_from( &mut self, pos: usize ) -> io::Result<()> {
                let ( lines, cols ) = self.move_delta( pos, self.cursor, &self.buffer );
                self.move_rel( lines, cols )
            }

            pub fn move_to( &mut self, pos: usize ) -> io::Result<()> {
                if pos != self.cursor {
                    let ( lines, cols ) = self.move_delta( self.cursor, pos, &self.buffer );
                    self.move_rel( lines, cols )?;
                    self.cursor = pos;
                }

                Ok( () )
            }

            pub fn move_to_end( &mut self ) -> io::Result<()> {
                let pos = self.buffer.len();
                self.move_to( pos )
            }

            pub fn move_right( &mut self, n: usize ) -> io::Result<()> {
                self.term.move_right( n )
            }
            /// Moves from `old` to `new` cursor position, using the given buffer
            /// as current input.
            fn move_delta( &self, old: usize, new: usize, buf:&str ) -> ( isize, isize ) {
                let prompt_len = self.prompt_suffix_length();
                let ( old_line, old_col ) = self.line_col_with( old, buf, prompt_len );
                let ( new_line, new_col ) = self.line_col_with( new, buf, prompt_len );

                ( new_line as isize - old_line as isize,
                new_col as isize - old_col as isize )
            }

            fn move_rel( &mut self, lines: isize, cols: isize ) -> io::Result<()> {
                if lines > 0 {
                    self.term.move_down( lines as usize )?;
                } else if lines < 0 {
                    self.term.move_up( ( -lines ) as usize )?;
                }

                if cols > 0 {
                    self.term.move_right( cols as usize )?;
                } else if cols < 0 {
                    self.term.move_left( ( -cols ) as usize )?;
                }

                Ok( () )
            }

            pub fn reset_data( &mut self ) {
                self.data.reset_data();
            }

            pub fn set_digit_from_char( &mut self, ch:char ) {
                let digit = match ch {
                    '-' => Digit::NegNone,
                    '0' ..= '9' => Digit::from( ch ),
                    _ => Digit::None
                };

                self.input_arg = digit;
                self.explicit_arg = true;
            }
        }

        #[derive( Copy, Clone )]
        struct Blink 
        {
            pos: usize,
            expiry: Instant,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Writer<'a, 'b, Term> 
        {
            fn new( mut write: WriterImpl<'a, 'b, Term>, clear: bool ) -> io::Result<Self> {
                write.expire_blink()?;

                if write.is_prompt_drawn {
                    if clear {
                        write.clear_full_prompt()?;
                    } else {
                        write.move_to_end()?;
                        write.write_str( "\n" )?;
                    }
                }

                Ok( Writer{write} )
            }

            pub fn with_lock( write: WriteLock<'b, Term>, clear: bool ) -> io::Result<Self> {
                Writer::new( WriterImpl::Mutex( write ), clear )
            }

            pub fn with_ref( write:&'a mut WriteLock<'b, Term>, clear: bool ) -> io::Result<Self> {
                Writer::new( WriterImpl::MutRef( write ), clear )
            }
            /// Returns an iterator over history entries.
            pub fn history( &self ) -> HistoryIter {
                self.write.history()
            }
            /// Writes some text to the terminal device.
            pub fn write_str( &mut self, s:&str ) -> io::Result<()> {
                self.write.write_str( s )
            }
            /// Writes formatted text to the terminal display.
            pub fn write_fmt( &mut self, args: fmt::Arguments ) -> io::Result<()> {
                let s = args.to_string();
                self.write_str( &s )
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Drop for Writer<'a, 'b, Term> 
        {
            fn drop( &mut self ) {
                if self.write.is_prompt_drawn {
                    let _ = self.write.draw_prompt();
                }
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for WriteLock<'a, Term> 
        {
            type Target = Write;

            fn deref( &self ) -> &Write {
                &self.data
            }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for WriteLock<'a, Term> 
        {
            fn deref_mut( &mut self ) -> &mut Write {
                &mut self.data
            }
        }

        impl Write 
        {
            pub fn new( screen_size: Size ) -> Write {
                Write{
                    buffer: String::new(),
                    backup_buffer: String::new(),
                    cursor: 0,
                    blink: None,

                    history: VecDeque::new(),
                    history_index: None,
                    history_size: MAX_HISTORY,
                    history_new_entries: 0,

                    is_prompt_drawn: false,

                    prompt_prefix: String::new(),
                    prompt_prefix_len: 0,
                    prompt_suffix: String::new(),
                    prompt_suffix_len: 0,

                    prompt_type: PromptType::Normal,

                    reverse_search: false,
                    search_failed: false,
                    search_buffer: String::new(),
                    last_search: String::new(),
                    prev_history: None,
                    prev_cursor: !0,

                    input_arg: Digit::None,
                    explicit_arg: false,

                    screen_size,
                }
            }

            pub fn history( &self ) -> HistoryIter {
                HistoryIter( self.history.iter() )
            }

            pub fn new_history( &self ) -> Skip<HistoryIter> {
                let first_new = self.history.len() - self.history_new_entries;
                self.history().skip( first_new )
            }

            pub fn new_history_entries( &self ) -> usize {
                self.history_new_entries
            }

            pub fn reset_data( &mut self ) {
                self.buffer.clear();
                self.backup_buffer.clear();
                self.cursor = 0;
                self.history_index = None;

                self.prompt_type = PromptType::Normal;

                self.input_arg = Digit::None;
                self.explicit_arg = false;
            }

            pub fn reset_new_history( &mut self ) {
                self.history_new_entries = 0;
            }

            pub fn set_buffer( &mut self, buf:&str ) {
                self.buffer.clear();
                self.buffer.push_str( buf );
                self.cursor = buf.len();
            }

            pub fn set_cursor( &mut self, pos: usize ) {
                if !self.buffer.is_char_boundary( pos ) {
                    panic!( "invalid cursor position {} in buffer {:?}",
                        pos, self.buffer );
                }

                self.cursor = pos;
            }

            pub fn set_prompt( &mut self, prompt:&str ) {
                let ( pre, suf ) = match prompt.rfind( '\n' ) {
                    Some( pos ) => ( &prompt[..pos + 1], &prompt[pos + 1..] ),
                    None => ( &prompt[..0], prompt )
                };

                self.prompt_prefix = pre.to_owned();
                self.prompt_suffix = suf.to_owned();

                let pre_virt = str::filter_visible( pre );
                self.prompt_prefix_len = self.display_size( &pre_virt, 0 );

                let suf_virt = str::filter_visible( suf );
                self.prompt_suffix_len = self.display_size( &suf_virt, 0 );
            }

            pub fn display_size( &self, s:&str, start_col: usize ) -> usize 
            {
                let width = self.screen_size.columns;
                let mut col = start_col;

                let disp = Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                };

                for ch in s.chars().flat_map( |ch| display( ch, disp ) ) 
                {
                    let n = match ch {
                        '\n' => width - ( col % width ),
                        '\t' => TAB_STOP - ( col % TAB_STOP ),
                        ch if is::combining_mark( ch ) => 0,
                        ch if is::wide( ch ) => {
                            if col % width == width - 1 {
                                3
                            } else {
                                2
                            }
                        }
                        _ => 1
                    };

                    col += n;
                }

                col - start_col
            }
        }
        /// Maximum value of digit input
        const NUMBER_MAX: i32 = 1_000_000;

        #[derive( Copy, Clone, Debug )]
        pub enum Digit 
        {
            None,
            NegNone,
            Num( i32 ),
            NegNum( i32 ),
        }

        impl Digit 
        {
            pub fn input( &mut self, n: i32 ) {
                match *self {
                    Digit::None => *self = Digit::Num( n ),
                    Digit::NegNone => *self = Digit::NegNum( n ),
                    Digit::Num( ref mut m ) | Digit::NegNum( ref mut m ) => {
                        *m *= 10;
                        *m += n;
                    }
                }
            }

            pub fn is_out_of_bounds( &self ) -> bool {
                match *self {
                    Digit::Num( n ) | Digit::NegNum( n ) if n > NUMBER_MAX => true,
                    _ => false
                }
            }

            pub fn to_i32( &self ) -> i32 {
                match *self {
                    Digit::None => 1,
                    Digit::NegNone => -1,
                    Digit::Num( n ) => n,
                    Digit::NegNum( n ) => -n,
                }
            }
        }

        impl From<char> for Digit 
        {
            /// Convert a decimal digit character to a `Digit` value.
            ///
            /// The input must be in the range `'0' ..= '9'`.
            fn from( ch:char ) -> Digit {
                let n = ( ch as u8 ) - b'0';
                Digit::Num( n as i32 )
            }
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum PromptType 
        {
            Normal,
            Number,
            Search,
            CompleteIntro( usize ),
            CompleteMore,
        }

        impl PromptType 
        {
            pub fn is_normal( &self ) -> bool {
                *self == PromptType::Normal
            }
        }

        impl<'a, 'b, Term: 'b + Terminal> Deref for WriterImpl<'a, 'b, Term> 
        {
            type Target = WriteLock<'b, Term>;

            fn deref( &self ) -> &WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex( ref m ) => m,
                    WriterImpl::MutRef( ref m ) => m,
                }
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> DerefMut for WriterImpl<'a, 'b, Term> 
        {
            fn deref_mut( &mut self ) -> &mut WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex( ref mut m ) => m,
                    WriterImpl::MutRef( ref mut m ) => m,
                }
            }
        }
        /// Iterator over `Interface` history entries
        pub struct HistoryIter<'a>( vec_deque::Iter<'a, String> );

        impl<'a> ExactSizeIterator for HistoryIter<'a> {}

        impl<'a> Iterator for HistoryIter<'a> 
        {
            type Item = &'a str;

            #[inline] fn next( &mut self ) -> Option<&'a str> { self.0.next().map( |s| &s[..] ) }

            #[inline] fn nth( &mut self, n: usize ) -> Option<&'a str> 
            { self.0.nth( n ).map( |s| &s[..] ) }

            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.0.size_hint() }
        }

        impl<'a> DoubleEndedIterator for HistoryIter<'a> 
        {
            #[inline] fn next_back( &mut self ) -> Option<&'a str>
            { self.0.next_back().map( |s| &s[..] ) }
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum DisplaySequence 
        {
            Char( char ),
            Escape( char ),
            End,
        }

        impl Iterator for DisplaySequence 
        {
            type Item = char;

            fn next( &mut self ) -> Option<char> {
                use self::DisplaySequence::*;

                let ( res, next ) = match *self {
                    Char( ch ) => ( ch, End ),
                    Escape( ch ) => ( '^', Char( ch ) ),
                    End => return None
                };

                *self = next;
                Some( res )
            }

            fn size_hint( &self ) -> ( usize, Option<usize> ) 
            {
                use self::DisplaySequence::*;

                let n = match *self {
                    Char( _ ) => 1,
                    Escape( _ ) => 2,
                    End => 0,
                };

                ( n, Some( n ) )
            }
        }

        #[derive( Copy, Clone, Debug, Default )]
        pub struct Display 
        {
            allow_tab: bool,
            allow_newline: bool,
            allow_escape: bool,
        }

        pub fn display( ch:char, style: Display ) -> DisplaySequence 
        {
            match ch 
            {
                '\t' if style.allow_tab => DisplaySequence::Char( ch ),
                '\n' if style.allow_newline => DisplaySequence::Char( ch ),
                ESCAPE if style.allow_escape => DisplaySequence::Char( ch ),
                '\0' => DisplaySequence::Escape( '@' ),
                RUBOUT => DisplaySequence::Escape( '?' ),
                ch if is::control( ch ) => DisplaySequence::Escape( unctrl( ch ) ),
                ch => DisplaySequence::Char( ch )
            }
        }

        pub fn display_str<'a>( s:&'a str, style: Display ) -> Cow<'a, str> 
        {
            if s.chars().all( |ch| display( ch, style ) == DisplaySequence::Char( ch ) ) {
                Borrowed( s )
            } else {
                Owned( s.chars().flat_map( |ch| display( ch, style ) ).collect() )
            }
        }

        fn complete_intro( n: usize ) -> String { format!( "Display all {} possibilities? ( y/n )", n ) }

        fn number_len( n: i32 ) -> usize
        {
            match n
            {
                -1_000_000              => 8,
                -  999_999 ..= -100_000 => 7,
                -   99_999 ..= - 10_000 => 6,
                -    9_999 ..= -  1_000 => 5,
                -      999 ..= -    100 => 4,
                -       99 ..= -     10 => 3,
                -        9 ..= -      1 => 2,
                        0 ..=        9 => 1,
                        10 ..=       99 => 2,
                    100 ..=      999 => 3,
                    1_000 ..=    9_999 => 4,
                    10_000 ..=   99_999 => 5,
                100_000 ..=  999_999 => 6,
                1_000_000              => 7,
                _ => unreachable!()
            }
        }
    }
}

pub mod thread
{
    pub use std::thread::{ * };
}

pub mod time
{
    pub use temporal::{ * };
    pub mod std
    {
        pub use std::time::{ * };
    }
}

pub mod tuples
{
    /*!
    Tuple | A container which can hold elements of different types.*/
    use ::
    {
        error::{ OverError },
        fmt::{ Format },
        result::{ OverResult },
        slice::{ Iter },
        sync::{ Arc },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    use crate::{OverError, OverResult, INDENT_STEP};
    */
    #[derive( Clone, Debug )]
    struct TupInner 
    {
        vec: Vec<Value>,
        inner_tvec: Vec<Type>,
    }
    /// `Tup` struct.
    #[derive( Clone, Debug )]
    pub struct Tup 
    {
        inner: Arc<TupInner>,
    }

    impl Tup 
    {
        /// Returns a new `Tup` from the given vector of `Value`s.
        pub fn from_vec( values: Vec<Value> ) -> Tup {
            let tvec: Vec<Type> = values.iter().map( |val| val.get_type() ).collect();

            Tup {
                inner: Arc::new( TupInner {
                    vec: values,
                    inner_tvec: tvec,
                } ),
            }
        }
        /// Returns a reference to the inner vec of this `Tup`.
        pub fn vec_ref( &self ) -> &Vec<Value> {
            &self.inner.vec
        }
        /// Iterates over each `Value` in `self`, applying `Fn` `f`.
        pub fn with_each<F>( &self, mut f: F ) where
            F: FnMut( &Value ),
        {
            for value in &self.inner.vec {
                f( value )
            }
        }
        /// Gets the value at `index`.
        /// Returns an error if `index` is out of bounds.
        pub fn get( &self, index: usize ) -> OverResult<Value> {
            if index >= self.inner.vec.len() {
                Err( OverError::TupOutOfBounds( index ) )
            } else {
                Ok( self.inner.vec[index].clone() )
            }
        }
        /// Returns the type vector of this `Tup`.
        pub fn inner_type_vec( &self ) -> Vec<Type> {
            self.inner.inner_tvec.clone()
        }
        /// Returns the length of this `Tup`.
        pub fn len( &self ) -> usize {
            self.inner.vec.len()
        }
        /// Returns whether this `Tup` is empty.
        pub fn is_empty( &self ) -> bool {
            self.inner.vec.is_empty()
        }
        /// Returns whether `self` and `other` point to the same data.
        pub fn ptr_eq( &self, other:&Self ) -> bool {
            Arc::ptr_eq( &self.inner, &other.inner )
        }
        /// Returns an iterator over the Tup.
        pub fn iter( &self ) -> Iter<Value> {
            self.vec_ref().iter()
        }
    }

    impl Default for Tup
    {
        fn default() -> Self { Self::from_vec( Vec::new() ) }
    }

    impl fmt::Display for Tup 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl From<Vec<Value>> for Tup 
    {
        fn from( vec: Vec<Value> ) -> Self {
            Self::from_vec( vec )
        }
    }

    impl PartialEq for Tup 
    {
        fn eq( &self, other:&Self ) -> bool {
           
            if self.inner.inner_tvec != other.inner.inner_tvec {
                return false;
            }
            self.inner.vec == other.inner.vec
        }
    }
}

pub mod types
{
    /*!
    */
    use ::
    {
        collections::{ HashMap, HashSet },
        *,
    };
    /*
    use regex::Regex;
    use crate::parsers;
    use crate::parsers::parser_line::tokens_to_redirections;
    */
    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);
    /// Enum of possible types for `Value`s.
    #[derive( Clone, Debug )]
    pub enum Type 
    {
        /// A type used to indicate an empty Arr.
        Any,
        /// Null value.
        Null,

        /// A boolean type.
        Bool,
        /// A signed integer type.
        Int,
        /// A fully signed integer type.
        Integer,
        /// A fractional type.
        Frac,
        /// A character type.
        Char,
        /// A string type.
        Str,
        /// A string type.
        Strand,
        /// An array type, containing the type of its sub-elements.
        Arr( Box<Type> ),
        /// A tuple type, containing the types of its sub-elements.
        Tup( Vec<Type> ),
        /// An object type.
        Obj,
    }

    impl Type 
    {
        /// Returns true if this type is strictly the same as `other`.
        pub fn is( &self, other:&Type ) -> bool 
        {
            use self::Type::*;

            match *self
            {
                Any => {
                    if let Any = *other {
                        true
                    } else {
                        false
                    }
                }
                Null => {
                    if let Null = *other {
                        true
                    } else {
                        false
                    }
                }
                Bool => {
                    if let Bool = *other {
                        true
                    } else {
                        false
                    }
                }
                Int => {
                    if let Int = *other {
                        true
                    } else {
                        false
                    }
                }
                Integer => {
                    if let Integer = *other {
                        true
                    } else {
                        false
                    }
                }
                Frac => {
                    if let Frac = *other {
                        true
                    } else {
                        false
                    }
                }
                Char => {
                    if let Char = *other {
                        true
                    } else {
                        false
                    }
                }
                Str => {
                    if let Str = *other {
                        true
                    } else {
                        false
                    }
                }
                Strand => {
                    if let Strand = *other {
                        true
                    } else {
                        false
                    }
                }
                Obj => {
                    if let Obj = *other {
                        true
                    } else {
                        false
                    }
                }
                Arr( ref t1 ) => {
                    if let Arr( ref t2 ) = *other {
                        t1.is( t2 )
                    } else {
                        false
                    }
                }
                Tup( ref tvec1 ) => {
                    if let Tup( ref tvec2 ) = *other {
                        if tvec1.len() != tvec2.len() {
                            return false;
                        }
                        tvec1.iter().zip( tvec2.iter() ).all( |( t1, t2 )| t1.is( t2 ) )
                    } else {
                        false
                    }
                }
            }
        }
        /// Returns true if this `Type` contains `Any`.
        pub fn has_any( &self ) -> bool 
        {
            match *self
            {
                Type::Any => true,
                Type::Arr( ref t ) => Self::has_any( t ),
                Type::Tup( ref tvec ) => tvec.iter().any( |t| Self::has_any( t ) ),
                _ => false,
            }
        }
        /// Returns a type with the most specificity that can be applied to the two input types.
        pub fn most_specific( type1:&Type, type2:&Type ) -> Option<( Type, bool )> 
        {
            use self::Type::*;

            if let Any = *type2 {
                return Some( ( type1.clone(), type1.has_any() ) );
            }
            match *type1 {
                Any => Some( ( type2.clone(), type2.has_any() ) ),

                Arr( ref t1 ) => {
                    if let Arr( ref t2 ) = *type2 {
                        Self::most_specific( t1, t2 ).map( |( t, any )| ( Arr( Box::new( t ) ), any ) )
                    } else {
                        None
                    }
                }
                Tup( ref tvec1 ) => {
                    if let Tup( ref tvec2 ) = *type2 {
                        if tvec1.len() == tvec2.len() {
                            let mut has_any = false;

                            let tvec: Option<Vec<Type>> = tvec1
                                .iter()
                                .zip( tvec2.iter() )
                                .map( |( t1, t2 )| {
                                    Self::most_specific( t1, t2 ).map( |( t, any )| {
                                        if !has_any && any {
                                            has_any = any;
                                        }
                                        t
                                    } )
                                } )
                                .collect();

                            tvec.map( |tvec| ( Tup( tvec ), has_any ) )
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                }
                ref t => {
                    if t == type2 {
                        Some( ( t.clone(), false ) )
                    } else {
                        None
                    }
                }
            }
        }
    }
    /// Two types are considered equal if one of them is Any or they have the same variant.
    impl PartialEq for Type 
    {
        fn eq( &self, other:&Self ) -> bool
        {
            use self::Type::*;
            
            if let Any = *other { return true; }

            match *self
            {
                Any => true,
                Arr( ref box1 ) =>
                {
                    if let Arr( ref box2 ) = *other { box1 == box2 }
                    else { false }
                }
                
                Tup( ref tvec1 ) =>
                {
                    if let Tup( ref tvec2 ) = *other { tvec1 == tvec2 }
                    else { false }
                }

                _ => self.is( other ),
            }
        }
    }

    impl Eq for Type {}

    impl fmt::Display for Type 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            use self::Type::*;

            match *self 
            {
                Any => write!( f, "Any" ),
                Null => write!( f, "Null" ),
                Bool => write!( f, "Bool" ),
                Int => write!( f, "Int" ),
                Integer => write!( f, "Integer" ),
                Frac => write!( f, "Frac" ),
                Char => write!( f, "Char" ),
                Str => write!( f, "Str" ),
                Strand => write!( f, "Strand" ),
                Arr( ref boxxy ) => write!( f, "Arr( {} )", boxxy ),
                Tup( ref tvec ) => write!( 
                    f,
                    "Tup( {} )",
                    match tvec.get( 0 ) {
                        Some( t1 ) => tvec
                            .iter()
                            .skip( 1 )
                            .fold( format!( "{}", t1 ), |s, t| format!( "{}, {}", s, t ) ),
                        None => String::from( "" ),
                    }
                ),
                Obj => write!( f, "Obj" ),
            }
        }
    }

    #[derive( Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash )]
    pub struct WaitStatus( i32, i32, i32 );

    impl WaitStatus 
    {
        pub fn from_exited( pid: i32, status: i32) -> Self 
        {
            WaitStatus( pid, 0, status )
        }

        pub fn from_signaled( pid: i32, sig: i32) -> Self 
        {
            WaitStatus( pid, 1, sig)
        }

        pub fn from_stopped( pid: i32, sig: i32) -> Self 
        {
            WaitStatus( pid, 2, sig)
        }

        pub fn from_continuted( pid: i32) -> Self 
        {
            WaitStatus( pid, 3, 0)
        }

        pub fn from_others() -> Self 
        {
            WaitStatus(0, 9, 9)
        }

        pub fn from_error(errno: i32) -> Self 
        {
            WaitStatus(0, 255, errno)
        }

        pub fn empty() -> Self 
        {
            WaitStatus(0, 0, 0)
        }

        pub fn is_error( &self ) -> bool 
        {
            self.1 == 255
        }

        pub fn is_others( &self ) -> bool 
        {
            self.1 == 9
        }

        pub fn is_signaled( &self ) -> bool 
        {
            self.1 == 1
        }

        pub fn get_errno( &self ) -> nix::Error 
        {
            nix::Error::from_raw( self.2)
        }

        pub fn is_exited( &self ) -> bool 
        {
            self.0 != 0 && self.1 == 0
        }

        pub fn is_stopped( &self ) -> bool 
        {
            self.1 == 2
        }

        pub fn is_continued( &self ) -> bool 
        {
            self.1 == 3
        }

        pub fn get_pid( &self ) -> i32 
        {
            self.0
        }

        fn _get_signaled_status( &self ) -> i32 
        {
            self.2 + 128
        }

        pub fn get_signal( &self ) -> i32 
        {
            self.2
        }

        pub fn get_name( &self ) -> String 
        {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!( "unknown: {}", self.2)
            }
        }

        pub fn get_status( &self ) -> i32 
        {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }

    impl fmt::Debug for WaitStatus
    {
        fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result
        {
            let mut formatter = f.debug_struct( "WaitStatus" );
            formatter.field( "pid", &self.0);
            let name = self.get_name();
            formatter.field( "name", &name );
            formatter.field( "ext", &self.2);
            formatter.finish()
        }
    }
    
    #[derive( Debug )]
    pub struct LineInfo
    {
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo
    {
        pub fn new( tokens: Tokens ) -> Self
        {
            LineInfo
            {
                tokens,
                is_complete: true,
            }
        }
    }
    
    #[derive( Debug )]
    pub struct Command
    {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from: Option<Token>,
    }

    #[derive( Debug )]
    pub struct CommandLine
    {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl Command
    {
        pub fn from_tokens( tokens: Tokens ) -> Result<Command, String>
        {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<" );

            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<" ) {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<" ) {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<" );
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections( &tokens_new) {
                Ok((_tokens, _redirects_to ) ) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err( e ) => {
                    return Err( e );
                }
            }

            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some(( redirects_from_type, redirects_from_value  ) )
            };

            Ok( Command {
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }

        pub fn has_redirect_from( &self ) -> bool
        { self.redirect_from.is_some() && self.redirect_from.clone().unwrap().0 == "<" }

        pub fn has_here_string( &self ) -> bool
        { self.redirect_from.is_some() && self.redirect_from.clone().unwrap().0 == "<<<" }

        pub fn is_builtin( &self ) -> bool
        {
            is::builtin( &self.tokens[0].1)
        }
    }

    #[derive( Clone, Debug, Default )]
    pub struct Job
    {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job 
    {
        pub fn all_members_stopped( &self ) -> bool 
        {
            for pid in &self.pids
            {
                if !self.pids_stopped.contains( pid ) { return false; }
            }

            true
        }

        pub fn all_members_running( &self ) -> bool 
        {
            self.pids_stopped.is_empty()
        }
    }

    #[allow(dead_code )]
    #[derive( Clone, Debug, Default )]
    pub struct CommandResult 
    {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult 
    {
        pub fn new() -> CommandResult 
        {
            CommandResult 
            {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status(gid: i32, status: i32) -> CommandResult 
        {
            CommandResult 
            {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult 
        {
            CommandResult 
            {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }

    #[allow(dead_code )]
    #[derive( Clone, Debug, Default )]
    pub struct CommandOptions
    {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }

    pub fn split_tokens_by_pipes( tokens:&[Token] ) -> Vec<Tokens> 
    {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();

        for token in tokens
        {
            let sep = &token.0;
            let value = &token.1;
            
            if sep.is_empty() && value == "|"
            {
                if cmd.is_empty() { return Vec::new(); }

                cmds.push( Cmd.clone() );
                cmd = Vec::new();
            }

            else { cmd.push( token.clone() ); }
        }
        
        if cmd.is_empty() { return Vec::new(); }

        cmds.push( Cmd.clone() );
        cmds
    }

    pub fn drain_env_tokens( tokens: &mut Tokens ) -> HashMap<String, String> 
    {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new( r"^([a-zA-Z0-9_]+)=(.*)$" ).unwrap();

        for ( sep, text ) in tokens.iter() {
            if !sep.is_empty() || !::regex::contains( text, r"^([a-zA-Z0-9_]+)=(.*)$" ) {
                break;
            }

            for cap in re.captures_iter( text ) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote( &cap[2]);
                envs.insert( name, value );
            }

            n += 1;
        }
        
        if n > 0 { tokens.drain(0..n ); }

        envs
    }

    impl CommandLine
    {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String>
        {
            let linfo = parsers::parser_line::parse_line(line );
            let mut tokens = linfo.tokens;
            shell::do_expansion( sh, &mut tokens );
            let envs = drain_env_tokens( &mut tokens );

            let mut background = false;
            let len = tokens.len();
            
            if len > 1 && tokens[len - 1].1 == "&"
            {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();

            for sub_tokens in split_tokens_by_pipes( &tokens )
            {
                match Command::from_tokens( sub_tokens ) {
                    Ok( c ) => {
                        commands.push( c );
                    }
                    Err( e ) => {
                        return Err( e );
                    }
                }
            }

            Ok
            (
                CommandLine
                {
                    line: line.to_string(),
                    commands,
                    envs,
                    background,
                }
            )
        }

        pub fn is_empty( &self ) -> bool { self.commands.is_empty() }

        pub fn with_pipeline( &self ) -> bool { self.commands.len() > 1 }

        pub fn is_single_and_builtin( &self ) -> bool { self.commands.len() == 1 && self.commands[0].is_builtin() }
    }
}

pub mod u8
{
    pub use std::u8::{ * };
}

pub mod u16
{
    pub use std::u16::{ * };
}

pub mod u32
{
    pub use std::u32::{ * };
}

pub mod u64
{
    pub use std::u64::{ * };
}

pub mod usize
{
    pub use std::usize::{ * };
}

pub mod u128
{
    pub use std::u128::{ * };
}

pub mod uuid
{
    /*!
    Generate and parse universally unique identifiers ( UUIDs ). */
    use ::
    {
        hash::{ Hash, Hasher },
        *,
    };

    pub mod builder
    {
        /*!
        A Builder type for [`Uuid`]s. */
        use ::
        {
            *,
        };
        /*
        use crate::{error::*, timestamp, Bytes, Uuid, Variant, Version};
        */
        /// A builder for creating a UUID.
        #[derive( Debug )]
        pub struct Builder( Uuid  );

        impl Uuid
        {
            /// The 'nil UUID' ( all zeros ).
            pub const fn nil() -> Self { Uuid::from_bytes( [0; 16] ) }
            /// The 'max UUID' ( all ones ).
            pub const fn max() -> Self { Uuid::from_bytes( [0xFF; 16] ) }
            /// Creates a UUID from four field values.
            pub const fn from_fields( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Uuid
            {
                Uuid::from_bytes
                ([
                    ( d1 >> 24 ) as u8, ( d1 >> 16 ) as u8, ( d1 >> 8 ) as u8, d1 as u8, ( d2 >> 8 ) as u8,
                    d2 as u8, ( d3 >> 8 ) as u8, d3 as u8, d4[0], d4[1], d4[2], d4[3], d4[4], d4[5], d4[6], d4[7],
                ] )
            }
            /// Creates a UUID from four field values in little-endian order.
            pub const fn from_fields_le( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Uuid
            {
                Uuid::from_bytes
                ([
                    d1 as u8, ( d1 >> 8 ) as u8, ( d1 >> 16 ) as u8, ( d1 >> 24 ) as u8, ( d2 ) as u8, 
                    ( d2 >> 8 ) as u8, d3 as u8, ( d3 >> 8 ) as u8, d4[0], d4[1], d4[2], d4[3], d4[4],
                    d4[5], d4[6], d4[7],
                ] )
            }
            /// Creates a UUID from a 128bit value.
            pub const fn from_u128( v: u128 ) -> Self { Uuid::from_bytes( v.to_be_bytes() ) }
            /// Creates a UUID from a 128bit value in little-endian order.
            pub const fn from_u128_le( v: u128 ) -> Self { Uuid::from_bytes( v.to_le_bytes() ) }
            /// Creates a UUID from two 64bit values.
            pub const fn from_u64_pair( high_bits: u64, low_bits: u64 ) -> Self
            { Uuid::from_u128( ( ( high_bits as u128 ) << 64 ) | low_bits as u128 ) }
            /// Creates a UUID using the supplied bytes.
            pub fn from_slice( b:&[u8] ) -> Result<Uuid, Error>
            {
                if b.len() != 16 { return Err( Error( ErrorKind::ParseByteLength { len: b.len() } ) ); }

                let mut bytes: Bytes = [0; 16];
                bytes.copy_from_slice( b );
                Ok( Uuid::from_bytes( bytes ) )
            }
            /// Creates a UUID using the supplied bytes in little endian order.
            pub fn from_slice_le( b:&[u8] ) -> Result<Uuid, Error>
            {
                if b.len() != 16 { return Err( Error( ErrorKind::ParseByteLength { len: b.len() } ) ); }

                let mut bytes: Bytes = [0; 16];
                bytes.copy_from_slice( b );
                Ok( Uuid::from_bytes_le( bytes ) )
            }
            /// Creates a UUID using the supplied bytes.
            #[inline] pub const fn from_bytes( bytes: Bytes ) -> Uuid { Uuid( bytes ) }
            /// Creates a UUID using the supplied bytes in little endian order.
            pub const fn from_bytes_le( b: Bytes ) -> Uuid
            {
                Uuid
                ([
                    b[3],b[2],b[1],b[0],b[5], b[4], b[7], b[6], b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15],
                ] )
            }
            /// Creates a reference to a UUID from a reference to the supplied bytes.
            #[inline] pub fn from_bytes_ref( bytes:&Bytes ) -> &Uuid { unsafe_transmute_ref!( bytes ) }
        }

        impl Builder
        {
            /// Creates a `Builder` using the supplied bytes.
            pub const fn from_bytes( b: Bytes ) -> Self { Builder( Uuid::from_bytes( b ) ) }
            /// Creates a `Builder` using the supplied bytes in little endian order.
            pub const fn from_bytes_le( b: Bytes ) -> Self { Builder( Uuid::from_bytes_le( b ) ) }
            /// Creates a `Builder` for a version 1 UUID using the supplied timestamp, counter, and node ID.
            pub const fn from_gregorian_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6] ) -> Self
            { Builder( timestamp::encode_gregorian_timestamp( ticks, counter, node_id ) ) }
            /// Creates a `Builder` for a version 3 UUID using the supplied MD5 hashed bytes.
            pub const fn from_md5_bytes( md5_bytes: Bytes ) -> Self
            {
                Builder( Uuid::from_bytes( md5_bytes ) )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Md5 )
            }
            /// Creates a `Builder` for a version 4 UUID using the supplied random bytes.
            pub const fn from_random_bytes( random_bytes: Bytes ) -> Self
            {
                Builder( Uuid::from_bytes( random_bytes ) )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Random )
            }
            /// Creates a `Builder` for a version 5 UUID using the supplied SHA-1 hashed bytes.
            pub const fn from_sha1_bytes( sha1_bytes: Bytes ) -> Self
            {
                Builder( Uuid::from_bytes( sha1_bytes ) )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Sha1 )
            }
            /// Creates a `Builder` for a version 6 UUID using the supplied timestamp, counter, and node ID.
            pub const fn from_sorted_gregorian_timestamp
            ( 
                ticks: u64,
                counter: u16,
                node_id:&[u8; 6],
            ) -> Self
            {
                Builder( timestamp::encode_sorted_gregorian_timestamp
                ( 
                    ticks, counter, node_id,
                ) )
            }
            /// Creates a `Builder` for a version 7 UUID using the supplied Unix timestamp and counter bytes.
            pub const fn from_unix_timestamp_millis( millis: u64, counter_random_bytes:&[u8; 10] ) -> Self
            {
                Builder( timestamp::encode_unix_timestamp_millis
                ( 
                    millis,
                    counter_random_bytes,
                ) )
            }
            /// Creates a `Builder` for a version 8 UUID using the supplied user-defined bytes.
            pub const fn from_custom_bytes( custom_bytes: Bytes ) -> Self
            {
                Builder::from_bytes( custom_bytes )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Custom )
            }
            /// Creates a `Builder` using the supplied bytes.
            pub fn from_slice( b:&[u8] ) -> Result<Self, Error>
            { Ok( Builder( Uuid::from_slice( b )? ) ) }
            /// Creates a `Builder` using the supplied bytes in little endian order.
            pub fn from_slice_le( b:&[u8] ) -> Result<Self, Error>
            { Ok( Builder( Uuid::from_slice_le( b )? ) ) }
            /// Creates a `Builder` from four field values.
            pub const fn from_fields( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Self
            { Builder( Uuid::from_fields( d1, d2, d3, d4 ) ) }
            /// Creates a `Builder` from four field values.
            pub const fn from_fields_le( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Self 
            { Builder( Uuid::from_fields_le( d1, d2, d3, d4 ) ) }
            /// Creates a `Builder` from a 128bit value.
            pub const fn from_u128( v: u128 ) -> Self 
            {
                Builder( Uuid::from_u128( v ) )
            }
            /// Creates a UUID from a 128bit value in little-endian order.
            pub const fn from_u128_le( v: u128 ) -> Self 
            {
                Builder( Uuid::from_u128_le( v ) )
            }
            /// Creates a `Builder` with an initial [`Uuid::nil`].
            pub const fn nil() -> Self { Builder( Uuid::nil() ) }
            /// Specifies the variant of the UUID.
            pub fn set_variant( &mut self, v: Variant ) -> &mut Self
            {
                *self = Builder( self.0 ).with_variant( v );
                self
            }
            /// Specifies the variant of the UUID.
            pub const fn with_variant( mut self, v: Variant ) -> Self
            {
                let byte = ( self.0 ).0[8];

                ( self.0 ).0[8] = match v
                {
                    Variant::NCS => byte & 0x7f,
                    Variant::RFC4122 => ( byte & 0x3f ) | 0x80,
                    Variant::Microsoft => ( byte & 0x1f ) | 0xc0,
                    Variant::Future => byte | 0xe0,
                };

                self
            }
            /// Specifies the version number of the UUID.
            pub fn set_version( &mut self, v: Version ) -> &mut Self
            {
                *self = Builder( self.0 ).with_version( v );
                self
            }
            /// Specifies the version number of the UUID.
            pub const fn with_version( mut self, v: Version ) -> Self
            {
                ( self.0 ).0[6] = (( self.0 ).0[6] & 0x0f ) | ( ( v as u8 ) << 4 );
                self
            }
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid( &self ) -> &Uuid { &self.0 }
            /// Convert the builder into a [`Uuid`].
            pub const fn into_uuid( self ) -> Uuid { self.0 }
        
            #[deprecated( 
                since = "1.10.0",
                note = "use `Builder::from_gregorian_timestamp( ticks, counter, node_id )`"
            )]
            pub const fn from_rfc4122_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6] ) -> Self
            { Builder::from_gregorian_timestamp( ticks, counter, node_id ) }

            #[deprecated( 
                since = "1.10.0",
                note = "use `Builder::from_sorted_gregorian_timestamp( ticks, counter, node_id )`"
            )]
            pub const fn from_sorted_rfc4122_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6], ) -> Self
            { Builder::from_sorted_gregorian_timestamp( ticks, counter, node_id ) }
        }
    }

    pub mod error
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        /// A general error that can occur when working with UUIDs.
        #[derive( Clone, Debug, Eq, Hash, PartialEq )]
        pub struct Error( pub ErrorKind );

        #[derive( Clone, Debug, Eq, Hash, PartialEq )]
        pub enum ErrorKind 
        {
            /// Invalid character in the [`Uuid`] string.
            ParseChar { character:char, index: usize },
            /// A simple [`Uuid`] didn't contain 32 characters.
            ParseSimpleLength { len: usize },
            /// A byte array didn't contain 16 bytes
            ParseByteLength { len: usize },
            /// A hyphenated [`Uuid`] didn't contain 5 groups
            ParseGroupCount { count: usize },
            /// A hyphenated [`Uuid`] had a group that wasn't the right length
            ParseGroupLength
            {
                group: usize,
                len: usize,
                index: usize,
            },
            /// The input was not a valid UTF8 string
            ParseInvalidUTF8,
            /// Some other parsing error occurred.
            ParseOther,
            /// The UUID is nil.
            Nil,
            /// A system time was invalid.
            InvalidSystemTime( &'static str ),
        }
        /// A string that is guaranteed to fail to parse to a [`Uuid`].
        #[derive( Clone, Debug, Eq, Hash, PartialEq )]
        pub struct InvalidUuid<'a>( pub &'a [u8] );

        impl<'a> InvalidUuid<'a>
        {
            /// Converts the lightweight error type into detailed diagnostics.
            pub fn into_err( self ) -> Error
            {
                let input_str = match ::str::from_utf8( self.0 )
                {
                    Ok( s ) => s,
                    Err( _ ) => return Error( ErrorKind::ParseInvalidUTF8 ),
                };

                let ( uuid_str, offset, simple ) = match input_str.as_bytes()
                {
                    [b'{', s @ .., b'}'] => ( s, 1, false ),
                    [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] =>
                    { ( s, "urn:uuid:".len(), false ) }
                    s => ( s, 0, true ),
                };

                let mut hyphen_count = 0;
                let mut group_bounds = [0; 4];
                
                let uuid_str = unsafe { ::str::from_utf8_unchecked( uuid_str ) };

                for ( index, character ) in uuid_str.char_indices()
                {
                    let byte = character as u8;
                    if character as u32 - byte as u32 > 0
                    {
                        return Error( ErrorKind::ParseChar
                        {
                            character,
                            index: index + offset + 1,
                        } );
                    }
                    
                    else if byte == b'-'
                    {
                        if hyphen_count < 4 { group_bounds[hyphen_count] = index; }
                        hyphen_count += 1;
                    }
                    
                    else if !byte.is_ascii_hexdigit()
                    {
                        return Error
                        ( 
                            ErrorKind::ParseChar
                            {
                                character: byte as char,
                                index: index + offset + 1,
                            }
                         );
                    }
                }

                if hyphen_count == 0 && simple
                {
                    Error( ErrorKind::ParseSimpleLength
                    {
                        len: input_str.len(),
                    } )
                }
                
                else if hyphen_count != 4
                {
                    Error( ErrorKind::ParseGroupCount
                    {
                        count: hyphen_count + 1,
                    } )
                }
                
                else
                {
                    const BLOCK_STARTS: [usize; 5] = [0, 9, 14, 19, 24];
                    for i in 0..4
                    {
                        if group_bounds[i] != BLOCK_STARTS[i + 1] - 1
                        {
                            return Error( ErrorKind::ParseGroupLength
                            {
                                group: i,
                                len: group_bounds[i] - BLOCK_STARTS[i],
                                index: offset + BLOCK_STARTS[i] + 1,
                            } );
                        }
                    }
                    
                    Error( ErrorKind::ParseGroupLength
                    {
                        group: 4,
                        len: input_str.len() - BLOCK_STARTS[4],
                        index: offset + BLOCK_STARTS[4] + 1,
                    } )
                }
            }
        }
        
        impl fmt::Display for Error
        {
            fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
            {
                match self.0
                {
                    ErrorKind::ParseChar
                    {
                        character, index, ..
                    } =>
                    {
                        write!
                        ( 
                            f,
                            r#"invalid character:
                            expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `{}` at {}"#, 
                            character,
                            index
                        )
                    }

                    ErrorKind::ParseSimpleLength { len } =>
                    {
                        write!( 
                            f,
                            "invalid length: expected length 32 for simple format, found {}",
                            len
                        )
                    }

                    ErrorKind::ParseByteLength { len } =>
                    {
                        write!( f, "invalid length: expected 16 bytes, found {}", len )
                    }

                    ErrorKind::ParseGroupCount { count } =>
                    {
                        write!( f, "invalid group count: expected 5, found {}", count )
                    }

                    ErrorKind::ParseGroupLength { group, len, .. } => 
                    {
                        let expected = [8, 4, 4, 4, 12][group];
                        write!( 
                            f,
                            "invalid group length in group {}: expected {}, found {}",
                            group, expected, len
                        )
                    }

                    ErrorKind::ParseInvalidUTF8 => write!( f, "non-UTF8 input" ),
                    ErrorKind::Nil => write!( f, "the UUID is nil" ),
                    ErrorKind::ParseOther => write!( f, "failed to parse a UUID" ),
                    ErrorKind::InvalidSystemTime( ref e ) => write!( f, "the system timestamp is invalid: {e}" ),
                }
            }
        }
    }

    pub mod fmt
    {
        /*!
        Adapters for alternative string formats. */
        use ::
        {
            borrow::{ Borrow },
            convert::{ TryInto as _, },
            str::{ FromStr },
            string::{ String, ToString },
            uuid::{ Uuid, Variant },
            *,
        };
        /*
        */
        impl ::fmt::Debug for Uuid
        {
            #[inline] fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::LowerHex::fmt( self, f ) }
        }

        impl fmt::Display for Uuid
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::LowerHex::fmt( self, f ) }
        }
        
        impl From<Uuid> for String
        {
            fn from( uuid: Uuid ) -> Self { uuid.to_string() }
        }

        impl fmt::Display for Variant
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
            {
                match *self
                {
                    Variant::NCS => write!( f, "NCS" ),
                    Variant::RFC4122 => write!( f, "RFC4122" ),
                    Variant::Microsoft => write!( f, "Microsoft" ),
                    Variant::Future => write!( f, "Future" ),
                }
            }
        }

        impl fmt::LowerHex for Uuid
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::LowerHex::fmt( self.as_hyphenated(), f ) }
        }

        impl fmt::UpperHex for Uuid
        {
            #[inline] fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
            { fmt::UpperHex::fmt( self.as_hyphenated(), f ) }
        }
        /// Format a [`Uuid`] as a hyphenated string.
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Hyphenated( Uuid );
        /// Format a [`Uuid`] as a simple string.
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Simple( Uuid );
        /// Format a [`Uuid`] as a URN string.
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Urn( Uuid );
        /// Format a [`Uuid`] as a braced hyphenated string.
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Braced( Uuid );

        impl Uuid
        {
            /// Get a [`Hyphenated`] formatter.
            #[inline] pub const fn hyphenated( self ) -> Hyphenated { Hyphenated( self ) }
            /// Get a borrowed [`Hyphenated`] formatter.
            #[inline] pub fn as_hyphenated( &self ) -> &Hyphenated { unsafe_transmute_ref!( self ) }
            /// Get a [`Simple`] formatter.
            #[inline] pub const fn simple( self ) -> Simple { Simple( self ) }
            /// Get a borrowed [`Simple`] formatter.
            #[inline] pub fn as_simple( &self ) -> &Simple { unsafe_transmute_ref!( self ) }
            /// Get a [`Urn`] formatter.
            #[inline] pub const fn urn( self ) -> Urn { Urn( self ) }
            /// Get a borrowed [`Urn`] formatter.
            #[inline] pub fn as_urn( &self ) -> &Urn { unsafe_transmute_ref!( self ) }
            /// Get a [`Braced`] formatter.
            #[inline] pub const fn braced( self ) -> Braced { Braced( self ) }
            /// Get a borrowed [`Braced`] formatter.
            #[inline] pub fn as_braced( &self ) -> &Braced { unsafe_transmute_ref!( self ) }
        }

        const UPPER: [u8; 16] =
        [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', b'A', b'B', b'C', b'D', b'E', b'F' ];
        
        const LOWER: [u8; 16] =
        [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', b'a', b'b', b'c', b'd', b'e', b'f' ];

        #[inline] const fn format_simple( src:&[u8; 16], upper: bool ) -> [u8; 32]
        {
            let lut = if upper { &UPPER } else { &LOWER };
            let mut dst = [0; 32];
            let mut i = 0;

            while i < 16
            {
                let x = src[i];
                dst[i * 2] = lut[( x >> 4 ) as usize];
                dst[i * 2 + 1] = lut[( x & 0x0f ) as usize];
                i += 1;
            }
            dst
        }

        #[inline] const fn format_hyphenated( src:&[u8; 16], upper: bool ) -> [u8; 36] 
        {
            let lut = if upper { &UPPER } else { &LOWER };
            let groups = [( 0, 8 ), ( 9, 13 ), ( 14, 18 ), ( 19, 23 ), ( 24, 36 )];
            let mut dst = [0; 36];

            let mut group_idx = 0;
            let mut i = 0;

            while group_idx < 5
            {
                let ( start, end ) = groups[group_idx];
                let mut j = start;

                while j < end
                {
                    let x = src[i];
                    i += 1;

                    dst[j] = lut[( x >> 4 ) as usize];
                    dst[j + 1] = lut[( x & 0x0f ) as usize];
                    j += 2;
                }

                if group_idx < 4
                {
                    dst[end] = b'-';
                }

                group_idx += 1;
            }

            dst
        }

        #[inline] fn encode_simple<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let buf = &mut buffer[..Simple::LENGTH];
            let buf:&mut [u8; Simple::LENGTH] = buf.try_into().unwrap();
            *buf = format_simple( src, upper );

            // SAFETY: The encoded buffer is ASCII encoded
            unsafe { str::from_utf8_unchecked_mut( buf ) }
        }

        #[inline] fn encode_hyphenated<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let buf = &mut buffer[..Hyphenated::LENGTH];
            let buf:&mut [u8; Hyphenated::LENGTH] = buf.try_into().unwrap();
            *buf = format_hyphenated( src, upper );

            // SAFETY: The encoded buffer is ASCII encoded
            unsafe { str::from_utf8_unchecked_mut( buf ) }
        }

        #[inline] fn encode_braced<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let buf = &mut buffer[..Hyphenated::LENGTH + 2];
            let buf:&mut [u8; Hyphenated::LENGTH + 2] = buf.try_into().unwrap();

            #[cfg_attr( 
                all( uuid_unstable, feature = "zerocopy" ),
                derive( zerocopy::IntoBytes )
            )]
            #[repr( C )]
            struct Braced {
                open_curly: u8,
                hyphenated: [u8; Hyphenated::LENGTH],
                close_curly: u8,
            }

            let braced = Braced {
                open_curly: b'{',
                hyphenated: format_hyphenated( src, upper ),
                close_curly: b'}',
            };

            *buf = unsafe_transmute!( braced );

            // SAFETY: The encoded buffer is ASCII encoded
            unsafe { str::from_utf8_unchecked_mut( buf ) }
        }

        #[inline] fn encode_urn<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let buf = &mut buffer[..Urn::LENGTH];
            buf[..9].copy_from_slice( b"urn:uuid:" );

            let dst = &mut buf[9..( 9 + Hyphenated::LENGTH )];
            let dst:&mut [u8; Hyphenated::LENGTH] = dst.try_into().unwrap();
            *dst = format_hyphenated( src, upper );
            
            unsafe { str::from_utf8_unchecked_mut( buf ) }
        }

        impl Hyphenated 
        {
            /// The length of a hyphenated [`Uuid`] string.
            pub const LENGTH: usize = 36;
            /// Creates a [`Hyphenated`] from a [`Uuid`].
            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Hyphenated( uuid )
            }
            /// Writes the [`Uuid`] as a lower-case hyphenated string to `buffer`,
            /// and returns the subslice of the buffer that contains the encoded UUID.
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_hyphenated( self.0.as_bytes(), buffer, false )
            }
            /// Writes the [`Uuid`] as an upper-case hyphenated string to
            /// `buffer`, and returns the subslice of the buffer that contains the
            /// encoded UUID.
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_hyphenated( self.0.as_bytes(), buffer, true )
            }
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }
            /// Consumes the [`Hyphenated`], returning the underlying [`Uuid`].
            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl Braced 
        {
            /// The length of a braced [`Uuid`] string.
            pub const LENGTH: usize = 38;
            /// Creates a [`Braced`] from a [`Uuid`].
            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Braced( uuid )
            }
            /// Writes the [`Uuid`] as a lower-case hyphenated string surrounded by
            /// braces to `buffer`, and returns the subslice of the buffer that contains
            /// the encoded UUID.
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_braced( self.0.as_bytes(), buffer, false )
            }
            /// Writes the [`Uuid`] as an upper-case hyphenated string surrounded by
            /// braces to `buffer`, and returns the subslice of the buffer that contains
            /// the encoded UUID.
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_braced( self.0.as_bytes(), buffer, true )
            }
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }
            /// Consumes the [`Braced`], returning the underlying [`Uuid`].
            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl Simple 
        {
            /// The length of a simple [`Uuid`] string.
            pub const LENGTH: usize = 32;
            /// Creates a [`Simple`] from a [`Uuid`].
            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Simple( uuid )
            }
            /// Writes the [`Uuid`] as a lower-case simple string to `buffer`,
            /// and returns the subslice of the buffer that contains the encoded UUID.
            /// double buffering.
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_simple( self.0.as_bytes(), buffer, false )
            }
            /// Writes the [`Uuid`] as an upper-case simple string to `buffer`,
            /// and returns the subslice of the buffer that contains the encoded UUID.
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_simple( self.0.as_bytes(), buffer, true )
            }
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }
            /// Consumes the [`Simple`], returning the underlying [`Uuid`].
            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl Urn 
        {
            /// The length of a URN [`Uuid`] string.
            pub const LENGTH: usize = 45;
            /// Creates a [`Urn`] from a [`Uuid`].
            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Urn( uuid )
            }
            /// Writes the [`Uuid`] as a lower-case URN string to
            /// `buffer`, and returns the subslice of the buffer that contains the
            /// encoded UUID.
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_urn( self.0.as_bytes(), buffer, false )
            }
            /// Writes the [`Uuid`] as an upper-case URN string to
            /// `buffer`, and returns the subslice of the buffer that contains the
            /// encoded UUID.
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_urn( self.0.as_bytes(), buffer, true )
            }
            /// Get a reference to the underlying [`Uuid`].
            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }
            /// Consumes the [`Urn`], returning the underlying [`Uuid`].
            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl FromStr for Hyphenated 
        {
            type Err = super::error::Error;

            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_hyphenated( s.as_bytes() )
                .map( |b| Hyphenated( Uuid( b ) ) )
                .map_err( |invalid| invalid.into_err() )
            }
        }

        impl FromStr for Simple 
        {
            type Err = super::error::Error;

            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_simple( s.as_bytes() )
                    .map( |b| Simple( Uuid( b ) ) )
                    .map_err( |invalid| invalid.into_err() )
            }
        }

        impl FromStr for Urn 
        {
            type Err = super::error::Error;

            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_urn( s.as_bytes() )
                    .map( |b| Urn( Uuid( b ) ) )
                    .map_err( |invalid| invalid.into_err() )
            }
        }

        impl FromStr for Braced 
        {
            type Err = super::error::Error;

            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_braced( s.as_bytes() )
                    .map( |b| Braced( Uuid( b ) ) )
                    .map_err( |invalid| invalid.into_err() )
            }
        }

        macro_rules! impl_fmt_traits 
        {
            ( $( $T:ident<$( $a:lifetime ),*> ),+ ) =>
            {$( 
                impl<$( $a ),*> fmt::Display for $T<$( $a ),*> 
                {
                    #[inline]
                    fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                        fmt::LowerHex::fmt( self, f )
                    }
                }

                impl<$( $a ),*> fmt::LowerHex for $T<$( $a ),*> 
                {
                    fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                        f.write_str( self.encode_lower( &mut [0; Self::LENGTH] ) )
                    }
                }

                impl<$( $a ),*> fmt::UpperHex for $T<$( $a ),*> 
                {
                    fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                        f.write_str( self.encode_upper( &mut [0; Self::LENGTH] ) )
                    }
                }

                impl_fmt_from!( $T<$( $a ),*> );
            )+}
        }

        macro_rules! impl_fmt_from 
        {
            ( $T:ident<> ) =>
            {
                impl From<Uuid> for $T {
                    #[inline]
                    fn from( f: Uuid ) -> Self {
                        $T( f )
                    }
                }

                impl From<$T> for Uuid {
                    #[inline]
                    fn from( f: $T ) -> Self {
                        f.into_uuid()
                    }
                }

                impl AsRef<Uuid> for $T {
                    #[inline]
                    fn as_ref( &self ) -> &Uuid {
                        &self.0
                    }
                }

                impl Borrow<Uuid> for $T {
                    #[inline]
                    fn borrow( &self ) -> &Uuid {
                        &self.0
                    }
                }
            };

            ( $T:ident<$a:lifetime> ) =>
            {
                impl<$a> From<&$a Uuid> for $T<$a> 
                {
                    #[inline]
                    fn from( f:&$a Uuid ) -> Self {
                        $T::from_uuid_ref( f )
                    }
                }

                impl<$a> From<$T<$a>> for &$a Uuid 
                {
                    #[inline]
                    fn from( f: $T<$a> ) -> &$a Uuid {
                        f.0
                    }
                }

                impl<$a> AsRef<Uuid> for $T<$a> 
                {
                    #[inline]
                    fn as_ref( &self ) -> &Uuid {
                        self.0
                    }
                }

                impl<$a> Borrow<Uuid> for $T<$a> 
                {
                    #[inline]
                    fn borrow( &self ) -> &Uuid {
                        self.0
                    }
                }
            };
        }

        impl_fmt_traits! 
        {
            Hyphenated<>,
            Simple<>,
            Urn<>,
            Braced<>
        }
    }

    pub mod non_nil
    {
        /*!
        A wrapper type for nil UUIDs that provides a more memory-efficient `Option<NonNilUuid>` representation.*/
        use ::
        {
            convert::{ TryFrom },
            num::{ NonZeroU128 },
            uuid::
            {
                error::{ Error, ErrorKind },
                Uuid
            },
            *,
        };
        /*
        */
        /// A UUID that is guaranteed not to be the [nil UUID]( https://www.ietf.org/rfc/rfc9562.html#name-nil-uuid ).
        #[repr( transparent )] #[derive( Copy, Clone, PartialEq, Eq, Hash )]
        pub struct NonNilUuid( NonZeroU128 );

        impl fmt::Debug for NonNilUuid 
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::Debug::fmt( &Uuid::from( *self ), f ) }
        }

        impl fmt::Display for NonNilUuid 
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::Display::fmt( &Uuid::from( *self ), f ) }
        }

        impl PartialEq<Uuid> for NonNilUuid 
        {
            fn eq( &self, other:&Uuid ) -> bool { self.get() == *other }
        }

        impl PartialEq<NonNilUuid> for Uuid 
        {
            fn eq( &self, other:&NonNilUuid ) -> bool { *self == other.get() }
        }

        impl NonNilUuid 
        {
            /// Creates a non-nil UUID if the value is non-nil.
            pub const fn new( uuid: Uuid ) -> Option<Self> 
            {
                match NonZeroU128::new( uuid.as_u128() )
                {
                    Some( non_nil ) => Some( NonNilUuid( non_nil ) ),
                    None => None,
                }
            }
            /// Creates a non-nil without checking whether the value is non-nil.
            pub const unsafe fn new_unchecked( uuid: Uuid ) -> Self 
            {
                NonNilUuid( unsafe { NonZeroU128::new_unchecked( uuid.as_u128() ) } )
            }
            /// Get the underlying [`Uuid`] value.
            #[inline] pub const fn get( self ) -> Uuid { Uuid::from_u128( self.0.get() ) }
        }

        impl From<NonNilUuid> for Uuid 
        {
            /// Converts a [`NonNilUuid`] back into a [`Uuid`].
            fn from( non_nil: NonNilUuid ) -> Self { Uuid::from_u128( non_nil.0.get() ) }
        }

        impl TryFrom<Uuid> for NonNilUuid 
        {
            type Error = Error;
            /// Attempts to convert a [`Uuid`] into a [`NonNilUuid`].on_nil = NonNilUuid::try_from( uuid ).unwrap();
            fn try_from( uuid: Uuid ) -> Result<Self, Self::Error> 
            {
                NonZeroU128::new( uuid.as_u128() )
                .map( self )
                .ok_or( Error( ErrorKind::Nil ) )
            }
        }
    }

    pub mod parser
    {
        /*!
        [`Uuid`] parsing constructs and utilities. */
        use ::
        {
            convert::{ TryFrom },
            string::{ String },
            uuid::
            {
                error::{ * },
                Uuid,
            },
            *,
        };
        /*
        */
        impl str::FromStr for Uuid
        {
            type Err = Error;

            fn from_str( uuid_str:&str ) -> Result<Self, Self::Err>
            {
                Uuid::parse_str( uuid_str )
            }
        }

        impl TryFrom<&'_ str> for Uuid 
        {
            type Error = Error;

            fn try_from( uuid_str:&'_ str ) -> Result<Self, Self::Error> {
                Uuid::parse_str( uuid_str )
            }
        }
        
        impl TryFrom<String> for Uuid 
        {
            type Error = Error;

            fn try_from( uuid_str: String ) -> Result<Self, Self::Error> {
                Uuid::try_from( uuid_str.as_ref() )
            }
        }

        impl Uuid 
        {
            /// Parses a `Uuid` from a string of hexadecimal digits with optional hyphens.
            pub fn parse_str( input:&str ) -> Result<Uuid, Error>
            {
                try_parse( input.as_bytes() )
                .map( Uuid::from_bytes )
                .map_err( InvalidUuid::into_err )
            }
            /// Parses a `Uuid` from a string of hexadecimal digits with optional hyphens.
            pub const fn try_parse( input:&str ) -> Result<Uuid, Error> { Self::try_parse_ascii( input.as_bytes() ) }
            /// Parses a `Uuid` from a string of hexadecimal digits with optional hyphens.
            pub const fn try_parse_ascii( input:&[u8] ) -> Result<Uuid, Error>
            {
                match try_parse( input )
                {
                    Ok( bytes ) => Ok( Uuid::from_bytes( bytes ) ),
                    Err( _ ) => Err( Error( ErrorKind::ParseOther ) ),
                }
            }
        }

        const fn try_parse( input:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            match ( input.len(), input )
            {
                ( 32, s ) => parse_simple( s ),
                ( 36, s )
                | ( 38, [b'{', s @ .., b'}'] )
                | ( 45, [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] ) =>
                {
                    parse_hyphenated( s )
                }
                _ => Err( InvalidUuid( input ) ),
            }
        }

        #[inline] #[allow( dead_code )] 
        pub const fn parse_braced( input:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if let ( 38, [b'{', s @ .., b'}'] ) = ( input.len(), input ) { parse_hyphenated( s ) }
            else { Err( InvalidUuid( input ) ) }
        }

        #[inline] #[allow( dead_code )] 
        pub const fn parse_urn( input:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if let ( 45, [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] ) = 
            ( input.len(), input ) { parse_hyphenated( s ) }

            else { Err( InvalidUuid( input ) ) }
        }

        #[inline] pub const fn parse_simple( s:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if s.len() != 32 { return Err( InvalidUuid( s ) ); }

            let mut buf: [u8; 16] = [0; 16];
            let mut i = 0;

            while i < 16
            {
                let h1 = HEX_TABLE[s[i * 2] as usize];
                let h2 = HEX_TABLE[s[i * 2 + 1] as usize];
                
                if h1 | h2 == 0xff { return Err( InvalidUuid( s ) ); }
                
                buf[i] = SHL4_TABLE[h1 as usize] | h2;
                i += 1;
            }

            Ok( buf )
        }

        #[inline] pub const fn parse_hyphenated( s:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if s.len() != 36 { return Err( InvalidUuid( s ) ); }
            
            match [s[8], s[13], s[18], s[23]]
            {
                [b'-', b'-', b'-', b'-'] => {}
                _ => return Err( InvalidUuid( s ) ),
            }

            let positions: [u8; 8] = [0, 4, 9, 14, 19, 24, 28, 32];
            let mut buf: [u8; 16] = [0; 16];
            let mut j = 0;

            while j < 8
            {
                let i = positions[j];
                let h1 = HEX_TABLE[s[i as usize] as usize];
                let h2 = HEX_TABLE[s[( i + 1 ) as usize] as usize];
                let h3 = HEX_TABLE[s[( i + 2 ) as usize] as usize];
                let h4 = HEX_TABLE[s[( i + 3 ) as usize] as usize];

                if h1 | h2 | h3 | h4 == 0xff { return Err( InvalidUuid( s ) ); }

                buf[j * 2] = SHL4_TABLE[h1 as usize] | h2;
                buf[j * 2 + 1] = SHL4_TABLE[h3 as usize] | h4;
                j += 1;
            }

            Ok( buf )
        }

        const HEX_TABLE:&[u8; 256] = &
        {
            let mut buf = [0; 256];
            let mut i: u8 = 0;

            loop
            {
                buf[i as usize] = match i
                {
                    b'0'..=b'9' => i - b'0',
                    b'a'..=b'f' => i - b'a' + 10,
                    b'A'..=b'F' => i - b'A' + 10,
                    _ => 0xff,
                };

                if i == 255 { break buf; }

                i += 1
            }
        };

        const SHL4_TABLE:&[u8; 256] = &
        {
            let mut buf = [0; 256];
            let mut i: u8 = 0;

            loop
            {
                buf[i as usize] = i.wrapping_shl( 4 );

                if i == 255 {
                    break buf;
                }

                i += 1;
            }
        };
    }
    
    pub mod rng
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        trait Rng
        {
            fn u128() -> u128;
            fn u64() -> u64;
            fn u16() -> u16;
        }

        pub fn u128() -> u128 { imp::RngImp::u128() }

        pub fn u64() -> u64 { imp::RngImp::u64() }

        pub fn u16() -> u16 { imp::RngImp::u16() }
        
        mod imp 
        {
            /*
            Random support for non `wasm32-unknown-unknown` platforms. */
            use super::*;

            pub struct RngImp;
            
            impl Rng for RngImp
            {
                fn u128() -> u128 { rand::random() }
                fn u64() -> u64 { rand::random() }
                fn u16() -> u16 { rand::random() }
            }
        }
    }

    pub mod timestamp
    {
        /*!
        Generating UUIDs from timestamps. */
        use ::
        {
            uuid::{ Uuid },
            *,
        };
        /*
        */
        /// The number of 100 nanosecond ticks between the RFC 9562 epoch
        /// ( `1582-10-15 00:00:00` ) and the Unix epoch ( `1970-01-01 00:00:00` ).
        pub const UUID_TICKS_BETWEEN_EPOCHS: u64 = 0x01B2_1DD2_1381_4000;
        /// A timestamp that can be encoded into a UUID.
        #[derive( Debug, Clone, Copy, PartialEq, Eq, Hash )]
        pub struct Timestamp
        {
            seconds: u64,
            subsec_nanos: u32,
            counter: u128,
            usable_counter_bits: u8,
        }

        impl Timestamp
        {
            /// Get a timestamp representing the current system time and up to a 128-bit counter.
            pub fn now( context:impl ClockSequence<Output = impl Into<u128>> ) -> Self
            {
                let ( seconds, subsec_nanos ) = now();
                let ( c, s, n ) = context.generate_timestamp_sequence( seconds, subsec_nanos );
                let c = c.into();
                let usable_counter_bits = context.usable_bits() as u8;
                Timestamp
                {
                    seconds:s,
                    subsec_nanos:n,
                    counter:c,
                    usable_counter_bits,
                }
            }
            /// Construct a `Timestamp` from the number of 100 nanosecond ticks since 00:00:00.00,
            /// 15 October 1582 ( the date of Gregorian reform to the Christian calendar ) and a 14-bit
            /// counter, as used in versions 1 and 6 UUIDs.
            pub const fn from_gregorian( ticks: u64, counter: u16 ) -> Self
            {
                let ( seconds, subsec_nanos ) = Self::gregorian_to_unix( ticks );

                Timestamp 
                {
                    seconds,
                    subsec_nanos,
                    counter: counter as u128,
                    usable_counter_bits: 14,
                }
            }
            /// Construct a `Timestamp` from a Unix timestamp and up to a 128-bit counter, as used in version 7 UUIDs.
            pub const fn from_unix_time( seconds:u64, subsec_nanos:u32, counter:u128, usable_counter_bits:u8 ) -> Self
            {
                Timestamp
                {
                    seconds,
                    subsec_nanos,
                    counter,
                    usable_counter_bits,
                }
            }
            /// Construct a `Timestamp` from a Unix timestamp and up to a 128-bit counter, as used in version 7 UUIDs.
            pub fn from_unix
            ( 
                context: impl ClockSequence<Output = impl Into<u128>>,
                seconds: u64,
                subsec_nanos: u32,
            ) -> Self
            {
                let ( counter, seconds, subsec_nanos ) = context.generate_timestamp_sequence( seconds, subsec_nanos );
                let counter = counter.into();
                let usable_counter_bits = context.usable_bits() as u8;

                Timestamp
                {
                    seconds,
                    subsec_nanos,
                    counter,
                    usable_counter_bits,
                }
            }
            /// Get the value of the timestamp as the number of 100 nanosecond ticks since 00:00:00.00,
            /// 15 October 1582 and a 14-bit counter, as used in versions 1 and 6 UUIDs.
            pub const fn to_gregorian( &self ) -> ( u64, u16 )
            {
                ( 
                    Self::unix_to_gregorian_ticks( self.seconds, self.subsec_nanos ),
                    ( self.counter as u16 ) & 0x3FFF,
                )
            }
            /// Get the value of the timestamp as a Unix timestamp, as used in version 7 UUIDs.
            pub const fn to_unix( &self ) -> ( u64, u32 ) { ( self.seconds, self.subsec_nanos ) }

            const fn unix_to_gregorian_ticks( seconds: u64, nanos: u32 ) -> u64
            {
                UUID_TICKS_BETWEEN_EPOCHS
                .wrapping_add( seconds.wrapping_mul( 10_000_000 ) )
                .wrapping_add( nanos as u64 / 100 )
            }

            const fn gregorian_to_unix( ticks: u64 ) -> ( u64, u32 )
            {
                ( 
                    ticks.wrapping_sub( UUID_TICKS_BETWEEN_EPOCHS ) / 10_000_000,
                    ( ticks.wrapping_sub( UUID_TICKS_BETWEEN_EPOCHS ) % 10_000_000 ) as u32 * 100,
                )
            }
        }

        #[doc( hidden )]
        impl Timestamp
        {
            #[deprecated( 
                since = "1.10.0",
                note = "use `Timestamp::from_gregorian( ticks, counter )`"
            )]
            pub const fn from_rfc4122( t:u64, c:u16 ) -> Self { Timestamp::from_gregorian( t, c ) }

            #[deprecated( since = "1.10.0", note = "use `Timestamp::to_gregorian()`" )]
            pub const fn to_rfc4122( &self ) -> ( u64, u16 ) { self.to_gregorian() }

            #[deprecated( 
                since = "1.2.0",
                note = "`Timestamp::to_unix_nanos()` is deprecated: use `Timestamp::to_unix()`"
            )]
            pub const fn to_unix_nanos( &self ) -> u32
            {
                panic!( "`Timestamp::to_unix_nanos()` is deprecated: use `Timestamp::to_unix()`" )
            }
        }
        
        impl ::convert::TryFrom<std::time::SystemTime> for Timestamp
        {
            type Error = super::Error;
            /// Perform the conversion.
            fn try_from( st: ::time::std::SystemTime ) -> Result<Self, Self::Error>
            {
                let dur = st.duration_since( ::time::std::UNIX_EPOCH )
                .map_err( |_| super::Error( super::error::ErrorKind::InvalidSystemTime( "unable to convert the system tie into a Unix timestamp" ) ) )?;

                Ok( Self::from_unix_time
                ( 
                    dur.as_secs(),
                    dur.subsec_nanos(),
                    0,
                    0,
                ) )
            }
        }
        
        impl From<Timestamp> for ::time::std::SystemTime
        {
            fn from( ts: Timestamp ) -> Self
            {
                let ( seconds, subsec_nanos ) = ts.to_unix();
                Self::UNIX_EPOCH + std::time::Duration::new( seconds, subsec_nanos )
            }
        }

        pub const fn encode_gregorian_timestamp
        ( 
            ticks: u64,
            counter: u16,
            node_id:&[u8; 6],
        ) -> Uuid
        {
            let time_low = ( ticks & 0xFFFF_FFFF ) as u32;
            let time_mid = (( ticks >> 32 ) & 0xFFFF ) as u16;
            let time_high_and_version = (( ( ticks >> 48 ) & 0x0FFF ) as u16 ) | ( 1 << 12 );
            let mut d4 = [0; 8];

            d4[0] = (( ( counter & 0x3F00 ) >> 8 ) as u8 ) | 0x80;
            d4[1] = ( counter & 0xFF ) as u8;
            d4[2] = node_id[0];
            d4[3] = node_id[1];
            d4[4] = node_id[2];
            d4[5] = node_id[3];
            d4[6] = node_id[4];
            d4[7] = node_id[5];

            Uuid::from_fields( time_low, time_mid, time_high_and_version, &d4 )
        }

        pub const fn decode_gregorian_timestamp( uuid:&Uuid ) -> ( u64, u16 )
        {
            let bytes = uuid.as_bytes();

            let ticks: u64 = (( bytes[6] & 0x0F ) as u64 ) << 56
            | ( bytes[7] as u64 ) << 48
            | ( bytes[4] as u64 ) << 40
            | ( bytes[5] as u64 ) << 32
            | ( bytes[0] as u64 ) << 24
            | ( bytes[1] as u64 ) << 16
            | ( bytes[2] as u64 ) << 8
            | ( bytes[3] as u64 );

            let counter: u16 = (( bytes[8] & 0x3F ) as u16 ) << 8 | ( bytes[9] as u16 );

            ( ticks, counter )
        }

        pub const fn encode_sorted_gregorian_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6] ) -> Uuid
        {
            let time_high = (( ticks >> 28 ) & 0xFFFF_FFFF ) as u32;
            let time_mid = (( ticks >> 12 ) & 0xFFFF ) as u16;
            let time_low_and_version = (( ticks & 0x0FFF ) as u16 ) | ( 0x6 << 12 );

            let mut d4 = [0; 8];

            d4[0] = (( ( counter & 0x3F00 ) >> 8 ) as u8 ) | 0x80;
            d4[1] = ( counter & 0xFF ) as u8;
            d4[2] = node_id[0];
            d4[3] = node_id[1];
            d4[4] = node_id[2];
            d4[5] = node_id[3];
            d4[6] = node_id[4];
            d4[7] = node_id[5];

            Uuid::from_fields( time_high, time_mid, time_low_and_version, &d4 )
        }

        pub const fn decode_sorted_gregorian_timestamp( uuid:&Uuid ) -> ( u64, u16 )
        {
            let bytes = uuid.as_bytes();
            let ticks: u64 = (( bytes[0] ) as u64 ) << 52
            | ( bytes[1] as u64 ) << 44
            | ( bytes[2] as u64 ) << 36
            | ( bytes[3] as u64 ) << 28
            | ( bytes[4] as u64 ) << 20
            | ( bytes[5] as u64 ) << 12
            | ( ( bytes[6] & 0xF ) as u64 ) << 8
            | ( bytes[7] as u64 );

            let counter: u16 = (( bytes[8] & 0x3F ) as u16 ) << 8 | ( bytes[9] as u16  );

            ( ticks, counter )
        }

        pub const fn encode_unix_timestamp_millis(  millis: u64, counter_random_bytes:&[u8; 10] ) -> Uuid
        {
            let millis_high = (( millis >> 16 ) & 0xFFFF_FFFF ) as u32;
            let millis_low = ( millis & 0xFFFF ) as u16;

            let counter_random_version = ( counter_random_bytes[1] as u16
            | ( ( counter_random_bytes[0] as u16 ) << 8 ) & 0x0FFF )
            | ( 0x7 << 12 );

            let mut d4 = [0; 8];

            d4[0] = ( counter_random_bytes[2] & 0x3F ) | 0x80;
            d4[1] = counter_random_bytes[3];
            d4[2] = counter_random_bytes[4];
            d4[3] = counter_random_bytes[5];
            d4[4] = counter_random_bytes[6];
            d4[5] = counter_random_bytes[7];
            d4[6] = counter_random_bytes[8];
            d4[7] = counter_random_bytes[9];

            Uuid::from_fields( millis_high, millis_low, counter_random_version, &d4 )
        }

        pub const fn decode_unix_timestamp_millis( uuid:&Uuid ) -> u64
        {
            let bytes = uuid.as_bytes();

            let millis: u64 = ( bytes[0] as u64 ) << 40
            | ( bytes[1] as u64 ) << 32
            | ( bytes[2] as u64 ) << 24
            | ( bytes[3] as u64 ) << 16
            | ( bytes[4] as u64 ) << 8
            | ( bytes[5] as u64 );

            millis
        }
        
        fn now() -> ( u64, u32 )
        {
            let dur = ::time::std::SystemTime::UNIX_EPOCH.elapsed()
            .expect( "Getting elapsed time since UNIX_EPOCH. If this fails, we've somehow violated causality",  );

            ( dur.as_secs(), dur.subsec_nanos() )
        }
        /// A counter that can be used by versions 1 and 6 UUIDs to support the uniqueness of timestamps.
        pub trait ClockSequence
        {
            /// The type of sequence returned by this counter.
            type Output;
            /// Get the next value in the sequence to feed into a timestamp.
            fn generate_sequence( &self, seconds: u64, subsec_nanos: u32 ) -> Self::Output;
            /// Get the next value in the sequence, potentially also adjusting the timestamp.
            fn generate_timestamp_sequence
            ( 
                &self,
                seconds:u64,
                subsec_nanos:u32
            ) -> ( Self::Output, u64, u32 )
            {
                ( 
                    self.generate_sequence( seconds, subsec_nanos ),
                    seconds,
                    subsec_nanos,
                )
            }
            /*
            The number of usable bits from the least significant bit in the result of 
            `ClockSequence::generate_sequence` or `ClockSequence::generate_timestamp_sequence`. */
            fn usable_bits( &self ) -> usize where
            Self::Output: Sized
            {
                cmp::min( 128, ::mem::size_of::<Self::Output>() )
            }
        }

        impl<'a, T:ClockSequence + ?Sized> ClockSequence for &'a T
        {
            type Output = T::Output;

            fn generate_sequence( &self, seconds: u64, subsec_nanos: u32 ) -> Self::Output
            { ( **self ).generate_sequence( seconds, subsec_nanos ) }

            fn generate_timestamp_sequence
            ( 
                &self,
                seconds: u64,
                subsec_nanos: u32
            ) -> ( Self::Output, u64, u32 )
            { ( **self ).generate_timestamp_sequence( seconds, subsec_nanos ) }

            fn usable_bits( &self ) -> usize where
            Self::Output: Sized
            { ( **self ).usable_bits() }
        }
        /// Default implementations for the [`ClockSequence`] trait.
        pub mod context
        {
            use super::ClockSequence;
            /// An empty counter that will always return the value `0`.
            #[derive( Debug, Clone, Copy, Default )]
            pub struct NoContext;

            impl ClockSequence for NoContext
            {
                type Output = u16;

                fn generate_sequence( &self, _seconds: u64, _nanos: u32 ) -> Self::Output { 0 }

                fn usable_bits( &self ) -> usize { 0 }
            }
        }
    } pub use self::timestamp::{ context::NoContext, ClockSequence, Timestamp };
    /*
    */
    /// A 128-bit ( 16 byte ) buffer containing the UUID.
    pub type Bytes = [u8; 16];
    /// The version of the UUID, denoting the generating algorithm.
    #[repr( u8 )] #[non_exhaustive] #[derive( Clone, Copy, Debug, PartialEq )]
    pub enum Version
    {
        /// The "nil" ( all zeros ) UUID.
        Nil = 0u8,
        /// Version 1: Timestamp and node ID.
        Mac = 1,
        /// Version 2: DCE Security.
        Dce = 2,
        /// Version 3: MD5 hash.
        Md5 = 3,
        /// Version 4: Random.
        Random = 4,
        /// Version 5: SHA-1 hash.
        Sha1 = 5,
        /// Version 6: Sortable Timestamp and node ID.
        SortMac = 6,
        /// Version 7: Timestamp and random.
        SortRand = 7,
        /// Version 8: Custom.
        Custom = 8,
        /// The "max" ( all ones ) UUID.
        Max = 0xff,
    }
    /// The reserved variants of UUIDs.
    #[repr( u8 )] #[non_exhaustive] #[derive( Clone, Copy, Debug, PartialEq )]
    pub enum Variant
    {
        /// Reserved by the NCS for backward compatibility.
        NCS = 0u8,
        /// As described in the RFC 9562 Specification ( default ).
        RFC4122,
        /// Reserved by Microsoft for backward compatibility.
        Microsoft,
        /// Reserved for future expansion.
        Future,
    }
    /// A Universally Unique Identifier ( UUID ).
    #[repr( transparent )] #[derive( Clone, Copy, Eq, Ord, PartialEq, PartialOrd )]
    pub struct Uuid( Bytes );

    impl Uuid
    {
        /// UUID namespace for Domain Name System ( DNS ).
        pub const NAMESPACE_DNS: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );
        /// UUID namespace for ISO Object Identifiers ( OIDs ).
        pub const NAMESPACE_OID: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x12, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );
        /// UUID namespace for Uniform Resource Locators ( URLs ).
        pub const NAMESPACE_URL: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x11, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );
        /// UUID namespace for X.500 Distinguished Names ( DNs ).
        pub const NAMESPACE_X500: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x14, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );
        /// Returns the variant of the UUID structure.
        pub const fn get_variant( &self ) -> Variant
        {
            match self.as_bytes()[8] 
            {
                x if x & 0x80 == 0x00 => Variant::NCS,
                x if x & 0xc0 == 0x80 => Variant::RFC4122,
                x if x & 0xe0 == 0xc0 => Variant::Microsoft,
                x if x & 0xe0 == 0xe0 => Variant::Future,
                _ => Variant::Future,
            }
        }
        /// Returns the version number of the UUID.
        pub const fn get_version_num( &self ) -> usize
        {
            ( self.as_bytes()[6] >> 4 ) as usize
        }
        /// Returns the version of the UUID.
        pub const fn get_version( &self ) -> Option<Version>
        {
            match self.get_version_num()
            {
                0 if self.is_nil() => Some( Version::Nil ),
                1 => Some( Version::Mac ),
                2 => Some( Version::Dce ),
                3 => Some( Version::Md5 ),
                4 => Some( Version::Random ),
                5 => Some( Version::Sha1 ),
                6 => Some( Version::SortMac ),
                7 => Some( Version::SortRand ),
                8 => Some( Version::Custom ),
                0xf => Some( Version::Max ),
                _ => None,
            }
        }
        /// Returns the four field values of the UUID.
        pub fn as_fields( &self ) -> ( u32, u16, u16, &[u8; 8] )
        {
            let bytes = self.as_bytes();

            let d1 = ( bytes[0] as u32 ) << 24
            | ( bytes[1] as u32 ) << 16
            | ( bytes[2] as u32 ) << 8
            | ( bytes[3] as u32 );

            let d2 = ( bytes[4] as u16 ) << 8 | ( bytes[5] as u16 );

            let d3 = ( bytes[6] as u16 ) << 8 | ( bytes[7] as u16 );

            let d4:&[u8; 8] = convert::TryInto::try_into( &bytes[8..16] ).unwrap();
            ( d1, d2, d3, d4 )
        }
        /// Returns the four field values of the UUID in little-endian order.
        pub fn to_fields_le( &self ) -> ( u32, u16, u16, &[u8; 8] )
        {
            let d1 = ( self.as_bytes()[0] as u32 )
            | ( self.as_bytes()[1] as u32 ) << 8
            | ( self.as_bytes()[2] as u32 ) << 16
            | ( self.as_bytes()[3] as u32 ) << 24;

            let d2 = ( self.as_bytes()[4] as u16 ) | ( self.as_bytes()[5] as u16 ) << 8;

            let d3 = ( self.as_bytes()[6] as u16 ) | ( self.as_bytes()[7] as u16 ) << 8;

            let d4:&[u8; 8] = convert::TryInto::try_into( &self.as_bytes()[8..16] ).unwrap();
            ( d1, d2, d3, d4 )
        }
        /// Returns a 128bit value containing the value.
        pub const fn as_u128( &self ) -> u128 { u128::from_be_bytes( *self.as_bytes() ) }
        /// Returns a 128bit little-endian value containing the value.
        pub const fn to_u128_le( &self ) -> u128 { u128::from_le_bytes( *self.as_bytes() ) }
        /// Returns two 64bit values containing the value.
        pub const fn as_u64_pair( &self ) -> ( u64, u64 )
        {
            let value = self.as_u128();
            ( ( value >> 64 ) as u64, value as u64 )
        }
        /// Returns a slice of 16 octets containing the value.
        #[inline] pub const fn as_bytes( &self ) -> &Bytes { &self.0 }
        /// Consumes self and returns the underlying byte value of the UUID.
        #[inline] pub const fn into_bytes( self ) -> Bytes { self.0 }
        /// Returns the bytes of the UUID in little-endian order.
        pub const fn to_bytes_le( &self ) -> Bytes
        {[
            self.0[3], self.0[2], self.0[1], self.0[0], self.0[5], self.0[4], self.0[7], self.0[6], 
            self.0[8], self.0[9], self.0[10], self.0[11], self.0[12], self.0[13], self.0[14], self.0[15],
        ]}
        /// Tests if the UUID is nil ( all zeros ).
        pub const fn is_nil( &self ) -> bool { self.as_u128() == u128::MIN }
        /// Tests if the UUID is max ( all ones ).
        pub const fn is_max( &self ) -> bool { self.as_u128() == u128::MAX }
        /// A buffer used for `encode_...` calls, that is guaranteed to be long enough for any of the format adapters.
        pub const fn encode_buffer() -> [ u8; fmt::Urn::LENGTH ] { [0; fmt::Urn::LENGTH] }
        /// If the UUID is the correct version, this will return the timestamp in a version-agnostic [`Timestamp`].
        pub const fn get_timestamp( &self ) -> Option<Timestamp>
        {
            match self.get_version()
            {
                Some( Version::Mac ) =>
                {
                    let ( ticks, counter ) = timestamp::decode_gregorian_timestamp( self );
                    Some( Timestamp::from_gregorian( ticks, counter ) )
                }

                Some( Version::SortMac ) =>
                {
                    let ( ticks, counter ) = timestamp::decode_sorted_gregorian_timestamp( self );
                    Some( Timestamp::from_gregorian( ticks, counter ) )
                }

                Some( Version::SortRand ) =>
                {
                    let millis = timestamp::decode_unix_timestamp_millis( self );
                    let seconds = millis / 1000;
                    let nanos = (( millis % 1000 ) * 1_000_000 ) as u32;
                    Some( Timestamp::from_unix_time( seconds, nanos, 0, 0 ) )
                }

                _ => None,
            }
        }
        /// If the UUID is the correct version, this will return the node value as a 6-byte array.
        pub const fn get_node_id( &self ) -> Option<[u8; 6]>
        {
            match self.get_version()
            {
                Some( Version::Mac ) | Some( Version::SortMac ) =>
                {
                    let mut node_id = [0; 6];
                    node_id[0] = self.0[10];
                    node_id[1] = self.0[11];
                    node_id[2] = self.0[12];
                    node_id[3] = self.0[13];
                    node_id[4] = self.0[14];
                    node_id[5] = self.0[15];
                    Some( node_id )
                }
                _ => None,
            }
        }
        /// Creates a random UUID.
        pub fn new_v4() -> Uuid
        {
            Uuid::from_u128( uuid::rng::u128() & 0xFFFFFFFFFFFF4FFFBFFFFFFFFFFFFFFF | 0x40008000000000000000 )
        }
    }

    impl Hash for Uuid
    {
        fn hash<H:Hasher>( &self, state:&mut H ) { state.write( &self.0  ); }
    }

    impl Default for Uuid
    {
        #[inline] fn default() -> Self { Uuid::nil() }
    }

    impl AsRef<Uuid> for Uuid
    {
        #[inline] fn as_ref( &self ) -> &Uuid { self }
    }

    impl AsRef<[u8]> for Uuid
    {
        #[inline] fn as_ref( &self ) -> &[u8] { &self.0 }
    }
    
    impl From<Uuid> for Vec<u8>
    {
        fn from( value: Uuid ) -> Self { value.0.to_vec() }
    }
    
    impl ::convert::TryFrom<Vec<u8>> for Uuid
    {
        type Error = error::Error;
        fn try_from( value:Vec<u8> ) -> Result<Self, Self::Error> { Uuid::from_slice( &value ) }
    }
}

pub mod values
{
    /*!
    */
    use ::
    {
        arrays::{ self, Arr },
        error::{ OverError },
        fmt::{ Format },
        num::
        {
            big::BigInt,
            rational::BigRational,
            traits::ToPrimitive,
        },
        objects::{ self, Obj },
        result::{ OverResult },
        tuples::{ self, Tup },
        types::{ Type },
        *,
    };
    /*
    
    use crate::{OverResult, INDENT_STEP};
    */
    macro_rules! get_fn
    {
        ( $doc:expr, $name:tt, $type:ty, $variant:ident ) =>
        {
            #[doc=$doc]
            pub fn $name( &self ) -> OverResult<$type> {
                if let Value::$variant( ref inner ) = *self {
                    Ok( inner.clone() )
                } else {
                    Err( OverError::TypeMismatch( Type::$variant, self.get_type() ) )
                }
            }
        }
    }

    macro_rules! impl_eq
    {
        ( $valtype:ident, $type:ty ) =>
        {
            impl PartialEq<$type> for Value
            {
                fn eq( &self, other:&$type ) -> bool
                {
                    match *self
                    {
                        Value::$valtype( ref value ) => value == other,
                        _ => false,
                    }
                }
            }
            
            impl PartialEq<Value> for $type
            {
                fn eq( &self, other:&Value ) -> bool
                {
                    match *other
                    {
                        Value::$valtype( ref value ) => value == self,
                        _ => false,
                    }
                }
            }
        };
    }
    
    macro_rules! impl_eq_int
    {
        ( $type:ty, $fn:tt ) =>
        {
            impl PartialEq<$type> for Value
            {
                fn eq( &self, other:&$type ) -> bool
                {
                    match *self
                    {
                        Value::Int( ref value ) => match value.$fn()
                        {
                            Some( value ) => value == *other,
                            None => false,
                        },
                        _ => false,
                    }
                }
            }
            
            impl PartialEq<Value> for $type
            {
                fn eq( &self, other:&Value ) -> bool
                {
                    match *other
                    {
                        Value::Int( ref value ) => match value.$fn()
                        {
                            Some( value ) => value == *self,
                            None => false,
                        },
                        _ => false,
                    }
                }
            }
        };
    }

    macro_rules! impl_from
    {
        ( $type:ty, $fn:tt ) =>
        {
            impl From<$type> for Value
            {
                fn from( inner: $type ) -> Self { Value::$fn( inner.into() ) }
            }
        };
    }
    /// Enum of possible values and their inner types.
    #[derive( Clone, Debug, PartialEq )]
    pub enum Value
    {
        /// A null value.
        Null,
        /// A boolean value.
        Bool( bool ),
        /// A signed integer value.
        Int( BigInt ),
        /// A signed integer value.
        Integer( i32 ),
        /// A fractional value.
        Frac( BigRational ),
        /// A character value.
        Char( char ),
        /// A string value.
        Str( String ),
        /// An ASCII string requiring expansion.
        Strand( String ),
        /// An array value.
        Arr( Arr ),
        /// A tuple value.
        Tup( Tup ),
        /// An object value.
        Obj( Obj ),
    }

    impl Value
    {
        /// Returns true if this `Value` is null.
        pub fn is_null( &self ) -> bool 
        {
            if let Value::Null = *self { true }
            else { false }
        }
        /// Returns the `Type` of this `Value`.
        pub fn get_type( &self ) -> Type
        {
            use self::Value::*;

            match *self
            {
                Null => Type::Null,
                Bool( _ ) => Type::Bool,
                Int( _ ) => Type::Int,
                Integer( _ ) => Type::Integer,
                Frac( _ ) => Type::Frac,
                Char( _ ) => Type::Char,
                Str( _ ) => Type::Str,
                Strand( _ ) => Type::Strand,
                Arr( ref arr ) => Type::Arr( Box::new( arr.inner_type() ) ),
                Tup( ref tup ) => Type::Tup( tup.inner_type_vec() ),
                Obj( _ ) => Type::Obj,
            }
        }

        get_fn!( r#"Returns the `bool` contained in this `Value`."#, get_bool, bool, Bool  );        
        get_fn! ( "Returns the `BigInt` contained in this `Value`.", get_int, BigInt, Int  );
        /// Returns the `BigRational` contained in this `Value`.
        pub fn get_frac( &self ) -> OverResult<BigRational>
        {
            match *self 
            {
                Value::Frac( ref inner ) => Ok( inner.clone() ),
                Value::Int( ref inner ) => Ok( frac!( inner.clone(), 1 ) ),
                _ => Err( OverError::TypeMismatch( Type::Frac, self.get_type() ) ),
            }
        }

        get_fn!( "Returns the `char` contained in this `Value`.", get_char, char, Char  );        
        get_fn!( r#"Returns the `String` contained in this `Value`."#, get_str, String, Str  );        
        get_fn!( "Returns the `Obj` contained in this `Value`.", get_obj, objects::Obj, Obj  );
        /// Returns the `Arr` contained in this `Value`.
        pub fn get_arr( &self ) -> OverResult<arrays::Arr>
        {
            if let Value::Arr( ref inner ) = *self { Ok( inner.clone() ) }
            else
            {
                Err
                ( 
                    OverError::TypeMismatch
                    ( 
                        Type::Arr( Box::new( Type::Any ) ),
                        self.get_type(),
                    )
                )
            }
        }
        /// Returns the `Tup` contained in this `Value`.
        pub fn get_tup( &self ) -> OverResult<tuples::Tup>
        {
            if let Value::Tup( ref inner ) = *self { Ok( inner.clone() ) }
            else { Err( OverError::TypeMismatch( Type::Tup( vec![] ), self.get_type() ) ) }
        }
    }

    impl From<()> for Value
    {
        fn from( _: () ) -> Self { Value::Bool( true ) }
    }
    
    impl fmt::Display for Value
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl_eq!( Bool, bool );
    impl_eq!( Int, BigInt );
    impl_eq!( Frac, BigRational );
    impl_eq!( Char, char );
    impl_eq!( Arr, arrays::Arr );
    impl_eq!( Tup, tuples::Tup );
    impl_eq!( Obj, objects::Obj );

    impl<'a> PartialEq<&'a str> for Value
    {
        fn eq( &self, other:&&str ) -> bool
        {
            match *self
            {
                Value::Str( ref value ) => value == &other.replace( "\r\n", "\n" ),
                _ => false,
            }
        }
    }

    impl<'a> PartialEq<Value> for &'a str
    {
        fn eq( &self, other:&Value ) -> bool
        {
            match *other
            {
                Value::Str( ref value ) => value == &self.replace( "\r\n", "\n" ),
                _ => false,
            }
        }
    }

    impl PartialEq<String> for Value
    {
        fn eq( &self, other:&String ) -> bool
        {
            &other.as_str() == self
        }
    }

    impl PartialEq<Value> for String
    {
        fn eq( &self, other:&Value ) -> bool
        {
            &self.as_str() == other
        }
    }

    impl_eq_int!( usize, to_usize );
    impl_eq_int!( u8, to_u8 );
    impl_eq_int!( u16, to_u16 );
    impl_eq_int!( u32, to_u32 );
    impl_eq_int!( u64, to_u64 );
    impl_eq_int!( i8, to_i8 );
    impl_eq_int!( i16, to_i16 );
    impl_eq_int!( i32, to_i32 );
    impl_eq_int!( i64, to_i64 );
    
    impl<'a> From<&'a str> for Value 
    {
        fn from( inner:&str ) -> Self 
        {
            Value::Str( inner.into() )
        }
    }

    impl_from!( bool, Bool );
    impl_from!( usize, Int );
    impl_from!( u8, Int );
    impl_from!( u16, Int );
    impl_from!( u32, Int );
    impl_from!( u64, Int );
    impl_from!( i8, Int );
    impl_from!( i16, Int );
    impl_from!( i32, Int );
    impl_from!( i64, Int );
    impl_from!( BigInt, Int );
    impl_from!( BigRational, Frac );
    impl_from!( char, Char );
    impl_from!( String, Str );
    impl_from!( arrays::Arr, Arr  );
    impl_from!( tuples::Tup, Tup  );
    impl_from!( objects::Obj, Obj  );
}

pub mod vec
{
    pub use std::vec::{ * };
}
/// Indent step in .over files.
pub const INDENT_STEP: usize = 4;

pub fn main() -> Result<(), error::parse::ParseError>
{
    unsafe
    {
        use ::system::api::{ * };

        let _ = ::system::common::build()?;
        let document = ::parses::load_from_str( ::system::common::DATABASE.as_str() )?;
        println!
        ( 
            r#"{}"#,
            //::system::common::INFORMATION
            document.read( "aliases" )?,
         );

        signal( SIG_PIPE, SIG_DFL );
        signal( SIG_TSTP, SIG_IGN );
        signal( SIG_QUIT, SIG_IGN );

        env::initialize_paths();

        let mut sh = shell::Shell::new();
        let args:Vec<String> = env::args().collect();

        if is::login( &args )
        {
            rc::file::run( &mut sh );
            sh.is_login = true;
        }

        // Initialize command cache for highlighting
        highlights::initialize();
        highlights::update( &sh );
        
        if is::script( &args )
        {
            //log!( "run script: {:?} ", &args );
            let status = scripts::run( &mut sh, &args );
            ::process::exit( status );
        }
        
        if is::command_string( &args )
        {
            let line = env::args_to_command_line();
            now::run_command_line( &mut sh, &line, false, false );
            ::process::exit( sh.previous_status );
        }

        if is::non_tty()
        {
            now::run_procs_for_non_tty( &mut sh );
            return;
        }

        let mut rl;
        match ::system::interface::Interface::new( "cicada" )
        {
            Ok( x ) => rl = x,
            Err( e ) => 
            {
                println!( ":: lineread error: {}", e );
                return;
            }
        }
        
        rl.define_function( "enter-function", ::sync::Arc::new( prompts::EnterFunction ) );
        rl.bind_sequence( "\r", types::Command::from_str( "enter-function" ) );
    }
    /*
    let document = ::parses::load_from_str
    ( 
        r#"receipt: "Oz-Ware Purchase Invoice"
            date:    "2012-08-06"
            customer: {
                first_name:  "Dorothy"
                family_name: "Gale"
            }

            items: [
                    {
                    part_no:  "A4786"
                    descrip:  "Water Bucket ( Filled )"
                    price:    01.47
                    quantity: 4
                    }
                    {
                    part_no:  "E1628"
                    descrip:  "High Heeled \"Ruby\" Slippers"
                    size:     8
                    price:    133.70
                    quantity: 1
                    }
                ]

            bill_to: {
                street:
                # A multi-line string. Can also be written as "123 Tornado Alley\nSuite16"
            "123 Tornado Alley
            Suite 16"
                city:  "East Centerville"
                state: "KS"
            }

            ship_to: bill_to

            specialDelivery:
            "Follow the Yellow Brick Road to the Emerald City. Pay no attention to the man behind the curtain."
    "# )?;
    
    assert_eq!( document.read( "receipt" )?, "Oz-Ware Purchase Invoice" );
    assert_eq!( document.read( "date"    )?, "2012-08-06"               );
    assert_eq!
    ( 
        document.read( "customer" )?,
        obj!
        { 
            "first_name"  => "Dorothy", 
            "family_name" => "Gale"
        }
     );

    assert_eq!
    ( 
        document.read( "items" )?,
        arr!
        [
            obj!
            {
                "part_no" => "A4786",
                "descrip" => "Water Bucket ( Filled )",
                "price" => frac!( 147,100 ),
                "quantity" => 4
            },

            obj!
            {
                "part_no" => "E1628",
                "descrip" => "High Heeled \"Ruby\" Slippers",
                "size" => 8,
                "price" => frac!( 1337,10 ),
                "quantity" => 1
            },
        ]
     );

    assert_eq!
    ( 
        document.read( "bill_to" )?,
        obj!
        {
            "street" => "123 Tornado Alley\nSuite 16",
            "city" => "East Centerville",
            "state" => "KS",
        }
     );

    assert_eq!
    ( 
        document.read( "ship_to" )?,
        document.read( "bill_to" )?,
     );

    assert_eq!
    ( 
        document.read( "specialDelivery" )?,
        r#"Follow the Yellow Brick Road to the Emerald City.
        Pay no attention to the man behind the curtain."#
     ); */

    /*
    */
    Ok( () )
}
// 43737 /////////////////////////////////////////////////////////////////////////////////////////////////////////////
